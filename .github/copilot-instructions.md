# Polar AI Agent Instructions

This document provides essential guidance for AI agents contributing to the Polar codebase.

## Architecture Overview

Polar is a monorepo containing a Python backend and a TypeScript/Next.js frontend.

-   **`server/`**: The backend is a Python application built with the **FastAPI** framework.
    -   **Database**: It uses **PostgreSQL** as its database, with **SQLAlchemy** as the ORM. Database models are located in `server/polar/models`.
    -   **Background Jobs**: Asynchronous tasks are handled by **Dramatiq** workers.
    -   **API**: The core API logic is in `server/polar/`, with routes organized into modules.
-   **`clients/`**: The frontend is a **Next.js** application managed with **Turborepo** and **pnpm**.
    -   **`clients/apps/web/`**: This is the main web dashboard application.
    -   **`clients/packages/ui/`**: A shared library of React components built with Radix UI and Tailwind CSS.
    -   **`clients/packages/client/`**: The generated API client and data-fetching hooks.

## Development Workflow

The primary setup and workflow instructions are in `DEVELOPMENT.md`.

### Setup

1.  **Environment Variables**: Run `./dev/setup-environment` to create the necessary `.env` files for both the server and the web client.
2.  **Dependencies**:
    -   Backend (in `server/`): Use `uv sync` to install Python dependencies.
    -   Frontend (in `clients/`): Use `pnpm install` to install JavaScript dependencies.

### Running the Application

-   **Backend**: In the `server/` directory, run the following commands in separate terminals:
    -   `uv run task api` to start the FastAPI server (http://127.0.0.1:8000).
    -   `uv run task worker` to start the Dramatiq background worker.
-   **Frontend**: In the `clients/` directory, run `pnpm run dev` to start the Next.js development server (http://127.0.0.1:3000).

### Database Migrations

The project uses Alembic for database migrations, located in `server/migrations/`. To apply migrations, run `uv run task db_migrate` from the `server/` directory. When creating a new model, you'll need to generate a new migration script.

## Backend Conventions

-   **Services**: Business logic is encapsulated in service classes. For example, `ProductService` in `server/polar/product/service.py` contains logic for managing products. When adding new business logic, prefer adding it to a service class.
-   **Schemas**: Pydantic schemas are used for API request/response validation and serialization. These are typically defined in `server/polar/{module}/schemas.py`.
-   **API Client Generation**: The frontend's TypeScript client is generated from the backend's OpenAPI schema. After making changes to the API, you may need to run `pnpm run generate` in `clients/packages/client` to update the client.

## Frontend Conventions

-   **Data Fetching**: The frontend uses **TanStack Query** for data fetching. Hooks are generated by `openapi-typescript-codegen` and are available from the `@polar-sh/sdk` package.
-   **State Management**: Global state is managed with **Zustand**.
-   **UI Components**: Use components from the shared `clients/packages/ui` library whenever possible. These components are built on top of Tailwind CSS and Radix UI.
-   **Styling**: Use **Tailwind CSS** for styling.

## Authentication

The backend uses a custom authentication system built on FastAPI's dependency injection.

-   **`AuthSubject`**: The core of the system is the `AuthSubject[T]` type, which represents the authenticated entity. `T` can be `User`, `Organization`, `Customer`, or `Anonymous`. It's available in endpoint signatures as a dependency. If an endpoint does not have an `auth_subject` dependency, it is public and accessible to anonymous users.
-   **Protecting Endpoints**: To protect an endpoint, use one of the predefined authenticator dependencies from `server/polar/auth/dependencies.py`.
    -   `WebUser`: Requires a logged-in user (`AuthSubject[User]`).
    -   `WebUserOrAnonymous`: Allows either a logged-in user or an anonymous user (`AuthSubject[User | Anonymous]`).
    -   `AdminUser`: Requires a user with admin privileges.
-   **Module-Specific Authentication**: For more granular control, authentication models can be defined within each module's `auth.py` file. This allows creating authenticators with specific scopes and allowed subjects.
    ```python
    # server/polar/discount/auth.py
    _DiscountWrite = Authenticator(
        required_scopes={Scope.web_default, Scope.discounts_write},
        allowed_subjects={User, Organization},
    )
    DiscountWrite = Annotated[AuthSubject[User | Organization], Depends(_DiscountWrite)]
    ```
-   **Scopes**: Scopes are used to control access to specific operations. An `AuthSubject` has a set of scopes, and an `Authenticator` can define a set of `required_scopes`. Access is granted if the subject possesses at least one of the required scopes.
-   **Example**:
    ```python
    from polar.auth.dependencies import WebUser
    from polar.models import User
    from polar.discount.auth import DiscountWrite # Module-specific auth

    @router.get("/me")
    def get_me(auth_subject: WebUser) -> User:
        return auth_subject.subject

    @router.post("/discounts")
    def create_discount(auth_subject: DiscountWrite) -> Discount:
        # Only users/orgs with `web_default` or `discounts_write` can access this
        ...
    ```
-   **How it works**: The system checks for credentials in a specific order: customer session token, user session cookie, and various API tokens (OAuth2, Personal Access, Organization Access). If no valid credential is found, it defaults to an `Anonymous` subject. The endpoint's authenticator then validates if the resolved subject type and its scopes are allowed.

## Key Integrations

-   **Stripe**: Handles payments and subscriptions. Requires API keys and a webhook secret in `server/.env`.
-   **GitHub**: Used for authentication and repository-related features. Requires a GitHub App to be configured for local development.
