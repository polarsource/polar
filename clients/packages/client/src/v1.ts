/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
    "/v1/users/me": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get Authenticated */
        get: operations["users:get_authenticated"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/users/me/scopes": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Scopes */
        get: operations["users:scopes"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/users/me/identity-verification": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Create Identity Verification */
        post: operations["users:create_identity_verification"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/users/me/stripe_customer_portal": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Create Stripe Customer Portal */
        post: operations["users:create_stripe_customer_portal"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/integrations/github/authorize": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Integrations.Github.Authorize */
        get: operations["integrations_github:integrations.github.authorize"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/integrations/github/callback": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Integrations.Github.Callback */
        get: operations["integrations_github:integrations.github.callback"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/integrations/github_repository_benefit/user/authorize": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Integrations.Github Repository Benefit.User Authorize */
        get: operations["integrations_github_repository_benefit:integrations.github_repository_benefit.user_authorize"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/integrations/github_repository_benefit/user/callback": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Integrations.Github Repository Benefit.User Callback */
        get: operations["integrations_github_repository_benefit:integrations.github_repository_benefit.user_callback"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/integrations/github_repository_benefit/user/repositories": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Integrations.Github Repository Benefit.User Repositories
         * @description Lists available repositories for this user
         */
        get: operations["integrations_github_repository_benefit:integrations.github_repository_benefit.user_repositories"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/integrations/github_repository_benefit/installation/install": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Integrations.Github Repository Benefit.Installation Install */
        get: operations["integrations_github_repository_benefit:integrations.github_repository_benefit.installation_install"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/integrations/github_repository_benefit/installation/callback": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Integrations.Github Repository Benefit.Installation Callback */
        get: operations["integrations_github_repository_benefit:integrations.github_repository_benefit.installation_callback"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/integrations/discord/bot/authorize": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Integrations.Discord.Bot Authorize */
        get: operations["integrations_discord:integrations.discord.bot_authorize"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/integrations/discord/bot/callback": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Integrations.Discord.Bot Callback */
        get: operations["integrations_discord:integrations.discord.bot_callback"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/integrations/discord/guild/lookup": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Discord Guild Lookup */
        get: operations["integrations_discord:discord_guild_lookup"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/magic_link/request": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Magic Link.Request */
        post: operations["magic_link:magic_link.request"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/magic_link/authenticate": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Magic Link.Authenticate */
        post: operations["magic_link:magic_link.authenticate"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/notifications": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get */
        get: operations["notifications:get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/notifications/read": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Mark Read */
        post: operations["notifications:mark_read"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/notifications/recipients": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Lists all notification recipients subscribed to notifications
         * @description List all devices subscribed to notifications.
         *
         *     **Scopes**: `notification_recipients:read` `notification_recipients:write`
         */
        get: operations["notifications:list"];
        put?: never;
        /**
         * Subscribes a device to notifications
         * @description Create a notification recipient.
         *
         *     **Scopes**: `notification_recipients:write`
         */
        post: operations["notifications:create"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/notifications/recipients/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        /**
         * Delete
         * @description Delete a notification recipient.
         *
         *     **Scopes**: `notification_recipients:write`
         */
        delete: operations["notifications:delete"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/personal_access_tokens/": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Personal Access Tokens
         * @description List personal access tokens.
         */
        get: operations["personal_access_token:list_personal_access_tokens"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/personal_access_tokens/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        /** Delete Personal Access Token */
        delete: operations["personal_access_token:delete_personal_access_token"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/accounts/search": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Search */
        get: operations["accounts:search"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/accounts/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get */
        get: operations["accounts:get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/accounts/{id}/onboarding_link": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Onboarding Link */
        post: operations["accounts:onboarding_link"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/accounts/{id}/dashboard_link": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Dashboard Link */
        post: operations["accounts:dashboard_link"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/accounts": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Create */
        post: operations["accounts:create"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/organizations/": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Organizations
         * @description List organizations.
         *
         *     **Scopes**: `organizations:read` `organizations:write`
         */
        get: operations["organizations:list"];
        put?: never;
        /**
         * Create Organization
         * @description Create an organization.
         *
         *     **Scopes**: `organizations:write`
         */
        post: operations["organizations:create"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/organizations/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Organization
         * @description Get an organization by ID.
         *
         *     **Scopes**: `organizations:read` `organizations:write`
         */
        get: operations["organizations:get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        /**
         * Update Organization
         * @description Update an organization.
         *
         *     **Scopes**: `organizations:write`
         */
        patch: operations["organizations:update"];
        trace?: never;
    };
    "/v1/organizations/{id}/account": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Organization Account
         * @description Get the account for an organization.
         *
         *     **Scopes**: `organizations:write`
         */
        get: operations["organizations:get_account"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        /**
         * Set Organization Account
         * @description Set the account for an organization.
         *
         *     **Scopes**: `organizations:write`
         */
        patch: operations["organizations:set_account"];
        trace?: never;
    };
    "/v1/organizations/{id}/members": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Members
         * @description List members in an organization.
         *
         *     **Scopes**: `organizations:write`
         */
        get: operations["organizations:members"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/subscriptions/": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Subscriptions
         * @description List subscriptions.
         *
         *     **Scopes**: `subscriptions:read` `subscriptions:write`
         */
        get: operations["subscriptions:list"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/subscriptions/export": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Export Subscriptions
         * @description Export subscriptions as a CSV file.
         *
         *     **Scopes**: `subscriptions:read` `subscriptions:write`
         */
        get: operations["subscriptions:export"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/subscriptions/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Subscription
         * @description Get a subscription by ID.
         *
         *     **Scopes**: `subscriptions:write`
         */
        get: operations["subscriptions:get"];
        put?: never;
        post?: never;
        /**
         * Revoke Subscription
         * @description Revoke a subscription, i.e cancel immediately.
         *
         *     **Scopes**: `subscriptions:write`
         */
        delete: operations["subscriptions:revoke"];
        options?: never;
        head?: never;
        /**
         * Update Subscription
         * @description Update a subscription.
         *
         *     **Scopes**: `subscriptions:write`
         */
        patch: operations["subscriptions:update"];
        trace?: never;
    };
    "/v1/transactions/search": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Search Transactions */
        get: operations["transactions:search_transactions"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/transactions/lookup": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Lookup Transaction */
        get: operations["transactions:lookup_transaction"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/transactions/summary": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get Summary */
        get: operations["transactions:get_summary"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/transactions/payouts": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get Payout Estimate */
        get: operations["transactions:get_payout_estimate"];
        put?: never;
        /** Create Payout */
        post: operations["transactions:create_payout"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/transactions/payouts/{id}/csv": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get Payout Csv */
        get: operations["transactions:get_payout_csv"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/auth/logout": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Logout */
        get: operations["auth:logout"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/oauth2/": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Clients
         * @description List OAuth2 clients.
         */
        get: operations["oauth2:clients:list"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/oauth2/register": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Create Client
         * @description Create an OAuth2 client.
         */
        post: operations["oauth2:clients:oauth2:create_client"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/oauth2/register/{client_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Client
         * @description Get an OAuth2 client by Client ID.
         */
        get: operations["oauth2:clients:oauth2:get_client"];
        /**
         * Update Client
         * @description Update an OAuth2 client.
         */
        put: operations["oauth2:clients:oauth2:update_client"];
        post?: never;
        /**
         * Delete Client
         * @description Delete an OAuth2 client.
         */
        delete: operations["oauth2:clients:oauth2:delete_client"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/oauth2/authorize": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Authorize */
        get: operations["oauth2:authorize"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/oauth2/consent": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Consent */
        post: operations["oauth2:consent"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/oauth2/token": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Request Token
         * @description Request an access token using a valid grant.
         */
        post: operations["oauth2:request_token"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/oauth2/revoke": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Revoke Token
         * @description Revoke an access token or a refresh token.
         */
        post: operations["oauth2:revoke_token"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/oauth2/introspect": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Introspect Token
         * @description Get information about an access token.
         */
        post: operations["oauth2:introspect_token"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/oauth2/userinfo": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get User Info
         * @description Get information about the authenticated user.
         */
        get: operations["oauth2:userinfo"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/benefits/": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Benefits
         * @description List benefits.
         *
         *     **Scopes**: `benefits:read` `benefits:write`
         */
        get: operations["benefits:list"];
        put?: never;
        /**
         * Create Benefit
         * @description Create a benefit.
         *
         *     **Scopes**: `benefits:write`
         */
        post: operations["benefits:create"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/benefits/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Benefit
         * @description Get a benefit by ID.
         *
         *     **Scopes**: `benefits:read` `benefits:write`
         */
        get: operations["benefits:get"];
        put?: never;
        post?: never;
        /**
         * Delete Benefit
         * @description Delete a benefit.
         *
         *     > [!WARNING]
         *     > Every grants associated with the benefit will be revoked.
         *     > Users will lose access to the benefit.
         *
         *     **Scopes**: `benefits:write`
         */
        delete: operations["benefits:delete"];
        options?: never;
        head?: never;
        /**
         * Update Benefit
         * @description Update a benefit.
         *
         *     **Scopes**: `benefits:write`
         */
        patch: operations["benefits:update"];
        trace?: never;
    };
    "/v1/benefits/{id}/grants": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Benefit Grants
         * @description List the individual grants for a benefit.
         *
         *     It's especially useful to check if a user has been granted a benefit.
         *
         *     **Scopes**: `benefits:read` `benefits:write`
         */
        get: operations["benefits:grants"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/webhooks/endpoints": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Webhook Endpoints
         * @description List webhook endpoints.
         *
         *     **Scopes**: `webhooks:read` `webhooks:write`
         */
        get: operations["webhooks:list_webhook_endpoints"];
        put?: never;
        /**
         * Create Webhook Endpoint
         * @description Create a webhook endpoint.
         *
         *     **Scopes**: `webhooks:write`
         */
        post: operations["webhooks:create_webhook_endpoint"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/webhooks/endpoints/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Webhook Endpoint
         * @description Get a webhook endpoint by ID.
         *
         *     **Scopes**: `webhooks:read` `webhooks:write`
         */
        get: operations["webhooks:get_webhook_endpoint"];
        put?: never;
        post?: never;
        /**
         * Delete Webhook Endpoint
         * @description Delete a webhook endpoint.
         *
         *     **Scopes**: `webhooks:write`
         */
        delete: operations["webhooks:delete_webhook_endpoint"];
        options?: never;
        head?: never;
        /**
         * Update Webhook Endpoint
         * @description Update a webhook endpoint.
         *
         *     **Scopes**: `webhooks:write`
         */
        patch: operations["webhooks:update_webhook_endpoint"];
        trace?: never;
    };
    "/v1/webhooks/deliveries": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Webhook Deliveries
         * @description List webhook deliveries.
         *
         *     Deliveries are all the attempts to deliver a webhook event to an endpoint.
         *
         *     **Scopes**: `webhooks:read` `webhooks:write`
         */
        get: operations["webhooks:list_webhook_deliveries"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/webhooks/events/{id}/redeliver": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Redeliver Webhook Event
         * @description Schedule the re-delivery of a webhook event.
         *
         *     **Scopes**: `webhooks:write`
         */
        post: operations["webhooks:redeliver_webhook_event"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/products/": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Products
         * @description List products.
         *
         *     **Scopes**: `products:read` `products:write`
         */
        get: operations["products:list"];
        put?: never;
        /**
         * Create Product
         * @description Create a product.
         *
         *     **Scopes**: `products:write`
         */
        post: operations["products:create"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/products/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Product
         * @description Get a product by ID.
         *
         *     **Scopes**: `products:read` `products:write`
         */
        get: operations["products:get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        /**
         * Update Product
         * @description Update a product.
         *
         *     **Scopes**: `products:write`
         */
        patch: operations["products:update"];
        trace?: never;
    };
    "/v1/products/{id}/benefits": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Update Product Benefits
         * @description Update benefits granted by a product.
         *
         *     **Scopes**: `products:write`
         */
        post: operations["products:update_benefits"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/orders/": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Orders
         * @description List orders.
         *
         *     **Scopes**: `orders:read`
         */
        get: operations["orders:list"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/orders/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Order
         * @description Get an order by ID.
         *
         *     **Scopes**: `orders:read`
         */
        get: operations["orders:get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/orders/{id}/invoice": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Order Invoice
         * @description Get an order's invoice data.
         *
         *     **Scopes**: `orders:read`
         */
        get: operations["orders:invoice"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/refunds/": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Refunds
         * @description List products.
         *
         *     **Scopes**: `refunds:read` `refunds:write`
         */
        get: operations["refunds:list"];
        put?: never;
        /**
         * Create Refund
         * @description Create a refund.
         *
         *     **Scopes**: `refunds:write`
         */
        post: operations["refunds:create"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/checkouts/": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Checkout Sessions
         * @description List checkout sessions.
         *
         *     **Scopes**: `checkouts:read` `checkouts:write`
         */
        get: operations["checkouts:list"];
        put?: never;
        /**
         * Create Checkout Session
         * @description Create a checkout session.
         *
         *     **Scopes**: `checkouts:write`
         */
        post: operations["checkouts:create"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/checkouts/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Checkout Session
         * @description Get a checkout session by ID.
         *
         *     **Scopes**: `checkouts:read` `checkouts:write`
         */
        get: operations["checkouts:get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        /**
         * Update Checkout Session
         * @description Update a checkout session.
         *
         *     **Scopes**: `checkouts:write`
         */
        patch: operations["checkouts:update"];
        trace?: never;
    };
    "/v1/checkouts/client/{client_secret}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Checkout Session from Client
         * @description Get a checkout session by client secret.
         */
        get: operations["checkouts:client_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        /**
         * Update Checkout Session from Client
         * @description Update a checkout session by client secret.
         */
        patch: operations["checkouts:client_update"];
        trace?: never;
    };
    "/v1/checkouts/client/": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Create Checkout Session from Client
         * @description Create a checkout session from a client. Suitable to build checkout links.
         */
        post: operations["checkouts:client_create"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/checkouts/client/{client_secret}/confirm": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Confirm Checkout Session from Client
         * @description Confirm a checkout session by client secret.
         *
         *     Orders and subscriptions will be processed.
         */
        post: operations["checkouts:client_confirm"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/files/": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Files
         * @description List files.
         *
         *     **Scopes**: `files:read` `files:write`
         */
        get: operations["files:list"];
        put?: never;
        /**
         * Create File
         * @description Create a file.
         *
         *     **Scopes**: `files:write`
         */
        post: operations["files:create"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/files/{id}/uploaded": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Complete File Upload
         * @description Complete a file upload.
         *
         *     **Scopes**: `files:write`
         */
        post: operations["files:uploaded"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/files/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        /**
         * Delete File
         * @description Delete a file.
         *
         *     **Scopes**: `files:write`
         */
        delete: operations["files:delete"];
        options?: never;
        head?: never;
        /**
         * Update File
         * @description Update a file.
         *
         *     **Scopes**: `files:write`
         */
        patch: operations["files:update"];
        trace?: never;
    };
    "/v1/metrics/": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Metrics
         * @description Get metrics about your orders and subscriptions.
         *
         *     Currency values are output in cents.
         *
         *     **Scopes**: `metrics:read`
         */
        get: operations["metrics:get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/metrics/limits": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Metrics Limits
         * @description Get the interval limits for the metrics endpoint.
         *
         *     **Scopes**: `metrics:read`
         */
        get: operations["metrics:limits"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/integrations/google/authorize": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Integrations.Google.Authorize */
        get: operations["integrations_google:integrations.google.authorize"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/integrations/google/callback": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Integrations.Google.Callback */
        get: operations["integrations_google:integrations.google.callback"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/license-keys/": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List License Keys
         * @description Get license keys connected to the given organization & filters.
         *
         *     **Scopes**: `license_keys:read` `license_keys:write`
         */
        get: operations["license_keys:list"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/license-keys/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get License Key
         * @description Get a license key.
         *
         *     **Scopes**: `license_keys:read` `license_keys:write`
         */
        get: operations["license_keys:get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        /**
         * Update License Key
         * @description Update a license key.
         *
         *     **Scopes**: `license_keys:write`
         */
        patch: operations["license_keys:update"];
        trace?: never;
    };
    "/v1/license-keys/{id}/activations/{activation_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Activation
         * @description Get a license key activation.
         *
         *     **Scopes**: `license_keys:read` `license_keys:write`
         */
        get: operations["license_keys:get_activation"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/checkout-links/": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Checkout Links
         * @description List checkout links.
         *
         *     **Scopes**: `checkout_links:read` `checkout_links:write`
         */
        get: operations["checkout-links:list"];
        put?: never;
        /**
         * Create Checkout Link
         * @description Create a checkout link.
         *
         *     **Scopes**: `checkout_links:write`
         */
        post: operations["checkout-links:create"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/checkout-links/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Checkout Link
         * @description Get a checkout link by ID.
         *
         *     **Scopes**: `checkout_links:read` `checkout_links:write`
         */
        get: operations["checkout-links:get"];
        put?: never;
        post?: never;
        /**
         * Delete Checkout Link
         * @description Delete a checkout link.
         *
         *     **Scopes**: `checkout_links:write`
         */
        delete: operations["checkout-links:delete"];
        options?: never;
        head?: never;
        /**
         * Update Checkout Link
         * @description Update a checkout link.
         *
         *     **Scopes**: `checkout_links:write`
         */
        patch: operations["checkout-links:update"];
        trace?: never;
    };
    "/v1/storefronts/{slug}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Organization Storefront
         * @description Get an organization storefront by slug.
         */
        get: operations["storefronts:get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/custom-fields/": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Custom Fields
         * @description List custom fields.
         *
         *     **Scopes**: `custom_fields:read` `custom_fields:write`
         */
        get: operations["custom-fields:list"];
        put?: never;
        /**
         * Create Custom Field
         * @description Create a custom field.
         *
         *     **Scopes**: `custom_fields:write`
         */
        post: operations["custom-fields:create"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/custom-fields/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Custom Field
         * @description Get a custom field by ID.
         *
         *     **Scopes**: `custom_fields:read` `custom_fields:write`
         */
        get: operations["custom-fields:get"];
        put?: never;
        post?: never;
        /**
         * Delete Custom Field
         * @description Delete a custom field.
         *
         *     **Scopes**: `custom_fields:write`
         */
        delete: operations["custom-fields:delete"];
        options?: never;
        head?: never;
        /**
         * Update Custom Field
         * @description Update a custom field.
         *
         *     **Scopes**: `custom_fields:write`
         */
        patch: operations["custom-fields:update"];
        trace?: never;
    };
    "/v1/embed/product/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Product Embed
         * @description Get product card.
         */
        get: operations["embeds:get_product"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/discounts/": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Discounts
         * @description List discounts.
         *
         *     **Scopes**: `discounts:read` `discounts:write`
         */
        get: operations["discounts:list"];
        put?: never;
        /**
         * Create Discount
         * @description Create a discount.
         *
         *     **Scopes**: `discounts:write`
         */
        post: operations["discounts:create"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/discounts/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Discount
         * @description Get a discount by ID.
         *
         *     **Scopes**: `discounts:read` `discounts:write`
         */
        get: operations["discounts:get"];
        put?: never;
        post?: never;
        /**
         * Delete Discount
         * @description Delete a discount.
         *
         *     **Scopes**: `discounts:write`
         */
        delete: operations["discounts:delete"];
        options?: never;
        head?: never;
        /**
         * Update Discount
         * @description Update a discount.
         *
         *     **Scopes**: `discounts:write`
         */
        patch: operations["discounts:update"];
        trace?: never;
    };
    "/v1/customers/": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Customers
         * @description List customers.
         *
         *     **Scopes**: `customers:read` `customers:write`
         */
        get: operations["customers:list"];
        put?: never;
        /**
         * Create Customer
         * @description Create a customer.
         *
         *     **Scopes**: `customers:write`
         */
        post: operations["customers:create"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/customers/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Customer
         * @description Get a customer by ID.
         *
         *     **Scopes**: `customers:read` `customers:write`
         */
        get: operations["customers:get"];
        put?: never;
        post?: never;
        /**
         * Delete Customer
         * @description Delete a customer.
         *
         *     This action cannot be undone and will immediately:
         *     - Cancel any active subscriptions for the customer
         *     - Revoke all their benefits
         *     - Clear any `external_id`
         *
         *     Use it only in the context of deleting a user within your
         *     own service. Otherwise, use more granular API endpoints to cancel
         *     a specific subscription or revoke certain benefits.
         *
         *     Note: The customers information will nonetheless be retained for historic
         *     orders and subscriptions.
         *
         *     **Scopes**: `customers:write`
         */
        delete: operations["customers:delete"];
        options?: never;
        head?: never;
        /**
         * Update Customer
         * @description Update a customer.
         *
         *     **Scopes**: `customers:write`
         */
        patch: operations["customers:update"];
        trace?: never;
    };
    "/v1/customers/external/{external_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Customer by External ID
         * @description Get a customer by external ID.
         *
         *     **Scopes**: `customers:read` `customers:write`
         */
        get: operations["customers:get_external"];
        put?: never;
        post?: never;
        /**
         * Delete Customer by External ID
         * @description Delete a customer by external ID.
         *
         *     Immediately cancels any active subscriptions and revokes any active benefits.
         *
         *     **Scopes**: `customers:write`
         */
        delete: operations["customers:delete_external"];
        options?: never;
        head?: never;
        /**
         * Update Customer by External ID
         * @description Update a customer by external ID.
         *
         *     **Scopes**: `customers:write`
         */
        patch: operations["customers:update_external"];
        trace?: never;
    };
    "/v1/customers/{id}/state": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Customer State
         * @description Get a customer state by ID.
         *
         *     The customer state includes information about
         *     the customer's active subscriptions and benefits.
         *
         *     It's the ideal endpoint to use when you need to get a full overview
         *     of a customer's status.
         *
         *     **Scopes**: `customers:read` `customers:write`
         */
        get: operations["customers:get_state"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/customers/external/{external_id}/state": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Customer State by External ID
         * @description Get a customer state by external ID.
         *
         *     The customer state includes information about
         *     the customer's active subscriptions and benefits.
         *
         *     It's the ideal endpoint to use when you need to get a full overview
         *     of a customer's status.
         *
         *     **Scopes**: `customers:read` `customers:write`
         */
        get: operations["customers:get_state_external"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/customer-portal/benefit-grants/": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Benefit Grants
         * @description List benefits grants of the authenticated customer.
         *
         *     **Scopes**: `customer_portal:read` `customer_portal:write`
         */
        get: operations["customer_portal:benefit-grants:list"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/customer-portal/benefit-grants/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Benefit Grant
         * @description Get a benefit grant by ID for the authenticated customer.
         *
         *     **Scopes**: `customer_portal:read` `customer_portal:write`
         */
        get: operations["customer_portal:benefit-grants:get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        /**
         * Update Benefit Grant
         * @description Update a benefit grant for the authenticated customer.
         *
         *     **Scopes**: `customer_portal:write`
         */
        patch: operations["customer_portal:benefit-grants:update"];
        trace?: never;
    };
    "/v1/customer-portal/customers/me": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Customer
         * @description Get authenticated customer.
         *
         *     **Scopes**: `customer_portal:read` `customer_portal:write`
         */
        get: operations["customer_portal:customers:get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        /**
         * Update Customer
         * @description Update authenticated customer.
         *
         *     **Scopes**: `customer_portal:write`
         */
        patch: operations["customer_portal:customers:update"];
        trace?: never;
    };
    "/v1/customer-portal/customers/me/payment-methods": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Customer Payment Methods
         * @description Get saved payment methods of the authenticated customer.
         *
         *     **Scopes**: `customer_portal:read` `customer_portal:write`
         */
        get: operations["customer_portal:customers:get_payment_methods"];
        put?: never;
        /**
         * Add Customer Payment Method
         * @description Add a payment method to the authenticated customer.
         *
         *     **Scopes**: `customer_portal:read` `customer_portal:write`
         */
        post: operations["customer_portal:customers:add_payment_method"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/customer-portal/customers/me/payment-methods/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        /**
         * Delete Customer Payment Method
         * @description Delete a payment method from the authenticated customer.
         *
         *     **Scopes**: `customer_portal:read` `customer_portal:write`
         */
        delete: operations["customer_portal:customers:delete_payment_method"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/customer-portal/meters/": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Meters
         * @description List meters of the authenticated customer.
         *
         *     **Scopes**: `customer_portal:read` `customer_portal:write`
         */
        get: operations["customer_portal:customer_meters:list"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/customer-portal/meters/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Customer Meter
         * @description Get a meter by ID for the authenticated customer.
         *
         *     **Scopes**: `customer_portal:read` `customer_portal:write`
         */
        get: operations["customer_portal:customer_meters:get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/customer-portal/customer-session/request": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Customer Portal.Customer Session.Request */
        post: operations["customer_portal:customer-session:customer_portal.customer_session.request"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/customer-portal/customer-session/authenticate": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Customer Portal.Customer Session.Authenticate */
        post: operations["customer_portal:customer-session:customer_portal.customer_session.authenticate"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/customer-portal/downloadables/": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Downloadables
         * @description **Scopes**: `customer_portal:read` `customer_portal:write`
         */
        get: operations["customer_portal:downloadables:list"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/customer-portal/downloadables/{token}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get Downloadable */
        get: operations["customer_portal:downloadables:customer_portal.downloadables.get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/customer-portal/license-keys/": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List License Keys
         * @description **Scopes**: `customer_portal:read` `customer_portal:write`
         */
        get: operations["customer_portal:license_keys:list"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/customer-portal/license-keys/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get License Key
         * @description Get a license key.
         *
         *     **Scopes**: `customer_portal:read` `customer_portal:write`
         */
        get: operations["customer_portal:license_keys:get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/customer-portal/license-keys/validate": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Validate License Key
         * @description Validate a license key.
         */
        post: operations["customer_portal:license_keys:validate"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/customer-portal/license-keys/activate": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Activate License Key
         * @description Activate a license key instance.
         */
        post: operations["customer_portal:license_keys:activate"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/customer-portal/license-keys/deactivate": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Deactivate License Key
         * @description Deactivate a license key instance.
         */
        post: operations["customer_portal:license_keys:deactivate"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/customer-portal/oauth-accounts/authorize": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Customer Portal.Oauth Accounts.Authorize
         * @description **Scopes**: `customer_portal:write`
         */
        get: operations["customer_portal:oauth-accounts:customer_portal.oauth_accounts.authorize"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/customer-portal/oauth-accounts/callback": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Customer Portal.Oauth Accounts.Callback
         * @description **Scopes**: `customer_portal:write`
         */
        get: operations["customer_portal:oauth-accounts:customer_portal.oauth_accounts.callback"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/customer-portal/orders/": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Orders
         * @description List orders of the authenticated customer.
         *
         *     **Scopes**: `customer_portal:read` `customer_portal:write`
         */
        get: operations["customer_portal:orders:list"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/customer-portal/orders/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Order
         * @description Get an order by ID for the authenticated customer.
         *
         *     **Scopes**: `customer_portal:read` `customer_portal:write`
         */
        get: operations["customer_portal:orders:get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/customer-portal/orders/{id}/invoice": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Order Invoice
         * @description Get an order's invoice data.
         *
         *     **Scopes**: `customer_portal:read` `customer_portal:write`
         */
        get: operations["customer_portal:orders:invoice"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/customer-portal/organizations/{slug}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Organization
         * @description Get a customer portal's organization by slug.
         */
        get: operations["customer_portal:organizations:get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/customer-portal/subscriptions/": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Subscriptions
         * @description List subscriptions of the authenticated customer.
         *
         *     **Scopes**: `customer_portal:read` `customer_portal:write`
         */
        get: operations["customer_portal:subscriptions:list"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/customer-portal/subscriptions/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Subscription
         * @description Get a subscription for the authenticated customer.
         *
         *     **Scopes**: `customer_portal:read` `customer_portal:write`
         */
        get: operations["customer_portal:subscriptions:get"];
        put?: never;
        post?: never;
        /**
         * Cancel Subscription
         * @description Cancel a subscription of the authenticated customer.
         *
         *     **Scopes**: `customer_portal:write`
         */
        delete: operations["customer_portal:subscriptions:cancel"];
        options?: never;
        head?: never;
        /**
         * Update Subscription
         * @description Update a subscription of the authenticated customer.
         *
         *     **Scopes**: `customer_portal:write`
         */
        patch: operations["customer_portal:subscriptions:update"];
        trace?: never;
    };
    "/v1/email-update/request": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Request Email Update */
        post: operations["email-update:request_email_update"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/email-update/verify": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Verify Email Update */
        post: operations["email-update:verify_email_update"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/customer-sessions/": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Create Customer Session
         * @description Create a customer session.
         *
         *     **Scopes**: `customer_sessions:write`
         */
        post: operations["customer-sessions:create"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/events/": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Events
         * @description List events.
         *
         *     **Scopes**: `events:read` `events:write`
         */
        get: operations["events:list"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/events/names": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Event Names
         * @description List event names.
         *
         *     **Scopes**: `events:read` `events:write`
         */
        get: operations["events:list_names"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/events/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Event
         * @description Get an event by ID.
         *
         *     **Scopes**: `events:read` `events:write`
         */
        get: operations["events:get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/events/ingest": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Ingest Events
         * @description Ingest batch of events.
         *
         *     **Scopes**: `events:write`
         */
        post: operations["events:ingest"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/meters/": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Meters
         * @description List meters.
         *
         *     **Scopes**: `meters:read` `meters:write`
         */
        get: operations["meters:list"];
        put?: never;
        /**
         * Create Meter
         * @description Create a meter.
         *
         *     **Scopes**: `meters:write`
         */
        post: operations["meters:create"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/meters/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Meter
         * @description Get a meter by ID.
         *
         *     **Scopes**: `meters:read` `meters:write`
         */
        get: operations["meters:get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        /**
         * Update Meter
         * @description Update a meter.
         *
         *     **Scopes**: `meters:write`
         */
        patch: operations["meters:update"];
        trace?: never;
    };
    "/v1/meters/{id}/quantities": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Meter Quantities
         * @description Get quantities of a meter over a time period.
         *
         *     **Scopes**: `meters:read` `meters:write`
         */
        get: operations["meters:quantities"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/organization-access-tokens/": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List
         * @description List organization access tokens.
         */
        get: operations["organization_access_token:list"];
        put?: never;
        /** Create */
        post: operations["organization_access_token:create"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/organization-access-tokens/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        /** Delete */
        delete: operations["organization_access_token:delete"];
        options?: never;
        head?: never;
        /** Update */
        patch: operations["organization_access_token:update"];
        trace?: never;
    };
    "/v1/customer-meters/": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Customer Meters
         * @description List customer meters.
         *
         *     **Scopes**: `customer_meters:read`
         */
        get: operations["customer_meters:list"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/customer-meters/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Customer Meter
         * @description Get a customer meter by ID.
         *
         *     **Scopes**: `customer_meters:read`
         */
        get: operations["customer_meters:get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/payments/": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Payments
         * @description List payments.
         *
         *     **Scopes**: `payments:read`
         */
        get: operations["payments:list"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/payments/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Payment
         * @description Get a payment by ID.
         *
         *     **Scopes**: `payments:read`
         */
        get: operations["payments:get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
}
export interface webhooks {
    "checkout.created": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * checkout.created
         * @description Sent when a new checkout is created.
         *
         *     **Discord & Slack support:** Basic
         */
        post: operations["_endpointcheckout_created_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "checkout.updated": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * checkout.updated
         * @description Sent when a checkout is updated.
         *
         *     **Discord & Slack support:** Basic
         */
        post: operations["_endpointcheckout_updated_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "customer.created": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * customer.created
         * @description Sent when a new customer is created.
         *
         *     A customer can be created:
         *
         *     * After a successful checkout.
         *     * Programmatically via the API.
         *
         *     **Discord & Slack support:** Basic
         */
        post: operations["_endpointcustomer_created_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "customer.updated": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * customer.updated
         * @description Sent when a customer is updated.
         *
         *     This event is fired when the customer details are updated.
         *
         *     If you want to be notified when a customer subscription or benefit state changes, you should listen to the `customer_state_changed` event.
         *
         *     **Discord & Slack support:** Basic
         */
        post: operations["_endpointcustomer_updated_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "customer.deleted": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * customer.deleted
         * @description Sent when a customer is deleted.
         *
         *     **Discord & Slack support:** Basic
         */
        post: operations["_endpointcustomer_deleted_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "customer.state_changed": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * customer.state_changed
         * @description Sent when a customer state has changed.
         *
         *     It's triggered when:
         *
         *     * Customer is created, updated or deleted.
         *     * A subscription is created or updated.
         *     * A benefit is granted or revoked.
         *
         *     **Discord & Slack support:** Basic
         */
        post: operations["_endpointcustomer_state_changed_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "order.created": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * order.created
         * @description Sent when a new order is created.
         *
         *     A new order is created when:
         *
         *     * A customer purchases a one-time product. In this case, `billing_reason` is set to `purchase`.
         *     * A customer starts a subscription. In this case, `billing_reason` is set to `subscription_create`.
         *     * A subscription is renewed. In this case, `billing_reason` is set to `subscription_cycle`.
         *     * A subscription is upgraded or downgraded with an immediate proration invoice. In this case, `billing_reason` is set to `subscription_update`.
         *
         *     <Warning>The order might not be paid yet, so the `status` field might be `pending`.</Warning>
         *
         *     **Discord & Slack support:** Full
         */
        post: operations["_endpointorder_created_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "order.updated": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * order.updated
         * @description Sent when an order is updated.
         *
         *     An order is updated when:
         *
         *     * Its status changes, e.g. from `pending` to `paid`.
         *     * It's refunded, partially or fully.
         *
         *     **Discord & Slack support:** Full
         */
        post: operations["_endpointorder_updated_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "order.paid": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * order.paid
         * @description Sent when an order is paid.
         *
         *     When you receive this event, the order is fully processed and payment has been received.
         *
         *     **Discord & Slack support:** Full
         */
        post: operations["_endpointorder_paid_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "order.refunded": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * order.refunded
         * @description Sent when an order is fully or partially refunded.
         *
         *     **Discord & Slack support:** Full
         */
        post: operations["_endpointorder_refunded_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "subscription.created": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * subscription.created
         * @description Sent when a new subscription is created.
         *
         *     When this event occurs, the subscription `status` might not be `active` yet, as we can still have to wait for the first payment to be processed.
         *
         *     **Discord & Slack support:** Full
         */
        post: operations["_endpointsubscription_created_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "subscription.updated": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * subscription.updated
         * @description Sent when a subscription is updated. This event fires for all changes to the subscription, including renewals.
         *
         *     If you want more specific events, you can listen to `subscription.active`, `subscription.canceled`, and `subscription.revoked`.
         *
         *     To listen specifically for renewals, you can listen to `order.created` events and check the `billing_reason` field.
         *
         *     **Discord & Slack support:** On cancellation and revocation. Renewals are skipped.
         */
        post: operations["_endpointsubscription_updated_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "subscription.active": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * subscription.active
         * @description Sent when a subscription becomes active,
         *     whether because it's a new paid subscription or because payment was recovered.
         *
         *     **Discord & Slack support:** Full
         */
        post: operations["_endpointsubscription_active_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "subscription.canceled": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * subscription.canceled
         * @description Sent when a subscription is canceled.
         *     Customers might still have access until the end of the current period.
         *
         *     **Discord & Slack support:** Full
         */
        post: operations["_endpointsubscription_canceled_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "subscription.uncanceled": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * subscription.uncanceled
         * @description Sent when a subscription is uncanceled.
         *
         *     **Discord & Slack support:** Full
         */
        post: operations["_endpointsubscription_uncanceled_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "subscription.revoked": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * subscription.revoked
         * @description Sent when a subscription is revoked, the user loses access immediately.
         *     Happens when the subscription is canceled, or payment is past due.
         *
         *     **Discord & Slack support:** Full
         */
        post: operations["_endpointsubscription_revoked_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "refund.created": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * refund.created
         * @description Sent when a refund is created regardless of status.
         *
         *     **Discord & Slack support:** Full
         */
        post: operations["_endpointrefund_created_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "refund.updated": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * refund.updated
         * @description Sent when a refund is updated.
         *
         *     **Discord & Slack support:** Full
         */
        post: operations["_endpointrefund_updated_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "product.created": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * product.created
         * @description Sent when a new product is created.
         *
         *     **Discord & Slack support:** Basic
         */
        post: operations["_endpointproduct_created_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "product.updated": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * product.updated
         * @description Sent when a product is updated.
         *
         *     **Discord & Slack support:** Basic
         */
        post: operations["_endpointproduct_updated_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "organization.updated": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * organization.updated
         * @description Sent when a organization is updated.
         *
         *     **Discord & Slack support:** Basic
         */
        post: operations["_endpointorganization_updated_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "benefit.created": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * benefit.created
         * @description Sent when a new benefit is created.
         *
         *     **Discord & Slack support:** Basic
         */
        post: operations["_endpointbenefit_created_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "benefit.updated": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * benefit.updated
         * @description Sent when a benefit is updated.
         *
         *     **Discord & Slack support:** Basic
         */
        post: operations["_endpointbenefit_updated_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "benefit_grant.created": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * benefit_grant.created
         * @description Sent when a new benefit grant is created.
         *
         *     **Discord & Slack support:** Basic
         */
        post: operations["_endpointbenefit_grant_created_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "benefit_grant.updated": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * benefit_grant.updated
         * @description Sent when a benefit grant is updated.
         *
         *     **Discord & Slack support:** Basic
         */
        post: operations["_endpointbenefit_grant_updated_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "benefit_grant.cycled": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * benefit_grant.cycled
         * @description Sent when a benefit grant is cycled,
         *     meaning the related subscription has been renewed for another period.
         *
         *     **Discord & Slack support:** Basic
         */
        post: operations["_endpointbenefit_grant_cycled_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "benefit_grant.revoked": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * benefit_grant.revoked
         * @description Sent when a benefit grant is revoked.
         *
         *     **Discord & Slack support:** Basic
         */
        post: operations["_endpointbenefit_grant_revoked_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
}
export interface components {
    schemas: {
        /** Account */
        Account: {
            /**
             * Id
             * Format: uuid
             */
            id: string;
            account_type: components["schemas"]["AccountType"];
            status: components["schemas"]["Status"];
            /** Stripe Id */
            stripe_id: string | null;
            /** Open Collective Slug */
            open_collective_slug: string | null;
            /** Is Details Submitted */
            is_details_submitted: boolean;
            /** Is Charges Enabled */
            is_charges_enabled: boolean;
            /** Is Payouts Enabled */
            is_payouts_enabled: boolean;
            /** Country */
            country: string;
            /** Users */
            users: components["schemas"]["UserBase"][];
            /** Organizations */
            organizations: components["schemas"]["Organization"][];
        };
        /** AccountCreate */
        AccountCreate: {
            /**
             * Account Type
             * @constant
             */
            account_type: "stripe";
            /**
             * Country
             * @description Two letter uppercase country code
             */
            country: string;
        };
        /** AccountLink */
        AccountLink: {
            /** Url */
            url: string;
        };
        /**
         * AccountType
         * @enum {string}
         */
        AccountType: "stripe" | "open_collective";
        /** Address */
        Address: {
            /** Line1 */
            line1?: string | null;
            /** Line2 */
            line2?: string | null;
            /** Postal Code */
            postal_code?: string | null;
            /** City */
            city?: string | null;
            /** State */
            state?: string | null;
            /** Country */
            country: string;
        };
        /** AlreadyActiveSubscriptionError */
        AlreadyActiveSubscriptionError: {
            /**
             * Error
             * @constant
             */
            error: "AlreadyActiveSubscriptionError";
            /** Detail */
            detail: string;
        };
        /** AlreadyCanceledSubscription */
        AlreadyCanceledSubscription: {
            /**
             * Error
             * @constant
             */
            error: "AlreadyCanceledSubscription";
            /** Detail */
            detail: string;
        };
        /**
         * AttachedCustomField
         * @description Schema of a custom field attached to a resource.
         */
        AttachedCustomField: {
            /**
             * Custom Field Id
             * Format: uuid4
             * @description ID of the custom field.
             */
            custom_field_id: string;
            /** CustomField */
            custom_field: components["schemas"]["CustomField"];
            /**
             * Order
             * @description Order of the custom field in the resource.
             */
            order: number;
            /**
             * Required
             * @description Whether the value is required for this custom field.
             */
            required: boolean;
        };
        /**
         * AttachedCustomFieldCreate
         * @description Schema to attach a custom field to a resource.
         */
        AttachedCustomFieldCreate: {
            /**
             * Custom Field Id
             * Format: uuid4
             * @description ID of the custom field to attach.
             */
            custom_field_id: string;
            /**
             * Required
             * @description Whether the value is required for this custom field.
             */
            required: boolean;
        };
        /** AuthorizeOrganization */
        AuthorizeOrganization: {
            /**
             * Id
             * Format: uuid4
             */
            id: string;
            /** Slug */
            slug: string;
            /** Avatar Url */
            avatar_url: string | null;
        };
        /** AuthorizeResponse */
        AuthorizeResponse: {
            /** Url */
            url: string;
        };
        /** AuthorizeResponseOrganization */
        AuthorizeResponseOrganization: {
            client: components["schemas"]["OAuth2ClientPublic"];
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            sub_type: "organization";
            sub: components["schemas"]["AuthorizeOrganization"] | null;
            /** Scopes */
            scopes: components["schemas"]["Scope"][];
            /** Organizations */
            organizations: components["schemas"]["AuthorizeOrganization"][];
        };
        /** AuthorizeResponseUser */
        AuthorizeResponseUser: {
            client: components["schemas"]["OAuth2ClientPublic"];
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            sub_type: "user";
            sub: components["schemas"]["AuthorizeUser"] | null;
            /** Scopes */
            scopes: components["schemas"]["Scope"][];
        };
        /** AuthorizeUser */
        AuthorizeUser: {
            /**
             * Id
             * Format: uuid4
             */
            id: string;
            /**
             * Email
             * Format: email
             */
            email: string;
            /** Avatar Url */
            avatar_url: string | null;
        };
        /**
         * AvailableScope
         * @enum {string}
         */
        AvailableScope: "openid" | "profile" | "email" | "user:read" | "organizations:read" | "organizations:write" | "custom_fields:read" | "custom_fields:write" | "discounts:read" | "discounts:write" | "checkout_links:read" | "checkout_links:write" | "checkouts:read" | "checkouts:write" | "products:read" | "products:write" | "benefits:read" | "benefits:write" | "events:read" | "events:write" | "meters:read" | "meters:write" | "files:read" | "files:write" | "subscriptions:read" | "subscriptions:write" | "customers:read" | "customers:write" | "customer_meters:read" | "customer_sessions:write" | "orders:read" | "refunds:read" | "refunds:write" | "payments:read" | "metrics:read" | "webhooks:read" | "webhooks:write" | "external_organizations:read" | "license_keys:read" | "license_keys:write" | "repositories:read" | "repositories:write" | "issues:read" | "issues:write" | "customer_portal:read" | "customer_portal:write" | "notification_recipients:read" | "notification_recipients:write";
        Benefit: components["schemas"]["BenefitCustom"] | components["schemas"]["BenefitDiscord"] | components["schemas"]["BenefitGitHubRepository"] | components["schemas"]["BenefitDownloadables"] | components["schemas"]["BenefitLicenseKeys"] | components["schemas"]["BenefitMeterCredit"];
        BenefitCreate: components["schemas"]["BenefitCustomCreate"] | components["schemas"]["BenefitDiscordCreate"] | components["schemas"]["BenefitGitHubRepositoryCreate"] | components["schemas"]["BenefitDownloadablesCreate"] | components["schemas"]["BenefitLicenseKeysCreate"] | components["schemas"]["BenefitMeterCreditCreate"];
        /**
         * BenefitCustom
         * @description A benefit of type `custom`.
         *
         *     Use it to grant any kind of benefit that doesn't fit in the other types.
         */
        BenefitCustom: {
            /**
             * Id
             * Format: uuid4
             * @description The ID of the benefit.
             */
            id: string;
            /**
             * Created At
             * Format: date-time
             * @description Creation timestamp of the object.
             */
            created_at: string;
            /**
             * Modified At
             * @description Last modification timestamp of the object.
             */
            modified_at: string | null;
            /**
             * Type
             * @constant
             */
            type: "custom";
            /**
             * Description
             * @description The description of the benefit.
             */
            description: string;
            /**
             * Selectable
             * @description Whether the benefit is selectable when creating a product.
             */
            selectable: boolean;
            /**
             * Deletable
             * @description Whether the benefit is deletable.
             */
            deletable: boolean;
            /**
             * Organization Id
             * Format: uuid4
             * @description The ID of the organization owning the benefit.
             */
            organization_id: string;
            /** Metadata */
            metadata: {
                [key: string]: string | number | boolean;
            };
            properties: components["schemas"]["BenefitCustomProperties"];
        };
        /**
         * BenefitCustomCreate
         * @description Schema to create a benefit of type `custom`.
         */
        BenefitCustomCreate: {
            /**
             * Metadata
             * @description Key-value object allowing you to store additional information.
             *
             *     The key must be a string with a maximum length of **40 characters**.
             *     The value must be either:
             *
             *     * A string with a maximum length of **500 characters**
             *     * An integer
             *     * A floating-point number
             *     * A boolean
             *
             *     You can store up to **50 key-value pairs**.
             */
            metadata?: {
                [key: string]: string | number | boolean;
            };
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            type: "custom";
            /**
             * Description
             * @description The description of the benefit. Will be displayed on products having this benefit.
             */
            description: string;
            /**
             * Organization Id
             * @description The ID of the organization owning the benefit. **Required unless you use an organization token.**
             */
            organization_id?: string | null;
            properties: components["schemas"]["BenefitCustomCreateProperties"];
        };
        /**
         * BenefitCustomCreateProperties
         * @description Properties for creating a benefit of type `custom`.
         */
        BenefitCustomCreateProperties: {
            /** Note */
            note?: (string | null) | null;
        };
        /**
         * BenefitCustomProperties
         * @description Properties for a benefit of type `custom`.
         */
        BenefitCustomProperties: {
            /** Note */
            note: (string | null) | null;
        };
        /** BenefitCustomSubscriber */
        BenefitCustomSubscriber: {
            /**
             * Id
             * Format: uuid4
             * @description The ID of the benefit.
             */
            id: string;
            /**
             * Created At
             * Format: date-time
             * @description Creation timestamp of the object.
             */
            created_at: string;
            /**
             * Modified At
             * @description Last modification timestamp of the object.
             */
            modified_at: string | null;
            /**
             * Type
             * @constant
             */
            type: "custom";
            /**
             * Description
             * @description The description of the benefit.
             */
            description: string;
            /**
             * Selectable
             * @description Whether the benefit is selectable when creating a product.
             */
            selectable: boolean;
            /**
             * Deletable
             * @description Whether the benefit is deletable.
             */
            deletable: boolean;
            /**
             * Organization Id
             * Format: uuid4
             * @description The ID of the organization owning the benefit.
             */
            organization_id: string;
            /** Metadata */
            metadata: {
                [key: string]: string | number | boolean;
            };
            organization: components["schemas"]["Organization"];
            properties: components["schemas"]["BenefitCustomSubscriberProperties"];
        };
        /**
         * BenefitCustomSubscriberProperties
         * @description Properties available to subscribers for a benefit of type `custom`.
         */
        BenefitCustomSubscriberProperties: {
            /** Note */
            note: (string | null) | null;
        };
        /** BenefitCustomUpdate */
        BenefitCustomUpdate: {
            /**
             * Metadata
             * @description Key-value object allowing you to store additional information.
             *
             *     The key must be a string with a maximum length of **40 characters**.
             *     The value must be either:
             *
             *     * A string with a maximum length of **500 characters**
             *     * An integer
             *     * A floating-point number
             *     * A boolean
             *
             *     You can store up to **50 key-value pairs**.
             */
            metadata?: {
                [key: string]: string | number | boolean;
            };
            /**
             * Description
             * @description The description of the benefit. Will be displayed on products having this benefit.
             */
            description?: string | null;
            /**
             * Type
             * @constant
             */
            type: "custom";
            properties?: components["schemas"]["BenefitCustomProperties"] | null;
        };
        /**
         * BenefitDiscord
         * @description A benefit of type `discord`.
         *
         *     Use it to automatically invite your backers to a Discord server.
         */
        BenefitDiscord: {
            /**
             * Id
             * Format: uuid4
             * @description The ID of the benefit.
             */
            id: string;
            /**
             * Created At
             * Format: date-time
             * @description Creation timestamp of the object.
             */
            created_at: string;
            /**
             * Modified At
             * @description Last modification timestamp of the object.
             */
            modified_at: string | null;
            /**
             * Type
             * @constant
             */
            type: "discord";
            /**
             * Description
             * @description The description of the benefit.
             */
            description: string;
            /**
             * Selectable
             * @description Whether the benefit is selectable when creating a product.
             */
            selectable: boolean;
            /**
             * Deletable
             * @description Whether the benefit is deletable.
             */
            deletable: boolean;
            /**
             * Organization Id
             * Format: uuid4
             * @description The ID of the organization owning the benefit.
             */
            organization_id: string;
            /** Metadata */
            metadata: {
                [key: string]: string | number | boolean;
            };
            properties: components["schemas"]["BenefitDiscordProperties"];
        };
        /** BenefitDiscordCreate */
        BenefitDiscordCreate: {
            /**
             * Metadata
             * @description Key-value object allowing you to store additional information.
             *
             *     The key must be a string with a maximum length of **40 characters**.
             *     The value must be either:
             *
             *     * A string with a maximum length of **500 characters**
             *     * An integer
             *     * A floating-point number
             *     * A boolean
             *
             *     You can store up to **50 key-value pairs**.
             */
            metadata?: {
                [key: string]: string | number | boolean;
            };
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            type: "discord";
            /**
             * Description
             * @description The description of the benefit. Will be displayed on products having this benefit.
             */
            description: string;
            /**
             * Organization Id
             * @description The ID of the organization owning the benefit. **Required unless you use an organization token.**
             */
            organization_id?: string | null;
            properties: components["schemas"]["BenefitDiscordCreateProperties"];
        };
        /**
         * BenefitDiscordCreateProperties
         * @description Properties to create a benefit of type `discord`.
         */
        BenefitDiscordCreateProperties: {
            /** Guild Token */
            guild_token: string;
            /**
             * Role Id
             * @description The ID of the Discord role to grant.
             */
            role_id: string;
        };
        /**
         * BenefitDiscordProperties
         * @description Properties for a benefit of type `discord`.
         */
        BenefitDiscordProperties: {
            /**
             * Guild Id
             * @description The ID of the Discord server.
             */
            guild_id: string;
            /**
             * Role Id
             * @description The ID of the Discord role to grant.
             */
            role_id: string;
            /** Guild Token */
            readonly guild_token: string;
        };
        /** BenefitDiscordSubscriber */
        BenefitDiscordSubscriber: {
            /**
             * Id
             * Format: uuid4
             * @description The ID of the benefit.
             */
            id: string;
            /**
             * Created At
             * Format: date-time
             * @description Creation timestamp of the object.
             */
            created_at: string;
            /**
             * Modified At
             * @description Last modification timestamp of the object.
             */
            modified_at: string | null;
            /**
             * Type
             * @constant
             */
            type: "discord";
            /**
             * Description
             * @description The description of the benefit.
             */
            description: string;
            /**
             * Selectable
             * @description Whether the benefit is selectable when creating a product.
             */
            selectable: boolean;
            /**
             * Deletable
             * @description Whether the benefit is deletable.
             */
            deletable: boolean;
            /**
             * Organization Id
             * Format: uuid4
             * @description The ID of the organization owning the benefit.
             */
            organization_id: string;
            /** Metadata */
            metadata: {
                [key: string]: string | number | boolean;
            };
            organization: components["schemas"]["Organization"];
            properties: components["schemas"]["BenefitDiscordSubscriberProperties"];
        };
        /**
         * BenefitDiscordSubscriberProperties
         * @description Properties available to subscribers for a benefit of type `discord`.
         */
        BenefitDiscordSubscriberProperties: {
            /**
             * Guild Id
             * @description The ID of the Discord server.
             */
            guild_id: string;
        };
        /** BenefitDiscordUpdate */
        BenefitDiscordUpdate: {
            /**
             * Metadata
             * @description Key-value object allowing you to store additional information.
             *
             *     The key must be a string with a maximum length of **40 characters**.
             *     The value must be either:
             *
             *     * A string with a maximum length of **500 characters**
             *     * An integer
             *     * A floating-point number
             *     * A boolean
             *
             *     You can store up to **50 key-value pairs**.
             */
            metadata?: {
                [key: string]: string | number | boolean;
            };
            /**
             * Description
             * @description The description of the benefit. Will be displayed on products having this benefit.
             */
            description?: string | null;
            /**
             * Type
             * @constant
             */
            type: "discord";
            properties?: components["schemas"]["BenefitDiscordCreateProperties"] | null;
        };
        /** BenefitDownloadables */
        BenefitDownloadables: {
            /**
             * Id
             * Format: uuid4
             * @description The ID of the benefit.
             */
            id: string;
            /**
             * Created At
             * Format: date-time
             * @description Creation timestamp of the object.
             */
            created_at: string;
            /**
             * Modified At
             * @description Last modification timestamp of the object.
             */
            modified_at: string | null;
            /**
             * Type
             * @constant
             */
            type: "downloadables";
            /**
             * Description
             * @description The description of the benefit.
             */
            description: string;
            /**
             * Selectable
             * @description Whether the benefit is selectable when creating a product.
             */
            selectable: boolean;
            /**
             * Deletable
             * @description Whether the benefit is deletable.
             */
            deletable: boolean;
            /**
             * Organization Id
             * Format: uuid4
             * @description The ID of the organization owning the benefit.
             */
            organization_id: string;
            /** Metadata */
            metadata: {
                [key: string]: string | number | boolean;
            };
            properties: components["schemas"]["BenefitDownloadablesProperties"];
        };
        /** BenefitDownloadablesCreate */
        BenefitDownloadablesCreate: {
            /**
             * Metadata
             * @description Key-value object allowing you to store additional information.
             *
             *     The key must be a string with a maximum length of **40 characters**.
             *     The value must be either:
             *
             *     * A string with a maximum length of **500 characters**
             *     * An integer
             *     * A floating-point number
             *     * A boolean
             *
             *     You can store up to **50 key-value pairs**.
             */
            metadata?: {
                [key: string]: string | number | boolean;
            };
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            type: "downloadables";
            /**
             * Description
             * @description The description of the benefit. Will be displayed on products having this benefit.
             */
            description: string;
            /**
             * Organization Id
             * @description The ID of the organization owning the benefit. **Required unless you use an organization token.**
             */
            organization_id?: string | null;
            properties: components["schemas"]["BenefitDownloadablesCreateProperties"];
        };
        /** BenefitDownloadablesCreateProperties */
        BenefitDownloadablesCreateProperties: {
            /**
             * Archived
             * @default {}
             */
            archived: {
                [key: string]: boolean;
            };
            /** Files */
            files: string[];
        };
        /** BenefitDownloadablesProperties */
        BenefitDownloadablesProperties: {
            /** Archived */
            archived: {
                [key: string]: boolean;
            };
            /** Files */
            files: string[];
        };
        /** BenefitDownloadablesSubscriber */
        BenefitDownloadablesSubscriber: {
            /**
             * Id
             * Format: uuid4
             * @description The ID of the benefit.
             */
            id: string;
            /**
             * Created At
             * Format: date-time
             * @description Creation timestamp of the object.
             */
            created_at: string;
            /**
             * Modified At
             * @description Last modification timestamp of the object.
             */
            modified_at: string | null;
            /**
             * Type
             * @constant
             */
            type: "downloadables";
            /**
             * Description
             * @description The description of the benefit.
             */
            description: string;
            /**
             * Selectable
             * @description Whether the benefit is selectable when creating a product.
             */
            selectable: boolean;
            /**
             * Deletable
             * @description Whether the benefit is deletable.
             */
            deletable: boolean;
            /**
             * Organization Id
             * Format: uuid4
             * @description The ID of the organization owning the benefit.
             */
            organization_id: string;
            /** Metadata */
            metadata: {
                [key: string]: string | number | boolean;
            };
            organization: components["schemas"]["Organization"];
            properties: components["schemas"]["BenefitDownloadablesSubscriberProperties"];
        };
        /** BenefitDownloadablesSubscriberProperties */
        BenefitDownloadablesSubscriberProperties: {
            /** Active Files */
            active_files: string[];
        };
        /** BenefitDownloadablesUpdate */
        BenefitDownloadablesUpdate: {
            /**
             * Metadata
             * @description Key-value object allowing you to store additional information.
             *
             *     The key must be a string with a maximum length of **40 characters**.
             *     The value must be either:
             *
             *     * A string with a maximum length of **500 characters**
             *     * An integer
             *     * A floating-point number
             *     * A boolean
             *
             *     You can store up to **50 key-value pairs**.
             */
            metadata?: {
                [key: string]: string | number | boolean;
            };
            /**
             * Description
             * @description The description of the benefit. Will be displayed on products having this benefit.
             */
            description?: string | null;
            /**
             * Type
             * @constant
             */
            type: "downloadables";
            properties?: components["schemas"]["BenefitDownloadablesCreateProperties"] | null;
        };
        /**
         * BenefitGitHubRepository
         * @description A benefit of type `github_repository`.
         *
         *     Use it to automatically invite your backers to a private GitHub repository.
         */
        BenefitGitHubRepository: {
            /**
             * Id
             * Format: uuid4
             * @description The ID of the benefit.
             */
            id: string;
            /**
             * Created At
             * Format: date-time
             * @description Creation timestamp of the object.
             */
            created_at: string;
            /**
             * Modified At
             * @description Last modification timestamp of the object.
             */
            modified_at: string | null;
            /**
             * Type
             * @constant
             */
            type: "github_repository";
            /**
             * Description
             * @description The description of the benefit.
             */
            description: string;
            /**
             * Selectable
             * @description Whether the benefit is selectable when creating a product.
             */
            selectable: boolean;
            /**
             * Deletable
             * @description Whether the benefit is deletable.
             */
            deletable: boolean;
            /**
             * Organization Id
             * Format: uuid4
             * @description The ID of the organization owning the benefit.
             */
            organization_id: string;
            /** Metadata */
            metadata: {
                [key: string]: string | number | boolean;
            };
            properties: components["schemas"]["BenefitGitHubRepositoryProperties"];
        };
        /** BenefitGitHubRepositoryCreate */
        BenefitGitHubRepositoryCreate: {
            /**
             * Metadata
             * @description Key-value object allowing you to store additional information.
             *
             *     The key must be a string with a maximum length of **40 characters**.
             *     The value must be either:
             *
             *     * A string with a maximum length of **500 characters**
             *     * An integer
             *     * A floating-point number
             *     * A boolean
             *
             *     You can store up to **50 key-value pairs**.
             */
            metadata?: {
                [key: string]: string | number | boolean;
            };
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            type: "github_repository";
            /**
             * Description
             * @description The description of the benefit. Will be displayed on products having this benefit.
             */
            description: string;
            /**
             * Organization Id
             * @description The ID of the organization owning the benefit. **Required unless you use an organization token.**
             */
            organization_id?: string | null;
            properties: components["schemas"]["BenefitGitHubRepositoryCreateProperties"];
        };
        /**
         * BenefitGitHubRepositoryCreateProperties
         * @description Properties to create a benefit of type `github_repository`.
         */
        BenefitGitHubRepositoryCreateProperties: {
            /**
             * Repository Owner
             * @description The owner of the repository.
             */
            repository_owner: string;
            /**
             * Repository Name
             * @description The name of the repository.
             */
            repository_name: string;
            /**
             * Permission
             * @description The permission level to grant. Read more about roles and their permissions on [GitHub documentation](https://docs.github.com/en/organizations/managing-user-access-to-your-organizations-repositories/managing-repository-roles/repository-roles-for-an-organization#permissions-for-each-role).
             * @enum {string}
             */
            permission: "pull" | "triage" | "push" | "maintain" | "admin";
        };
        /**
         * BenefitGitHubRepositoryProperties
         * @description Properties for a benefit of type `github_repository`.
         */
        BenefitGitHubRepositoryProperties: {
            /**
             * Repository Owner
             * @description The owner of the repository.
             */
            repository_owner: string;
            /**
             * Repository Name
             * @description The name of the repository.
             */
            repository_name: string;
            /**
             * Permission
             * @description The permission level to grant. Read more about roles and their permissions on [GitHub documentation](https://docs.github.com/en/organizations/managing-user-access-to-your-organizations-repositories/managing-repository-roles/repository-roles-for-an-organization#permissions-for-each-role).
             * @enum {string}
             */
            permission: "pull" | "triage" | "push" | "maintain" | "admin";
        };
        /** BenefitGitHubRepositorySubscriber */
        BenefitGitHubRepositorySubscriber: {
            /**
             * Id
             * Format: uuid4
             * @description The ID of the benefit.
             */
            id: string;
            /**
             * Created At
             * Format: date-time
             * @description Creation timestamp of the object.
             */
            created_at: string;
            /**
             * Modified At
             * @description Last modification timestamp of the object.
             */
            modified_at: string | null;
            /**
             * Type
             * @constant
             */
            type: "github_repository";
            /**
             * Description
             * @description The description of the benefit.
             */
            description: string;
            /**
             * Selectable
             * @description Whether the benefit is selectable when creating a product.
             */
            selectable: boolean;
            /**
             * Deletable
             * @description Whether the benefit is deletable.
             */
            deletable: boolean;
            /**
             * Organization Id
             * Format: uuid4
             * @description The ID of the organization owning the benefit.
             */
            organization_id: string;
            /** Metadata */
            metadata: {
                [key: string]: string | number | boolean;
            };
            organization: components["schemas"]["Organization"];
            properties: components["schemas"]["BenefitGitHubRepositorySubscriberProperties"];
        };
        /**
         * BenefitGitHubRepositorySubscriberProperties
         * @description Properties available to subscribers for a benefit of type `github_repository`.
         */
        BenefitGitHubRepositorySubscriberProperties: {
            /**
             * Repository Owner
             * @description The owner of the repository.
             */
            repository_owner: string;
            /**
             * Repository Name
             * @description The name of the repository.
             */
            repository_name: string;
        };
        /** BenefitGitHubRepositoryUpdate */
        BenefitGitHubRepositoryUpdate: {
            /**
             * Metadata
             * @description Key-value object allowing you to store additional information.
             *
             *     The key must be a string with a maximum length of **40 characters**.
             *     The value must be either:
             *
             *     * A string with a maximum length of **500 characters**
             *     * An integer
             *     * A floating-point number
             *     * A boolean
             *
             *     You can store up to **50 key-value pairs**.
             */
            metadata?: {
                [key: string]: string | number | boolean;
            };
            /**
             * Description
             * @description The description of the benefit. Will be displayed on products having this benefit.
             */
            description?: string | null;
            /**
             * Type
             * @constant
             */
            type: "github_repository";
            properties?: components["schemas"]["BenefitGitHubRepositoryCreateProperties"] | null;
        };
        /** BenefitGrant */
        BenefitGrant: {
            /**
             * Created At
             * Format: date-time
             * @description Creation timestamp of the object.
             */
            created_at: string;
            /**
             * Modified At
             * @description Last modification timestamp of the object.
             */
            modified_at: string | null;
            /**
             * Id
             * Format: uuid4
             * @description The ID of the grant.
             */
            id: string;
            /**
             * Granted At
             * @description The timestamp when the benefit was granted. If `None`, the benefit is not granted.
             */
            granted_at?: string | null;
            /**
             * Is Granted
             * @description Whether the benefit is granted.
             */
            is_granted: boolean;
            /**
             * Revoked At
             * @description The timestamp when the benefit was revoked. If `None`, the benefit is not revoked.
             */
            revoked_at?: string | null;
            /**
             * Is Revoked
             * @description Whether the benefit is revoked.
             */
            is_revoked: boolean;
            /**
             * Subscription Id
             * @description The ID of the subscription that granted this benefit.
             */
            subscription_id: string | null;
            /**
             * Order Id
             * @description The ID of the order that granted this benefit.
             */
            order_id: string | null;
            /**
             * Customer Id
             * Format: uuid4
             * @description The ID of the customer concerned by this grant.
             */
            customer_id: string;
            /**
             * Benefit Id
             * Format: uuid4
             * @description The ID of the benefit concerned by this grant.
             */
            benefit_id: string;
            /** @description The error information if the benefit grant failed with an unrecoverable error. */
            error?: components["schemas"]["BenefitGrantError"] | null;
            customer: components["schemas"]["Customer"];
            /** Properties */
            properties: components["schemas"]["BenefitGrantDiscordProperties"] | components["schemas"]["BenefitGrantGitHubRepositoryProperties"] | components["schemas"]["BenefitGrantDownloadablesProperties"] | components["schemas"]["BenefitGrantLicenseKeysProperties"] | components["schemas"]["BenefitGrantCustomProperties"];
        };
        /** BenefitGrantCustomProperties */
        BenefitGrantCustomProperties: Record<string, never>;
        /** BenefitGrantDiscordProperties */
        BenefitGrantDiscordProperties: {
            /** Account Id */
            account_id?: string;
            /** Guild Id */
            guild_id?: string;
            /** Role Id */
            role_id?: string;
        };
        /** BenefitGrantDownloadablesProperties */
        BenefitGrantDownloadablesProperties: {
            /** Files */
            files?: string[];
        };
        /** BenefitGrantError */
        BenefitGrantError: {
            /** Message */
            message: string;
            /** Type */
            type: string;
            /** Timestamp */
            timestamp: string;
        };
        /** BenefitGrantGitHubRepositoryProperties */
        BenefitGrantGitHubRepositoryProperties: {
            /** Account Id */
            account_id?: string;
            /** Repository Owner */
            repository_owner?: string;
            /** Repository Name */
            repository_name?: string;
            /**
             * Permission
             * @enum {string}
             */
            permission?: "pull" | "triage" | "push" | "maintain" | "admin";
        };
        /** BenefitGrantLicenseKeysProperties */
        BenefitGrantLicenseKeysProperties: {
            /** License Key Id */
            license_key_id?: string;
            /** Display Key */
            display_key?: string;
        };
        /** BenefitGrantMeterCreditProperties */
        BenefitGrantMeterCreditProperties: {
            /** Last Credited Meter Id */
            last_credited_meter_id: string;
            /** Last Credited Units */
            last_credited_units: number;
            /** Last Credited At */
            last_credited_at: string;
        };
        /** BenefitGrantWebhook */
        BenefitGrantWebhook: {
            /**
             * Created At
             * Format: date-time
             * @description Creation timestamp of the object.
             */
            created_at: string;
            /**
             * Modified At
             * @description Last modification timestamp of the object.
             */
            modified_at: string | null;
            /**
             * Id
             * Format: uuid4
             * @description The ID of the grant.
             */
            id: string;
            /**
             * Granted At
             * @description The timestamp when the benefit was granted. If `None`, the benefit is not granted.
             */
            granted_at?: string | null;
            /**
             * Is Granted
             * @description Whether the benefit is granted.
             */
            is_granted: boolean;
            /**
             * Revoked At
             * @description The timestamp when the benefit was revoked. If `None`, the benefit is not revoked.
             */
            revoked_at?: string | null;
            /**
             * Is Revoked
             * @description Whether the benefit is revoked.
             */
            is_revoked: boolean;
            /**
             * Subscription Id
             * @description The ID of the subscription that granted this benefit.
             */
            subscription_id: string | null;
            /**
             * Order Id
             * @description The ID of the order that granted this benefit.
             */
            order_id: string | null;
            /**
             * Customer Id
             * Format: uuid4
             * @description The ID of the customer concerned by this grant.
             */
            customer_id: string;
            /**
             * Benefit Id
             * Format: uuid4
             * @description The ID of the benefit concerned by this grant.
             */
            benefit_id: string;
            /** @description The error information if the benefit grant failed with an unrecoverable error. */
            error?: components["schemas"]["BenefitGrantError"] | null;
            customer: components["schemas"]["Customer"];
            /** Properties */
            properties: components["schemas"]["BenefitGrantDiscordProperties"] | components["schemas"]["BenefitGrantGitHubRepositoryProperties"] | components["schemas"]["BenefitGrantDownloadablesProperties"] | components["schemas"]["BenefitGrantLicenseKeysProperties"] | components["schemas"]["BenefitGrantCustomProperties"];
            /** Benefit */
            benefit: components["schemas"]["Benefit"];
            /** Previous Properties */
            previous_properties?: components["schemas"]["BenefitGrantDiscordProperties"] | components["schemas"]["BenefitGrantGitHubRepositoryProperties"] | components["schemas"]["BenefitGrantDownloadablesProperties"] | components["schemas"]["BenefitGrantLicenseKeysProperties"] | components["schemas"]["BenefitGrantCustomProperties"] | null;
        };
        /** BenefitLicenseKeyActivationCreateProperties */
        BenefitLicenseKeyActivationCreateProperties: {
            /** Limit */
            limit: number;
            /** Enable Customer Admin */
            enable_customer_admin: boolean;
        };
        /** BenefitLicenseKeyActivationProperties */
        BenefitLicenseKeyActivationProperties: {
            /** Limit */
            limit: number;
            /** Enable Customer Admin */
            enable_customer_admin: boolean;
        };
        /** BenefitLicenseKeyExpirationProperties */
        BenefitLicenseKeyExpirationProperties: {
            /** Ttl */
            ttl: number;
            /**
             * Timeframe
             * @enum {string}
             */
            timeframe: "year" | "month" | "day";
        };
        /** BenefitLicenseKeys */
        BenefitLicenseKeys: {
            /**
             * Id
             * Format: uuid4
             * @description The ID of the benefit.
             */
            id: string;
            /**
             * Created At
             * Format: date-time
             * @description Creation timestamp of the object.
             */
            created_at: string;
            /**
             * Modified At
             * @description Last modification timestamp of the object.
             */
            modified_at: string | null;
            /**
             * Type
             * @constant
             */
            type: "license_keys";
            /**
             * Description
             * @description The description of the benefit.
             */
            description: string;
            /**
             * Selectable
             * @description Whether the benefit is selectable when creating a product.
             */
            selectable: boolean;
            /**
             * Deletable
             * @description Whether the benefit is deletable.
             */
            deletable: boolean;
            /**
             * Organization Id
             * Format: uuid4
             * @description The ID of the organization owning the benefit.
             */
            organization_id: string;
            /** Metadata */
            metadata: {
                [key: string]: string | number | boolean;
            };
            properties: components["schemas"]["BenefitLicenseKeysProperties"];
        };
        /** BenefitLicenseKeysCreate */
        BenefitLicenseKeysCreate: {
            /**
             * Metadata
             * @description Key-value object allowing you to store additional information.
             *
             *     The key must be a string with a maximum length of **40 characters**.
             *     The value must be either:
             *
             *     * A string with a maximum length of **500 characters**
             *     * An integer
             *     * A floating-point number
             *     * A boolean
             *
             *     You can store up to **50 key-value pairs**.
             */
            metadata?: {
                [key: string]: string | number | boolean;
            };
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            type: "license_keys";
            /**
             * Description
             * @description The description of the benefit. Will be displayed on products having this benefit.
             */
            description: string;
            /**
             * Organization Id
             * @description The ID of the organization owning the benefit. **Required unless you use an organization token.**
             */
            organization_id?: string | null;
            properties: components["schemas"]["BenefitLicenseKeysCreateProperties"];
        };
        /** BenefitLicenseKeysCreateProperties */
        BenefitLicenseKeysCreateProperties: {
            /** Prefix */
            prefix?: string | null;
            expires?: components["schemas"]["BenefitLicenseKeyExpirationProperties"] | null;
            activations?: components["schemas"]["BenefitLicenseKeyActivationCreateProperties"] | null;
            /** Limit Usage */
            limit_usage?: number | null;
        };
        /** BenefitLicenseKeysProperties */
        BenefitLicenseKeysProperties: {
            /** Prefix */
            prefix: string | null;
            expires: components["schemas"]["BenefitLicenseKeyExpirationProperties"] | null;
            activations: components["schemas"]["BenefitLicenseKeyActivationProperties"] | null;
            /** Limit Usage */
            limit_usage: number | null;
        };
        /** BenefitLicenseKeysSubscriber */
        BenefitLicenseKeysSubscriber: {
            /**
             * Id
             * Format: uuid4
             * @description The ID of the benefit.
             */
            id: string;
            /**
             * Created At
             * Format: date-time
             * @description Creation timestamp of the object.
             */
            created_at: string;
            /**
             * Modified At
             * @description Last modification timestamp of the object.
             */
            modified_at: string | null;
            /**
             * Type
             * @constant
             */
            type: "license_keys";
            /**
             * Description
             * @description The description of the benefit.
             */
            description: string;
            /**
             * Selectable
             * @description Whether the benefit is selectable when creating a product.
             */
            selectable: boolean;
            /**
             * Deletable
             * @description Whether the benefit is deletable.
             */
            deletable: boolean;
            /**
             * Organization Id
             * Format: uuid4
             * @description The ID of the organization owning the benefit.
             */
            organization_id: string;
            /** Metadata */
            metadata: {
                [key: string]: string | number | boolean;
            };
            organization: components["schemas"]["Organization"];
            properties: components["schemas"]["BenefitLicenseKeysSubscriberProperties"];
        };
        /** BenefitLicenseKeysSubscriberProperties */
        BenefitLicenseKeysSubscriberProperties: {
            /** Prefix */
            prefix: string | null;
            expires: components["schemas"]["BenefitLicenseKeyExpirationProperties"] | null;
            activations: components["schemas"]["BenefitLicenseKeyActivationProperties"] | null;
            /** Limit Usage */
            limit_usage: number | null;
        };
        /** BenefitLicenseKeysUpdate */
        BenefitLicenseKeysUpdate: {
            /**
             * Metadata
             * @description Key-value object allowing you to store additional information.
             *
             *     The key must be a string with a maximum length of **40 characters**.
             *     The value must be either:
             *
             *     * A string with a maximum length of **500 characters**
             *     * An integer
             *     * A floating-point number
             *     * A boolean
             *
             *     You can store up to **50 key-value pairs**.
             */
            metadata?: {
                [key: string]: string | number | boolean;
            };
            /**
             * Description
             * @description The description of the benefit. Will be displayed on products having this benefit.
             */
            description?: string | null;
            /**
             * Type
             * @constant
             */
            type: "license_keys";
            properties?: components["schemas"]["BenefitLicenseKeysCreateProperties"] | null;
        };
        /**
         * BenefitMeterCredit
         * @description A benefit of type `meter_unit`.
         *
         *     Use it to grant a number of units on a specific meter.
         */
        BenefitMeterCredit: {
            /**
             * Id
             * Format: uuid4
             * @description The ID of the benefit.
             */
            id: string;
            /**
             * Created At
             * Format: date-time
             * @description Creation timestamp of the object.
             */
            created_at: string;
            /**
             * Modified At
             * @description Last modification timestamp of the object.
             */
            modified_at: string | null;
            /**
             * Type
             * @constant
             */
            type: "meter_credit";
            /**
             * Description
             * @description The description of the benefit.
             */
            description: string;
            /**
             * Selectable
             * @description Whether the benefit is selectable when creating a product.
             */
            selectable: boolean;
            /**
             * Deletable
             * @description Whether the benefit is deletable.
             */
            deletable: boolean;
            /**
             * Organization Id
             * Format: uuid4
             * @description The ID of the organization owning the benefit.
             */
            organization_id: string;
            /** Metadata */
            metadata: {
                [key: string]: string | number | boolean;
            };
            properties: components["schemas"]["BenefitMeterCreditProperties"];
        };
        /**
         * BenefitMeterCreditCreate
         * @description Schema to create a benefit of type `meter_unit`.
         */
        BenefitMeterCreditCreate: {
            /**
             * Metadata
             * @description Key-value object allowing you to store additional information.
             *
             *     The key must be a string with a maximum length of **40 characters**.
             *     The value must be either:
             *
             *     * A string with a maximum length of **500 characters**
             *     * An integer
             *     * A floating-point number
             *     * A boolean
             *
             *     You can store up to **50 key-value pairs**.
             */
            metadata?: {
                [key: string]: string | number | boolean;
            };
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            type: "meter_credit";
            /**
             * Description
             * @description The description of the benefit. Will be displayed on products having this benefit.
             */
            description: string;
            /**
             * Organization Id
             * @description The ID of the organization owning the benefit. **Required unless you use an organization token.**
             */
            organization_id?: string | null;
            properties: components["schemas"]["BenefitMeterCreditCreateProperties"];
        };
        /**
         * BenefitMeterCreditCreateProperties
         * @description Properties for creating a benefit of type `meter_unit`.
         */
        BenefitMeterCreditCreateProperties: {
            /** Units */
            units: number;
            /** Rollover */
            rollover: boolean;
            /**
             * Meter Id
             * Format: uuid4
             */
            meter_id: string;
        };
        /**
         * BenefitMeterCreditProperties
         * @description Properties for a benefit of type `meter_unit`.
         */
        BenefitMeterCreditProperties: {
            /** Units */
            units: number;
            /** Rollover */
            rollover: boolean;
            /**
             * Meter Id
             * Format: uuid4
             */
            meter_id: string;
        };
        /** BenefitMeterCreditSubscriber */
        BenefitMeterCreditSubscriber: {
            /**
             * Id
             * Format: uuid4
             * @description The ID of the benefit.
             */
            id: string;
            /**
             * Created At
             * Format: date-time
             * @description Creation timestamp of the object.
             */
            created_at: string;
            /**
             * Modified At
             * @description Last modification timestamp of the object.
             */
            modified_at: string | null;
            /**
             * Type
             * @constant
             */
            type: "meter_credit";
            /**
             * Description
             * @description The description of the benefit.
             */
            description: string;
            /**
             * Selectable
             * @description Whether the benefit is selectable when creating a product.
             */
            selectable: boolean;
            /**
             * Deletable
             * @description Whether the benefit is deletable.
             */
            deletable: boolean;
            /**
             * Organization Id
             * Format: uuid4
             * @description The ID of the organization owning the benefit.
             */
            organization_id: string;
            /** Metadata */
            metadata: {
                [key: string]: string | number | boolean;
            };
            organization: components["schemas"]["Organization"];
            properties: components["schemas"]["BenefitMeterCreditSubscriberProperties"];
        };
        /**
         * BenefitMeterCreditSubscriberProperties
         * @description Properties available to subscribers for a benefit of type `meter_unit`.
         */
        BenefitMeterCreditSubscriberProperties: {
            /** Units */
            units: number;
            /** Rollover */
            rollover: boolean;
            /**
             * Meter Id
             * Format: uuid4
             */
            meter_id: string;
        };
        /** BenefitMeterCreditUpdate */
        BenefitMeterCreditUpdate: {
            /**
             * Metadata
             * @description Key-value object allowing you to store additional information.
             *
             *     The key must be a string with a maximum length of **40 characters**.
             *     The value must be either:
             *
             *     * A string with a maximum length of **500 characters**
             *     * An integer
             *     * A floating-point number
             *     * A boolean
             *
             *     You can store up to **50 key-value pairs**.
             */
            metadata?: {
                [key: string]: string | number | boolean;
            };
            /**
             * Description
             * @description The description of the benefit. Will be displayed on products having this benefit.
             */
            description?: string | null;
            /**
             * Type
             * @constant
             */
            type: "meter_credit";
            properties?: components["schemas"]["BenefitMeterCreditCreateProperties"] | null;
        };
        /** BenefitPublic */
        BenefitPublic: {
            /**
             * Id
             * Format: uuid4
             * @description The ID of the benefit.
             */
            id: string;
            /**
             * Created At
             * Format: date-time
             * @description Creation timestamp of the object.
             */
            created_at: string;
            /**
             * Modified At
             * @description Last modification timestamp of the object.
             */
            modified_at: string | null;
            /** @description The type of the benefit. */
            type: components["schemas"]["BenefitType"];
            /**
             * Description
             * @description The description of the benefit.
             */
            description: string;
            /**
             * Selectable
             * @description Whether the benefit is selectable when creating a product.
             */
            selectable: boolean;
            /**
             * Deletable
             * @description Whether the benefit is deletable.
             */
            deletable: boolean;
            /**
             * Organization Id
             * Format: uuid4
             * @description The ID of the organization owning the benefit.
             */
            organization_id: string;
        };
        /**
         * BenefitSortProperty
         * @enum {string}
         */
        BenefitSortProperty: "created_at" | "-created_at" | "description" | "-description";
        /**
         * BenefitType
         * @enum {string}
         */
        BenefitType: "custom" | "discord" | "github_repository" | "downloadables" | "license_keys" | "meter_credit";
        /** Body_email-update:verify_email_update */
        "Body_email-update_verify_email_update": {
            /** Token */
            token: string;
        };
        /** Body_oauth2:consent */
        Body_oauth2_consent: {
            /**
             * Action
             * @enum {string}
             */
            action: "allow" | "deny";
        };
        /**
         * CardPayment
         * @description Schema of a payment with a card payment method.
         */
        CardPayment: {
            /**
             * Created At
             * Format: date-time
             * @description Creation timestamp of the object.
             */
            created_at: string;
            /**
             * Modified At
             * @description Last modification timestamp of the object.
             */
            modified_at: string | null;
            /**
             * Id
             * Format: uuid4
             * @description The ID of the object.
             */
            id: string;
            /** @description The payment processor. */
            processor: components["schemas"]["PaymentProcessor"];
            /** @description The payment status. */
            status: components["schemas"]["PaymentStatus"];
            /**
             * Amount
             * @description The payment amount in cents.
             */
            amount: number;
            /**
             * Currency
             * @description The payment currency. Currently, only `usd` is supported.
             */
            currency: string;
            /**
             * Method
             * @description The payment method used.
             * @constant
             */
            method: "card";
            /**
             * Decline Reason
             * @description Error code, if the payment was declined.
             */
            decline_reason: string | null;
            /**
             * Decline Message
             * @description Human-reasable error message, if the payment was declined.
             */
            decline_message: string | null;
            /**
             * Organization Id
             * Format: uuid4
             * @description The ID of the organization that owns the payment.
             */
            organization_id: string;
            /**
             * Checkout Id
             * @description The ID of the checkout session associated with this payment.
             */
            checkout_id: string | null;
            /**
             * Order Id
             * @description The ID of the order associated with this payment.
             */
            order_id: string | null;
            /** @description Additional metadata for the card payment method. */
            method_metadata: components["schemas"]["CardPaymentMetadata"];
        };
        /**
         * CardPaymentMetadata
         * @description Additional metadata for a card payment method.
         */
        CardPaymentMetadata: {
            /**
             * Brand
             * @description The brand of the card used for the payment.
             */
            brand: string;
            /**
             * Last4
             * @description The last 4 digits of the card number.
             */
            last4: string;
        };
        /**
         * Checkout
         * @description Checkout session data retrieved using an access token.
         */
        Checkout: {
            /**
             * Created At
             * Format: date-time
             * @description Creation timestamp of the object.
             */
            created_at: string;
            /**
             * Modified At
             * @description Last modification timestamp of the object.
             */
            modified_at: string | null;
            /**
             * Id
             * Format: uuid4
             * @description The ID of the object.
             */
            id: string;
            /**
             * Custom Field Data
             * @description Key-value object storing custom field values.
             */
            custom_field_data?: {
                [key: string]: string | number | boolean | null;
            };
            /** @description Payment processor used. */
            payment_processor: components["schemas"]["PaymentProcessor"];
            /** @description Status of the checkout session. */
            status: components["schemas"]["CheckoutStatus"];
            /**
             * Client Secret
             * @description Client secret used to update and complete the checkout session from the client.
             */
            client_secret: string;
            /**
             * Url
             * @description URL where the customer can access the checkout session.
             */
            url: string;
            /**
             * Expires At
             * Format: date-time
             * @description Expiration date and time of the checkout session.
             */
            expires_at: string;
            /**
             * Success Url
             * @description URL where the customer will be redirected after a successful payment.
             */
            success_url: string;
            /**
             * Embed Origin
             * @description When checkout is embedded, represents the Origin of the page embedding the checkout. Used as a security measure to send messages only to the embedding page.
             */
            embed_origin: string | null;
            /**
             * Amount
             * @description Amount in cents, before discounts and taxes.
             */
            amount: number;
            /**
             * Discount Amount
             * @description Discount amount in cents.
             */
            discount_amount: number;
            /**
             * Net Amount
             * @description Amount in cents, after discounts but before taxes.
             */
            net_amount: number;
            /**
             * Tax Amount
             * @description Sales tax amount in cents. If `null`, it means there is no enough information yet to calculate it.
             */
            tax_amount: number | null;
            /**
             * Total Amount
             * @description Amount in cents, after discounts and taxes.
             */
            total_amount: number;
            /**
             * Currency
             * @description Currency code of the checkout session.
             */
            currency: string;
            /**
             * Product Id
             * Format: uuid4
             * @description ID of the product to checkout.
             */
            product_id: string;
            /**
             * Product Price Id
             * Format: uuid4
             * @description ID of the product price to checkout.
             */
            product_price_id: string;
            /**
             * Discount Id
             * @description ID of the discount applied to the checkout.
             */
            discount_id: string | null;
            /**
             * Allow Discount Codes
             * @description Whether to allow the customer to apply discount codes. If you apply a discount through `discount_id`, it'll still be applied, but the customer won't be able to change it.
             */
            allow_discount_codes: boolean;
            /**
             * Require Billing Address
             * @description Whether to require the customer to fill their full billing address, instead of just the country. Customers in the US will always be required to fill their full address, regardless of this setting. If you preset the billing address, this setting will be automatically set to `true`.
             */
            require_billing_address: boolean;
            /**
             * Is Discount Applicable
             * @description Whether the discount is applicable to the checkout. Typically, free and custom prices are not discountable.
             */
            is_discount_applicable: boolean;
            /**
             * Is Free Product Price
             * @description Whether the product price is free, regardless of discounts.
             */
            is_free_product_price: boolean;
            /**
             * Is Payment Required
             * @description Whether the checkout requires payment, e.g. in case of free products or discounts that cover the total amount.
             */
            is_payment_required: boolean;
            /**
             * Is Payment Setup Required
             * @description Whether the checkout requires setting up a payment method, regardless of the amount, e.g. subscriptions that have first free cycles.
             */
            is_payment_setup_required: boolean;
            /**
             * Is Payment Form Required
             * @description Whether the checkout requires a payment form, whether because of a payment or payment method setup.
             */
            is_payment_form_required: boolean;
            /** Customer Id */
            customer_id: string | null;
            /**
             * Customer Name
             * @description Name of the customer.
             */
            customer_name: string | null;
            /**
             * Customer Email
             * @description Email address of the customer.
             */
            customer_email: string | null;
            /** Customer Ip Address */
            customer_ip_address: string | null;
            customer_billing_address: components["schemas"]["Address"] | null;
            /** Customer Tax Id */
            customer_tax_id: string | null;
            /** Payment Processor Metadata */
            payment_processor_metadata: {
                [key: string]: string;
            };
            /** Metadata */
            metadata: {
                [key: string]: string | number | boolean;
            };
            /**
             * Customer External Id
             * @description ID of the customer in your system. If a matching customer exists on Polar, the resulting order will be linked to this customer. Otherwise, a new customer will be created with this external ID set.
             */
            customer_external_id: string | null;
            /**
             * Products
             * @description List of products available to select.
             */
            products: components["schemas"]["CheckoutProduct"][];
            /** @description Product selected to checkout. */
            product: components["schemas"]["CheckoutProduct"];
            /**
             * Product Price
             * @description Price of the selected product.
             */
            product_price: components["schemas"]["LegacyRecurringProductPrice"] | components["schemas"]["ProductPrice"];
            /** Discount */
            discount: (components["schemas"]["CheckoutDiscountFixedOnceForeverDuration"] | components["schemas"]["CheckoutDiscountFixedRepeatDuration"] | components["schemas"]["CheckoutDiscountPercentageOnceForeverDuration"] | components["schemas"]["CheckoutDiscountPercentageRepeatDuration"]) | null;
            /** Subscription Id */
            subscription_id: string | null;
            /** Attached Custom Fields */
            attached_custom_fields: components["schemas"]["AttachedCustomField"][];
            /** Customer Metadata */
            customer_metadata: {
                [key: string]: string | number | boolean;
            };
            /** @description Determine which billing address fields should be shown in the checkout form. */
            readonly customer_billing_address_fields: components["schemas"]["CheckoutCustomerBillingAddressFields"];
        };
        /**
         * CheckoutConfirmStripe
         * @description Confirm a checkout session using a Stripe confirmation token.
         */
        CheckoutConfirmStripe: {
            /**
             * Custom Field Data
             * @description Key-value object storing custom field values.
             */
            custom_field_data?: {
                [key: string]: string | number | boolean | null;
            };
            /**
             * Product Id
             * @description ID of the product to checkout. Must be present in the checkout's product list.
             */
            product_id?: string | null;
            /**
             * Product Price Id
             * @deprecated
             * @description ID of the product price to checkout. Must correspond to a price present in the checkout's product list.
             */
            product_price_id?: string | null;
            /** Amount */
            amount?: number | null;
            /** Customer Name */
            customer_name?: string | null;
            /** Customer Email */
            customer_email?: string | null;
            customer_billing_address?: components["schemas"]["Address"] | null;
            /** Customer Tax Id */
            customer_tax_id?: string | null;
            /**
             * Discount Code
             * @description Discount code to apply to the checkout.
             */
            discount_code?: string | null;
            /**
             * Confirmation Token Id
             * @description ID of the Stripe confirmation token. Required for fixed prices and custom prices.
             */
            confirmation_token_id?: string | null;
        };
        CheckoutCreate: components["schemas"]["CheckoutProductsCreate"];
        /**
         * CheckoutCreatePublic
         * @description Create a new checkout session from a client.
         */
        CheckoutCreatePublic: {
            /**
             * Product Id
             * Format: uuid4
             * @description ID of the product to checkout.
             */
            product_id: string;
            /** Customer Email */
            customer_email?: string | null;
            /**
             * Subscription Id
             * @description ID of a subscription to upgrade. It must be on a free pricing. If checkout is successful, metadata set on this checkout will be copied to the subscription, and existing keys will be overwritten.
             */
            subscription_id?: string | null;
        };
        /** CheckoutCustomerBillingAddressFields */
        CheckoutCustomerBillingAddressFields: {
            /** Country */
            country: boolean;
            /** State */
            state: boolean;
            /** City */
            city: boolean;
            /** Postal Code */
            postal_code: boolean;
            /** Line1 */
            line1: boolean;
            /** Line2 */
            line2: boolean;
        };
        /**
         * CheckoutDiscountFixedOnceForeverDuration
         * @description Schema for a fixed amount discount that is applied once or forever.
         */
        CheckoutDiscountFixedOnceForeverDuration: {
            duration: components["schemas"]["DiscountDuration"];
            type: components["schemas"]["DiscountType"];
            /** Amount */
            amount: number;
            /** Currency */
            currency: string;
            /**
             * Id
             * Format: uuid4
             * @description The ID of the object.
             */
            id: string;
            /** Name */
            name: string;
            /** Code */
            code: string | null;
        };
        /**
         * CheckoutDiscountFixedRepeatDuration
         * @description Schema for a fixed amount discount that is applied on every invoice
         *     for a certain number of months.
         */
        CheckoutDiscountFixedRepeatDuration: {
            duration: components["schemas"]["DiscountDuration"];
            /** Duration In Months */
            duration_in_months: number;
            type: components["schemas"]["DiscountType"];
            /** Amount */
            amount: number;
            /** Currency */
            currency: string;
            /**
             * Id
             * Format: uuid4
             * @description The ID of the object.
             */
            id: string;
            /** Name */
            name: string;
            /** Code */
            code: string | null;
        };
        /**
         * CheckoutDiscountPercentageOnceForeverDuration
         * @description Schema for a percentage discount that is applied once or forever.
         */
        CheckoutDiscountPercentageOnceForeverDuration: {
            duration: components["schemas"]["DiscountDuration"];
            type: components["schemas"]["DiscountType"];
            /** Basis Points */
            basis_points: number;
            /**
             * Id
             * Format: uuid4
             * @description The ID of the object.
             */
            id: string;
            /** Name */
            name: string;
            /** Code */
            code: string | null;
        };
        /**
         * CheckoutDiscountPercentageRepeatDuration
         * @description Schema for a percentage discount that is applied on every invoice
         *     for a certain number of months.
         */
        CheckoutDiscountPercentageRepeatDuration: {
            duration: components["schemas"]["DiscountDuration"];
            /** Duration In Months */
            duration_in_months: number;
            type: components["schemas"]["DiscountType"];
            /** Basis Points */
            basis_points: number;
            /**
             * Id
             * Format: uuid4
             * @description The ID of the object.
             */
            id: string;
            /** Name */
            name: string;
            /** Code */
            code: string | null;
        };
        CheckoutForbiddenError: components["schemas"]["AlreadyActiveSubscriptionError"] | components["schemas"]["NotOpenCheckout"];
        /**
         * CheckoutLink
         * @description Checkout link data.
         */
        CheckoutLink: {
            /**
             * Created At
             * Format: date-time
             * @description Creation timestamp of the object.
             */
            created_at: string;
            /**
             * Modified At
             * @description Last modification timestamp of the object.
             */
            modified_at: string | null;
            /**
             * Id
             * Format: uuid4
             * @description The ID of the object.
             */
            id: string;
            /** Metadata */
            metadata: {
                [key: string]: string | number | boolean;
            };
            /** @description Payment processor used. */
            payment_processor: components["schemas"]["PaymentProcessor"];
            /**
             * Client Secret
             * @description Client secret used to access the checkout link.
             */
            client_secret: string;
            /**
             * Success Url
             * @description URL where the customer will be redirected after a successful payment.
             */
            success_url: string | null;
            /**
             * Label
             * @description Optional label to distinguish links internally
             */
            label: string | null;
            /**
             * Allow Discount Codes
             * @description Whether to allow the customer to apply discount codes. If you apply a discount through `discount_id`, it'll still be applied, but the customer won't be able to change it.
             */
            allow_discount_codes: boolean;
            /**
             * Require Billing Address
             * @description Whether to require the customer to fill their full billing address, instead of just the country. Customers in the US will always be required to fill their full address, regardless of this setting.
             */
            require_billing_address: boolean;
            /**
             * Discount Id
             * @description ID of the discount to apply to the checkout. If the discount is not applicable anymore when opening the checkout link, it'll be ignored.
             */
            discount_id: string | null;
            /**
             * Organization Id
             * Format: uuid4
             * @description The organization ID.
             */
            organization_id: string;
            /** Products */
            products: components["schemas"]["CheckoutLinkProduct"][];
            /** Discount */
            discount: (components["schemas"]["DiscountFixedOnceForeverDurationBase"] | components["schemas"]["DiscountFixedRepeatDurationBase"] | components["schemas"]["DiscountPercentageOnceForeverDurationBase"] | components["schemas"]["DiscountPercentageRepeatDurationBase"]) | null;
            /** Url */
            readonly url: string;
        };
        /**
         * CheckoutLinkCreateProduct
         * @description Schema to create a new checkout link from a a single product.
         *
         *     **Deprecated**: Use `CheckoutLinkCreateProducts` instead.
         */
        CheckoutLinkCreateProduct: {
            /**
             * Metadata
             * @description Key-value object allowing you to store additional information.
             *
             *     The key must be a string with a maximum length of **40 characters**.
             *     The value must be either:
             *
             *     * A string with a maximum length of **500 characters**
             *     * An integer
             *     * A floating-point number
             *     * A boolean
             *
             *     You can store up to **50 key-value pairs**.
             */
            metadata?: {
                [key: string]: string | number | boolean;
            };
            /**
             * Payment Processor
             * @description Payment processor to use. Currently only Stripe is supported.
             * @constant
             */
            payment_processor: "stripe";
            /**
             * Label
             * @description Optional label to distinguish links internally
             */
            label?: string | null;
            /**
             * Allow Discount Codes
             * @description Whether to allow the customer to apply discount codes. If you apply a discount through `discount_id`, it'll still be applied, but the customer won't be able to change it.
             * @default true
             */
            allow_discount_codes: boolean;
            /**
             * Require Billing Address
             * @description Whether to require the customer to fill their full billing address, instead of just the country. Customers in the US will always be required to fill their full address, regardless of this setting.
             * @default false
             */
            require_billing_address: boolean;
            /**
             * Discount Id
             * @description ID of the discount to apply to the checkout. If the discount is not applicable anymore when opening the checkout link, it'll be ignored.
             */
            discount_id?: string | null;
            /**
             * Success Url
             * @description URL where the customer will be redirected after a successful payment.You can add the `checkout_id={CHECKOUT_ID}` query parameter to retrieve the checkout session id.
             */
            success_url?: string | null;
            /**
             * Product Id
             * Format: uuid4
             */
            product_id: string;
        };
        /**
         * CheckoutLinkCreateProductPrice
         * @description Schema to create a new checkout link from a a single product price.
         *
         *     **Deprecated**: Use `CheckoutLinkCreateProducts` instead.
         */
        CheckoutLinkCreateProductPrice: {
            /**
             * Metadata
             * @description Key-value object allowing you to store additional information.
             *
             *     The key must be a string with a maximum length of **40 characters**.
             *     The value must be either:
             *
             *     * A string with a maximum length of **500 characters**
             *     * An integer
             *     * A floating-point number
             *     * A boolean
             *
             *     You can store up to **50 key-value pairs**.
             */
            metadata?: {
                [key: string]: string | number | boolean;
            };
            /**
             * Payment Processor
             * @description Payment processor to use. Currently only Stripe is supported.
             * @constant
             */
            payment_processor: "stripe";
            /**
             * Label
             * @description Optional label to distinguish links internally
             */
            label?: string | null;
            /**
             * Allow Discount Codes
             * @description Whether to allow the customer to apply discount codes. If you apply a discount through `discount_id`, it'll still be applied, but the customer won't be able to change it.
             * @default true
             */
            allow_discount_codes: boolean;
            /**
             * Require Billing Address
             * @description Whether to require the customer to fill their full billing address, instead of just the country. Customers in the US will always be required to fill their full address, regardless of this setting.
             * @default false
             */
            require_billing_address: boolean;
            /**
             * Discount Id
             * @description ID of the discount to apply to the checkout. If the discount is not applicable anymore when opening the checkout link, it'll be ignored.
             */
            discount_id?: string | null;
            /**
             * Success Url
             * @description URL where the customer will be redirected after a successful payment.You can add the `checkout_id={CHECKOUT_ID}` query parameter to retrieve the checkout session id.
             */
            success_url?: string | null;
            /**
             * Product Price Id
             * Format: uuid4
             */
            product_price_id: string;
        };
        /**
         * CheckoutLinkCreateProducts
         * @description Schema to create a new checkout link.
         */
        CheckoutLinkCreateProducts: {
            /**
             * Metadata
             * @description Key-value object allowing you to store additional information.
             *
             *     The key must be a string with a maximum length of **40 characters**.
             *     The value must be either:
             *
             *     * A string with a maximum length of **500 characters**
             *     * An integer
             *     * A floating-point number
             *     * A boolean
             *
             *     You can store up to **50 key-value pairs**.
             */
            metadata?: {
                [key: string]: string | number | boolean;
            };
            /**
             * Payment Processor
             * @description Payment processor to use. Currently only Stripe is supported.
             * @constant
             */
            payment_processor: "stripe";
            /**
             * Label
             * @description Optional label to distinguish links internally
             */
            label?: string | null;
            /**
             * Allow Discount Codes
             * @description Whether to allow the customer to apply discount codes. If you apply a discount through `discount_id`, it'll still be applied, but the customer won't be able to change it.
             * @default true
             */
            allow_discount_codes: boolean;
            /**
             * Require Billing Address
             * @description Whether to require the customer to fill their full billing address, instead of just the country. Customers in the US will always be required to fill their full address, regardless of this setting.
             * @default false
             */
            require_billing_address: boolean;
            /**
             * Discount Id
             * @description ID of the discount to apply to the checkout. If the discount is not applicable anymore when opening the checkout link, it'll be ignored.
             */
            discount_id?: string | null;
            /**
             * Success Url
             * @description URL where the customer will be redirected after a successful payment.You can add the `checkout_id={CHECKOUT_ID}` query parameter to retrieve the checkout session id.
             */
            success_url?: string | null;
            /**
             * Products
             * @description List of products that will be available to select at checkout.
             */
            products: string[];
        };
        /**
         * CheckoutLinkProduct
         * @description Product data for a checkout link.
         */
        CheckoutLinkProduct: {
            /** Metadata */
            metadata: {
                [key: string]: string | number | boolean;
            };
            /**
             * Created At
             * Format: date-time
             * @description Creation timestamp of the object.
             */
            created_at: string;
            /**
             * Modified At
             * @description Last modification timestamp of the object.
             */
            modified_at: string | null;
            /**
             * Id
             * Format: uuid4
             * @description The ID of the product.
             */
            id: string;
            /**
             * Name
             * @description The name of the product.
             */
            name: string;
            /**
             * Description
             * @description The description of the product.
             */
            description: string | null;
            /** @description The recurring interval of the product. If `None`, the product is a one-time purchase. */
            recurring_interval: components["schemas"]["SubscriptionRecurringInterval"] | null;
            /**
             * Is Recurring
             * @description Whether the product is a subscription.
             */
            is_recurring: boolean;
            /**
             * Is Archived
             * @description Whether the product is archived and no longer available.
             */
            is_archived: boolean;
            /**
             * Organization Id
             * Format: uuid4
             * @description The ID of the organization owning the product.
             */
            organization_id: string;
            /**
             * Prices
             * @description List of prices for this product.
             */
            prices: (components["schemas"]["LegacyRecurringProductPrice"] | components["schemas"]["ProductPrice"])[];
            /**
             * BenefitPublic
             * @description List of benefits granted by the product.
             */
            benefits: components["schemas"]["BenefitPublic"][];
            /**
             * Medias
             * @description List of medias associated to the product.
             */
            medias: components["schemas"]["ProductMediaFileRead"][];
        };
        /**
         * CheckoutLinkSortProperty
         * @enum {string}
         */
        CheckoutLinkSortProperty: "created_at" | "-created_at" | "label" | "-label" | "success_url" | "-success_url" | "allow_discount_codes" | "-allow_discount_codes";
        /**
         * CheckoutLinkUpdate
         * @description Schema to update an existing checkout link.
         */
        CheckoutLinkUpdate: {
            /**
             * Metadata
             * @description Key-value object allowing you to store additional information.
             *
             *     The key must be a string with a maximum length of **40 characters**.
             *     The value must be either:
             *
             *     * A string with a maximum length of **500 characters**
             *     * An integer
             *     * A floating-point number
             *     * A boolean
             *
             *     You can store up to **50 key-value pairs**.
             */
            metadata?: {
                [key: string]: string | number | boolean;
            };
            /**
             * Products
             * @description List of products that will be available to select at checkout.
             */
            products?: string[] | null;
            /** Label */
            label?: string | null;
            /**
             * Allow Discount Codes
             * @description Whether to allow the customer to apply discount codes. If you apply a discount through `discount_id`, it'll still be applied, but the customer won't be able to change it.
             */
            allow_discount_codes?: boolean | null;
            /**
             * Require Billing Address
             * @description Whether to require the customer to fill their full billing address, instead of just the country. Customers in the US will always be required to fill their full address, regardless of this setting.
             */
            require_billing_address?: boolean | null;
            /**
             * Discount Id
             * @description ID of the discount to apply to the checkout. If the discount is not applicable anymore when opening the checkout link, it'll be ignored.
             */
            discount_id?: string | null;
            /**
             * Success Url
             * @description URL where the customer will be redirected after a successful payment.You can add the `checkout_id={CHECKOUT_ID}` query parameter to retrieve the checkout session id.
             */
            success_url?: string | null;
        };
        /**
         * CheckoutPriceCreate
         * @description Create a new checkout session from a product price.
         *
         *     **Deprecated**: Use `CheckoutProductsCreate` instead.
         *
         *     Metadata set on the checkout will be copied
         *     to the resulting order and/or subscription.
         */
        CheckoutPriceCreate: {
            /**
             * Metadata
             * @description Key-value object allowing you to store additional information.
             *
             *     The key must be a string with a maximum length of **40 characters**.
             *     The value must be either:
             *
             *     * A string with a maximum length of **500 characters**
             *     * An integer
             *     * A floating-point number
             *     * A boolean
             *
             *     You can store up to **50 key-value pairs**.
             */
            metadata?: {
                [key: string]: string | number | boolean;
            };
            /**
             * Custom Field Data
             * @description Key-value object storing custom field values.
             */
            custom_field_data?: {
                [key: string]: string | number | boolean | null;
            };
            /**
             * Discount Id
             * @description ID of the discount to apply to the checkout.
             */
            discount_id?: string | null;
            /**
             * Allow Discount Codes
             * @description Whether to allow the customer to apply discount codes. If you apply a discount through `discount_id`, it'll still be applied, but the customer won't be able to change it.
             * @default true
             */
            allow_discount_codes: boolean;
            /**
             * Require Billing Address
             * @description Whether to require the customer to fill their full billing address, instead of just the country. Customers in the US will always be required to fill their full address, regardless of this setting. If you preset the billing address, this setting will be automatically set to `true`.
             * @default false
             */
            require_billing_address: boolean;
            /** Amount */
            amount?: number | null;
            /**
             * Customer Id
             * @description ID of an existing customer in the organization. The customer data will be pre-filled in the checkout form. The resulting order will be linked to this customer.
             */
            customer_id?: string | null;
            /**
             * Customer External Id
             * @description ID of the customer in your system. If a matching customer exists on Polar, the resulting order will be linked to this customer. Otherwise, a new customer will be created with this external ID set.
             */
            customer_external_id?: string | null;
            /** Customer Name */
            customer_name?: string | null;
            /** Customer Email */
            customer_email?: string | null;
            /** Customer Ip Address */
            customer_ip_address?: string | null;
            customer_billing_address?: components["schemas"]["Address"] | null;
            /** Customer Tax Id */
            customer_tax_id?: string | null;
            /**
             * Customer Metadata
             * @description Key-value object allowing you to store additional information that'll be copied to the created customer.
             *
             *     The key must be a string with a maximum length of **40 characters**.
             *     The value must be either:
             *
             *     * A string with a maximum length of **500 characters**
             *     * An integer
             *     * A floating-point number
             *     * A boolean
             *
             *     You can store up to **50 key-value pairs**.
             */
            customer_metadata?: {
                [key: string]: string | number | boolean;
            };
            /**
             * Subscription Id
             * @description ID of a subscription to upgrade. It must be on a free pricing. If checkout is successful, metadata set on this checkout will be copied to the subscription, and existing keys will be overwritten.
             */
            subscription_id?: string | null;
            /**
             * Success Url
             * @description URL where the customer will be redirected after a successful payment.You can add the `checkout_id={CHECKOUT_ID}` query parameter to retrieve the checkout session id.
             */
            success_url?: string | null;
            /**
             * Embed Origin
             * @description If you plan to embed the checkout session, set this to the Origin of the embedding page. It'll allow the Polar iframe to communicate with the parent page.
             */
            embed_origin?: string | null;
            /**
             * Product Price Id
             * Format: uuid4
             * @description ID of the product price to checkout.
             */
            product_price_id: string;
        };
        /**
         * CheckoutProduct
         * @description Product data for a checkout session.
         */
        CheckoutProduct: {
            /**
             * Created At
             * Format: date-time
             * @description Creation timestamp of the object.
             */
            created_at: string;
            /**
             * Modified At
             * @description Last modification timestamp of the object.
             */
            modified_at: string | null;
            /**
             * Id
             * Format: uuid4
             * @description The ID of the product.
             */
            id: string;
            /**
             * Name
             * @description The name of the product.
             */
            name: string;
            /**
             * Description
             * @description The description of the product.
             */
            description: string | null;
            /** @description The recurring interval of the product. If `None`, the product is a one-time purchase. */
            recurring_interval: components["schemas"]["SubscriptionRecurringInterval"] | null;
            /**
             * Is Recurring
             * @description Whether the product is a subscription.
             */
            is_recurring: boolean;
            /**
             * Is Archived
             * @description Whether the product is archived and no longer available.
             */
            is_archived: boolean;
            /**
             * Organization Id
             * Format: uuid4
             * @description The ID of the organization owning the product.
             */
            organization_id: string;
            /**
             * Prices
             * @description List of prices for this product.
             */
            prices: (components["schemas"]["LegacyRecurringProductPrice"] | components["schemas"]["ProductPrice"])[];
            /**
             * BenefitPublic
             * @description List of benefits granted by the product.
             */
            benefits: components["schemas"]["BenefitPublic"][];
            /**
             * Medias
             * @description List of medias associated to the product.
             */
            medias: components["schemas"]["ProductMediaFileRead"][];
        };
        /**
         * CheckoutProductCreate
         * @description Create a new checkout session from a product.
         *
         *     **Deprecated**: Use `CheckoutProductsCreate` instead.
         *
         *     Metadata set on the checkout will be copied
         *     to the resulting order and/or subscription.
         */
        CheckoutProductCreate: {
            /**
             * Metadata
             * @description Key-value object allowing you to store additional information.
             *
             *     The key must be a string with a maximum length of **40 characters**.
             *     The value must be either:
             *
             *     * A string with a maximum length of **500 characters**
             *     * An integer
             *     * A floating-point number
             *     * A boolean
             *
             *     You can store up to **50 key-value pairs**.
             */
            metadata?: {
                [key: string]: string | number | boolean;
            };
            /**
             * Custom Field Data
             * @description Key-value object storing custom field values.
             */
            custom_field_data?: {
                [key: string]: string | number | boolean | null;
            };
            /**
             * Discount Id
             * @description ID of the discount to apply to the checkout.
             */
            discount_id?: string | null;
            /**
             * Allow Discount Codes
             * @description Whether to allow the customer to apply discount codes. If you apply a discount through `discount_id`, it'll still be applied, but the customer won't be able to change it.
             * @default true
             */
            allow_discount_codes: boolean;
            /**
             * Require Billing Address
             * @description Whether to require the customer to fill their full billing address, instead of just the country. Customers in the US will always be required to fill their full address, regardless of this setting. If you preset the billing address, this setting will be automatically set to `true`.
             * @default false
             */
            require_billing_address: boolean;
            /** Amount */
            amount?: number | null;
            /**
             * Customer Id
             * @description ID of an existing customer in the organization. The customer data will be pre-filled in the checkout form. The resulting order will be linked to this customer.
             */
            customer_id?: string | null;
            /**
             * Customer External Id
             * @description ID of the customer in your system. If a matching customer exists on Polar, the resulting order will be linked to this customer. Otherwise, a new customer will be created with this external ID set.
             */
            customer_external_id?: string | null;
            /** Customer Name */
            customer_name?: string | null;
            /** Customer Email */
            customer_email?: string | null;
            /** Customer Ip Address */
            customer_ip_address?: string | null;
            customer_billing_address?: components["schemas"]["Address"] | null;
            /** Customer Tax Id */
            customer_tax_id?: string | null;
            /**
             * Customer Metadata
             * @description Key-value object allowing you to store additional information that'll be copied to the created customer.
             *
             *     The key must be a string with a maximum length of **40 characters**.
             *     The value must be either:
             *
             *     * A string with a maximum length of **500 characters**
             *     * An integer
             *     * A floating-point number
             *     * A boolean
             *
             *     You can store up to **50 key-value pairs**.
             */
            customer_metadata?: {
                [key: string]: string | number | boolean;
            };
            /**
             * Subscription Id
             * @description ID of a subscription to upgrade. It must be on a free pricing. If checkout is successful, metadata set on this checkout will be copied to the subscription, and existing keys will be overwritten.
             */
            subscription_id?: string | null;
            /**
             * Success Url
             * @description URL where the customer will be redirected after a successful payment.You can add the `checkout_id={CHECKOUT_ID}` query parameter to retrieve the checkout session id.
             */
            success_url?: string | null;
            /**
             * Embed Origin
             * @description If you plan to embed the checkout session, set this to the Origin of the embedding page. It'll allow the Polar iframe to communicate with the parent page.
             */
            embed_origin?: string | null;
            /**
             * Product Id
             * Format: uuid4
             * @description ID of the product to checkout. First available price will be selected.
             */
            product_id: string;
        };
        /**
         * CheckoutProductsCreate
         * @description Create a new checkout session from a list of products.
         *     Customers will be able to switch between those products.
         *
         *     Metadata set on the checkout will be copied
         *     to the resulting order and/or subscription.
         */
        CheckoutProductsCreate: {
            /**
             * Metadata
             * @description Key-value object allowing you to store additional information.
             *
             *     The key must be a string with a maximum length of **40 characters**.
             *     The value must be either:
             *
             *     * A string with a maximum length of **500 characters**
             *     * An integer
             *     * A floating-point number
             *     * A boolean
             *
             *     You can store up to **50 key-value pairs**.
             */
            metadata?: {
                [key: string]: string | number | boolean;
            };
            /**
             * Custom Field Data
             * @description Key-value object storing custom field values.
             */
            custom_field_data?: {
                [key: string]: string | number | boolean | null;
            };
            /**
             * Discount Id
             * @description ID of the discount to apply to the checkout.
             */
            discount_id?: string | null;
            /**
             * Allow Discount Codes
             * @description Whether to allow the customer to apply discount codes. If you apply a discount through `discount_id`, it'll still be applied, but the customer won't be able to change it.
             * @default true
             */
            allow_discount_codes: boolean;
            /**
             * Require Billing Address
             * @description Whether to require the customer to fill their full billing address, instead of just the country. Customers in the US will always be required to fill their full address, regardless of this setting. If you preset the billing address, this setting will be automatically set to `true`.
             * @default false
             */
            require_billing_address: boolean;
            /** Amount */
            amount?: number | null;
            /**
             * Customer Id
             * @description ID of an existing customer in the organization. The customer data will be pre-filled in the checkout form. The resulting order will be linked to this customer.
             */
            customer_id?: string | null;
            /**
             * Customer External Id
             * @description ID of the customer in your system. If a matching customer exists on Polar, the resulting order will be linked to this customer. Otherwise, a new customer will be created with this external ID set.
             */
            customer_external_id?: string | null;
            /** Customer Name */
            customer_name?: string | null;
            /** Customer Email */
            customer_email?: string | null;
            /** Customer Ip Address */
            customer_ip_address?: string | null;
            customer_billing_address?: components["schemas"]["Address"] | null;
            /** Customer Tax Id */
            customer_tax_id?: string | null;
            /**
             * Customer Metadata
             * @description Key-value object allowing you to store additional information that'll be copied to the created customer.
             *
             *     The key must be a string with a maximum length of **40 characters**.
             *     The value must be either:
             *
             *     * A string with a maximum length of **500 characters**
             *     * An integer
             *     * A floating-point number
             *     * A boolean
             *
             *     You can store up to **50 key-value pairs**.
             */
            customer_metadata?: {
                [key: string]: string | number | boolean;
            };
            /**
             * Subscription Id
             * @description ID of a subscription to upgrade. It must be on a free pricing. If checkout is successful, metadata set on this checkout will be copied to the subscription, and existing keys will be overwritten.
             */
            subscription_id?: string | null;
            /**
             * Success Url
             * @description URL where the customer will be redirected after a successful payment.You can add the `checkout_id={CHECKOUT_ID}` query parameter to retrieve the checkout session id.
             */
            success_url?: string | null;
            /**
             * Embed Origin
             * @description If you plan to embed the checkout session, set this to the Origin of the embedding page. It'll allow the Polar iframe to communicate with the parent page.
             */
            embed_origin?: string | null;
            /**
             * Products
             * @description List of product IDs available to select at that checkout. The first one will be selected by default.
             */
            products: string[];
        };
        /**
         * CheckoutPublic
         * @description Checkout session data retrieved using the client secret.
         */
        CheckoutPublic: {
            /**
             * Created At
             * Format: date-time
             * @description Creation timestamp of the object.
             */
            created_at: string;
            /**
             * Modified At
             * @description Last modification timestamp of the object.
             */
            modified_at: string | null;
            /**
             * Id
             * Format: uuid4
             * @description The ID of the object.
             */
            id: string;
            /**
             * Custom Field Data
             * @description Key-value object storing custom field values.
             */
            custom_field_data?: {
                [key: string]: string | number | boolean | null;
            };
            /** @description Payment processor used. */
            payment_processor: components["schemas"]["PaymentProcessor"];
            /** @description Status of the checkout session. */
            status: components["schemas"]["CheckoutStatus"];
            /**
             * Client Secret
             * @description Client secret used to update and complete the checkout session from the client.
             */
            client_secret: string;
            /**
             * Url
             * @description URL where the customer can access the checkout session.
             */
            url: string;
            /**
             * Expires At
             * Format: date-time
             * @description Expiration date and time of the checkout session.
             */
            expires_at: string;
            /**
             * Success Url
             * @description URL where the customer will be redirected after a successful payment.
             */
            success_url: string;
            /**
             * Embed Origin
             * @description When checkout is embedded, represents the Origin of the page embedding the checkout. Used as a security measure to send messages only to the embedding page.
             */
            embed_origin: string | null;
            /**
             * Amount
             * @description Amount in cents, before discounts and taxes.
             */
            amount: number;
            /**
             * Discount Amount
             * @description Discount amount in cents.
             */
            discount_amount: number;
            /**
             * Net Amount
             * @description Amount in cents, after discounts but before taxes.
             */
            net_amount: number;
            /**
             * Tax Amount
             * @description Sales tax amount in cents. If `null`, it means there is no enough information yet to calculate it.
             */
            tax_amount: number | null;
            /**
             * Total Amount
             * @description Amount in cents, after discounts and taxes.
             */
            total_amount: number;
            /**
             * Currency
             * @description Currency code of the checkout session.
             */
            currency: string;
            /**
             * Product Id
             * Format: uuid4
             * @description ID of the product to checkout.
             */
            product_id: string;
            /**
             * Product Price Id
             * Format: uuid4
             * @description ID of the product price to checkout.
             */
            product_price_id: string;
            /**
             * Discount Id
             * @description ID of the discount applied to the checkout.
             */
            discount_id: string | null;
            /**
             * Allow Discount Codes
             * @description Whether to allow the customer to apply discount codes. If you apply a discount through `discount_id`, it'll still be applied, but the customer won't be able to change it.
             */
            allow_discount_codes: boolean;
            /**
             * Require Billing Address
             * @description Whether to require the customer to fill their full billing address, instead of just the country. Customers in the US will always be required to fill their full address, regardless of this setting. If you preset the billing address, this setting will be automatically set to `true`.
             */
            require_billing_address: boolean;
            /**
             * Is Discount Applicable
             * @description Whether the discount is applicable to the checkout. Typically, free and custom prices are not discountable.
             */
            is_discount_applicable: boolean;
            /**
             * Is Free Product Price
             * @description Whether the product price is free, regardless of discounts.
             */
            is_free_product_price: boolean;
            /**
             * Is Payment Required
             * @description Whether the checkout requires payment, e.g. in case of free products or discounts that cover the total amount.
             */
            is_payment_required: boolean;
            /**
             * Is Payment Setup Required
             * @description Whether the checkout requires setting up a payment method, regardless of the amount, e.g. subscriptions that have first free cycles.
             */
            is_payment_setup_required: boolean;
            /**
             * Is Payment Form Required
             * @description Whether the checkout requires a payment form, whether because of a payment or payment method setup.
             */
            is_payment_form_required: boolean;
            /** Customer Id */
            customer_id: string | null;
            /**
             * Customer Name
             * @description Name of the customer.
             */
            customer_name: string | null;
            /**
             * Customer Email
             * @description Email address of the customer.
             */
            customer_email: string | null;
            /** Customer Ip Address */
            customer_ip_address: string | null;
            customer_billing_address: components["schemas"]["Address"] | null;
            /** Customer Tax Id */
            customer_tax_id: string | null;
            /** Payment Processor Metadata */
            payment_processor_metadata: {
                [key: string]: string;
            };
            /**
             * Products
             * @description List of products available to select.
             */
            products: components["schemas"]["CheckoutProduct"][];
            /** @description Product selected to checkout. */
            product: components["schemas"]["CheckoutProduct"];
            /**
             * Product Price
             * @description Price of the selected product.
             */
            product_price: components["schemas"]["LegacyRecurringProductPrice"] | components["schemas"]["ProductPrice"];
            /** Discount */
            discount: (components["schemas"]["CheckoutDiscountFixedOnceForeverDuration"] | components["schemas"]["CheckoutDiscountFixedRepeatDuration"] | components["schemas"]["CheckoutDiscountPercentageOnceForeverDuration"] | components["schemas"]["CheckoutDiscountPercentageRepeatDuration"]) | null;
            organization: components["schemas"]["Organization"];
            /** Attached Custom Fields */
            attached_custom_fields: components["schemas"]["AttachedCustomField"][];
            /** @description Determine which billing address fields should be shown in the checkout form. */
            readonly customer_billing_address_fields: components["schemas"]["CheckoutCustomerBillingAddressFields"];
        };
        /**
         * CheckoutPublicConfirmed
         * @description Checkout session data retrieved using the client secret after confirmation.
         *
         *     It contains a customer session token to retrieve order information
         *     right after the checkout.
         */
        CheckoutPublicConfirmed: {
            /**
             * Created At
             * Format: date-time
             * @description Creation timestamp of the object.
             */
            created_at: string;
            /**
             * Modified At
             * @description Last modification timestamp of the object.
             */
            modified_at: string | null;
            /**
             * Id
             * Format: uuid4
             * @description The ID of the object.
             */
            id: string;
            /**
             * Custom Field Data
             * @description Key-value object storing custom field values.
             */
            custom_field_data?: {
                [key: string]: string | number | boolean | null;
            };
            /** @description Payment processor used. */
            payment_processor: components["schemas"]["PaymentProcessor"];
            /**
             * Status
             * @constant
             */
            status: "confirmed";
            /**
             * Client Secret
             * @description Client secret used to update and complete the checkout session from the client.
             */
            client_secret: string;
            /**
             * Url
             * @description URL where the customer can access the checkout session.
             */
            url: string;
            /**
             * Expires At
             * Format: date-time
             * @description Expiration date and time of the checkout session.
             */
            expires_at: string;
            /**
             * Success Url
             * @description URL where the customer will be redirected after a successful payment.
             */
            success_url: string;
            /**
             * Embed Origin
             * @description When checkout is embedded, represents the Origin of the page embedding the checkout. Used as a security measure to send messages only to the embedding page.
             */
            embed_origin: string | null;
            /**
             * Amount
             * @description Amount in cents, before discounts and taxes.
             */
            amount: number;
            /**
             * Discount Amount
             * @description Discount amount in cents.
             */
            discount_amount: number;
            /**
             * Net Amount
             * @description Amount in cents, after discounts but before taxes.
             */
            net_amount: number;
            /**
             * Tax Amount
             * @description Sales tax amount in cents. If `null`, it means there is no enough information yet to calculate it.
             */
            tax_amount: number | null;
            /**
             * Total Amount
             * @description Amount in cents, after discounts and taxes.
             */
            total_amount: number;
            /**
             * Currency
             * @description Currency code of the checkout session.
             */
            currency: string;
            /**
             * Product Id
             * Format: uuid4
             * @description ID of the product to checkout.
             */
            product_id: string;
            /**
             * Product Price Id
             * Format: uuid4
             * @description ID of the product price to checkout.
             */
            product_price_id: string;
            /**
             * Discount Id
             * @description ID of the discount applied to the checkout.
             */
            discount_id: string | null;
            /**
             * Allow Discount Codes
             * @description Whether to allow the customer to apply discount codes. If you apply a discount through `discount_id`, it'll still be applied, but the customer won't be able to change it.
             */
            allow_discount_codes: boolean;
            /**
             * Require Billing Address
             * @description Whether to require the customer to fill their full billing address, instead of just the country. Customers in the US will always be required to fill their full address, regardless of this setting. If you preset the billing address, this setting will be automatically set to `true`.
             */
            require_billing_address: boolean;
            /**
             * Is Discount Applicable
             * @description Whether the discount is applicable to the checkout. Typically, free and custom prices are not discountable.
             */
            is_discount_applicable: boolean;
            /**
             * Is Free Product Price
             * @description Whether the product price is free, regardless of discounts.
             */
            is_free_product_price: boolean;
            /**
             * Is Payment Required
             * @description Whether the checkout requires payment, e.g. in case of free products or discounts that cover the total amount.
             */
            is_payment_required: boolean;
            /**
             * Is Payment Setup Required
             * @description Whether the checkout requires setting up a payment method, regardless of the amount, e.g. subscriptions that have first free cycles.
             */
            is_payment_setup_required: boolean;
            /**
             * Is Payment Form Required
             * @description Whether the checkout requires a payment form, whether because of a payment or payment method setup.
             */
            is_payment_form_required: boolean;
            /** Customer Id */
            customer_id: string | null;
            /**
             * Customer Name
             * @description Name of the customer.
             */
            customer_name: string | null;
            /**
             * Customer Email
             * @description Email address of the customer.
             */
            customer_email: string | null;
            /** Customer Ip Address */
            customer_ip_address: string | null;
            customer_billing_address: components["schemas"]["Address"] | null;
            /** Customer Tax Id */
            customer_tax_id: string | null;
            /** Payment Processor Metadata */
            payment_processor_metadata: {
                [key: string]: string;
            };
            /**
             * Products
             * @description List of products available to select.
             */
            products: components["schemas"]["CheckoutProduct"][];
            /** @description Product selected to checkout. */
            product: components["schemas"]["CheckoutProduct"];
            /**
             * Product Price
             * @description Price of the selected product.
             */
            product_price: components["schemas"]["LegacyRecurringProductPrice"] | components["schemas"]["ProductPrice"];
            /** Discount */
            discount: (components["schemas"]["CheckoutDiscountFixedOnceForeverDuration"] | components["schemas"]["CheckoutDiscountFixedRepeatDuration"] | components["schemas"]["CheckoutDiscountPercentageOnceForeverDuration"] | components["schemas"]["CheckoutDiscountPercentageRepeatDuration"]) | null;
            organization: components["schemas"]["Organization"];
            /** Attached Custom Fields */
            attached_custom_fields: components["schemas"]["AttachedCustomField"][];
            /** Customer Session Token */
            customer_session_token: string;
            /** @description Determine which billing address fields should be shown in the checkout form. */
            readonly customer_billing_address_fields: components["schemas"]["CheckoutCustomerBillingAddressFields"];
        };
        /**
         * CheckoutSortProperty
         * @enum {string}
         */
        CheckoutSortProperty: "created_at" | "-created_at" | "expires_at" | "-expires_at" | "status" | "-status";
        /**
         * CheckoutStatus
         * @enum {string}
         */
        CheckoutStatus: "open" | "expired" | "confirmed" | "succeeded" | "failed";
        /**
         * CheckoutUpdate
         * @description Update an existing checkout session using an access token.
         */
        CheckoutUpdate: {
            /**
             * Custom Field Data
             * @description Key-value object storing custom field values.
             */
            custom_field_data?: {
                [key: string]: string | number | boolean | null;
            };
            /**
             * Product Id
             * @description ID of the product to checkout. Must be present in the checkout's product list.
             */
            product_id?: string | null;
            /**
             * Product Price Id
             * @deprecated
             * @description ID of the product price to checkout. Must correspond to a price present in the checkout's product list.
             */
            product_price_id?: string | null;
            /** Amount */
            amount?: number | null;
            /** Customer Name */
            customer_name?: string | null;
            /** Customer Email */
            customer_email?: string | null;
            customer_billing_address?: components["schemas"]["Address"] | null;
            /** Customer Tax Id */
            customer_tax_id?: string | null;
            /**
             * Metadata
             * @description Key-value object allowing you to store additional information.
             *
             *     The key must be a string with a maximum length of **40 characters**.
             *     The value must be either:
             *
             *     * A string with a maximum length of **500 characters**
             *     * An integer
             *     * A floating-point number
             *     * A boolean
             *
             *     You can store up to **50 key-value pairs**.
             */
            metadata?: {
                [key: string]: string | number | boolean;
            };
            /**
             * Discount Id
             * @description ID of the discount to apply to the checkout.
             */
            discount_id?: string | null;
            /**
             * Allow Discount Codes
             * @description Whether to allow the customer to apply discount codes. If you apply a discount through `discount_id`, it'll still be applied, but the customer won't be able to change it.
             */
            allow_discount_codes?: boolean | null;
            /**
             * Require Billing Address
             * @description Whether to require the customer to fill their full billing address, instead of just the country. Customers in the US will always be required to fill their full address, regardless of this setting. If you preset the billing address, this setting will be automatically set to `true`.
             */
            require_billing_address?: boolean | null;
            /** Customer Ip Address */
            customer_ip_address?: string | null;
            /**
             * Customer Metadata
             * @description Key-value object allowing you to store additional information that'll be copied to the created customer.
             *
             *     The key must be a string with a maximum length of **40 characters**.
             *     The value must be either:
             *
             *     * A string with a maximum length of **500 characters**
             *     * An integer
             *     * A floating-point number
             *     * A boolean
             *
             *     You can store up to **50 key-value pairs**.
             */
            customer_metadata?: {
                [key: string]: string | number | boolean;
            } | null;
            /**
             * Success Url
             * @description URL where the customer will be redirected after a successful payment.You can add the `checkout_id={CHECKOUT_ID}` query parameter to retrieve the checkout session id.
             */
            success_url?: string | null;
            /**
             * Embed Origin
             * @description If you plan to embed the checkout session, set this to the Origin of the embedding page. It'll allow the Polar iframe to communicate with the parent page.
             */
            embed_origin?: string | null;
        };
        /**
         * CheckoutUpdatePublic
         * @description Update an existing checkout session using the client secret.
         */
        CheckoutUpdatePublic: {
            /**
             * Custom Field Data
             * @description Key-value object storing custom field values.
             */
            custom_field_data?: {
                [key: string]: string | number | boolean | null;
            };
            /**
             * Product Id
             * @description ID of the product to checkout. Must be present in the checkout's product list.
             */
            product_id?: string | null;
            /**
             * Product Price Id
             * @deprecated
             * @description ID of the product price to checkout. Must correspond to a price present in the checkout's product list.
             */
            product_price_id?: string | null;
            /** Amount */
            amount?: number | null;
            /** Customer Name */
            customer_name?: string | null;
            /** Customer Email */
            customer_email?: string | null;
            customer_billing_address?: components["schemas"]["Address"] | null;
            /** Customer Tax Id */
            customer_tax_id?: string | null;
            /**
             * Discount Code
             * @description Discount code to apply to the checkout.
             */
            discount_code?: string | null;
        };
        /** CountAggregation */
        CountAggregation: {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            func: "count";
        };
        CustomField: components["schemas"]["CustomFieldText"] | components["schemas"]["CustomFieldNumber"] | components["schemas"]["CustomFieldDate"] | components["schemas"]["CustomFieldCheckbox"] | components["schemas"]["CustomFieldSelect"];
        /**
         * CustomFieldCheckbox
         * @description Schema for a custom field of type checkbox.
         */
        CustomFieldCheckbox: {
            /**
             * Created At
             * Format: date-time
             * @description Creation timestamp of the object.
             */
            created_at: string;
            /**
             * Modified At
             * @description Last modification timestamp of the object.
             */
            modified_at: string | null;
            /**
             * Id
             * Format: uuid4
             * @description The ID of the object.
             */
            id: string;
            /** Metadata */
            metadata: {
                [key: string]: string | number | boolean;
            };
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            type: "checkbox";
            /**
             * Slug
             * @description Identifier of the custom field. It'll be used as key when storing the value.
             */
            slug: string;
            /**
             * Name
             * @description Name of the custom field.
             */
            name: string;
            /**
             * Organization Id
             * Format: uuid4
             * @description The ID of the organization owning the custom field.
             */
            organization_id: string;
            properties: components["schemas"]["CustomFieldCheckboxProperties"];
        };
        /** CustomFieldCheckboxProperties */
        CustomFieldCheckboxProperties: {
            /** Form Label */
            form_label?: string;
            /** Form Help Text */
            form_help_text?: string;
            /** Form Placeholder */
            form_placeholder?: string;
        };
        CustomFieldCreate: components["schemas"]["CustomFieldCreateText"] | components["schemas"]["CustomFieldCreateNumber"] | components["schemas"]["CustomFieldCreateDate"] | components["schemas"]["CustomFieldCreateCheckbox"] | components["schemas"]["CustomFieldCreateSelect"];
        /**
         * CustomFieldCreateCheckbox
         * @description Schema to create a custom field of type checkbox.
         */
        CustomFieldCreateCheckbox: {
            /**
             * Metadata
             * @description Key-value object allowing you to store additional information.
             *
             *     The key must be a string with a maximum length of **40 characters**.
             *     The value must be either:
             *
             *     * A string with a maximum length of **500 characters**
             *     * An integer
             *     * A floating-point number
             *     * A boolean
             *
             *     You can store up to **50 key-value pairs**.
             */
            metadata?: {
                [key: string]: string | number | boolean;
            };
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            type: "checkbox";
            /**
             * Slug
             * @description Identifier of the custom field. It'll be used as key when storing the value. Must be unique across the organization.It can only contain ASCII letters, numbers and hyphens.
             */
            slug: string;
            /**
             * Name
             * @description Name of the custom field.
             */
            name: string;
            /**
             * Organization Id
             * @description The ID of the organization owning the custom field. **Required unless you use an organization token.**
             */
            organization_id?: string | null;
            properties: components["schemas"]["CustomFieldCheckboxProperties"];
        };
        /**
         * CustomFieldCreateDate
         * @description Schema to create a custom field of type date.
         */
        CustomFieldCreateDate: {
            /**
             * Metadata
             * @description Key-value object allowing you to store additional information.
             *
             *     The key must be a string with a maximum length of **40 characters**.
             *     The value must be either:
             *
             *     * A string with a maximum length of **500 characters**
             *     * An integer
             *     * A floating-point number
             *     * A boolean
             *
             *     You can store up to **50 key-value pairs**.
             */
            metadata?: {
                [key: string]: string | number | boolean;
            };
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            type: "date";
            /**
             * Slug
             * @description Identifier of the custom field. It'll be used as key when storing the value. Must be unique across the organization.It can only contain ASCII letters, numbers and hyphens.
             */
            slug: string;
            /**
             * Name
             * @description Name of the custom field.
             */
            name: string;
            /**
             * Organization Id
             * @description The ID of the organization owning the custom field. **Required unless you use an organization token.**
             */
            organization_id?: string | null;
            properties: components["schemas"]["CustomFieldDateProperties"];
        };
        /**
         * CustomFieldCreateNumber
         * @description Schema to create a custom field of type number.
         */
        CustomFieldCreateNumber: {
            /**
             * Metadata
             * @description Key-value object allowing you to store additional information.
             *
             *     The key must be a string with a maximum length of **40 characters**.
             *     The value must be either:
             *
             *     * A string with a maximum length of **500 characters**
             *     * An integer
             *     * A floating-point number
             *     * A boolean
             *
             *     You can store up to **50 key-value pairs**.
             */
            metadata?: {
                [key: string]: string | number | boolean;
            };
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            type: "number";
            /**
             * Slug
             * @description Identifier of the custom field. It'll be used as key when storing the value. Must be unique across the organization.It can only contain ASCII letters, numbers and hyphens.
             */
            slug: string;
            /**
             * Name
             * @description Name of the custom field.
             */
            name: string;
            /**
             * Organization Id
             * @description The ID of the organization owning the custom field. **Required unless you use an organization token.**
             */
            organization_id?: string | null;
            properties: components["schemas"]["CustomFieldNumberProperties"];
        };
        /**
         * CustomFieldCreateSelect
         * @description Schema to create a custom field of type select.
         */
        CustomFieldCreateSelect: {
            /**
             * Metadata
             * @description Key-value object allowing you to store additional information.
             *
             *     The key must be a string with a maximum length of **40 characters**.
             *     The value must be either:
             *
             *     * A string with a maximum length of **500 characters**
             *     * An integer
             *     * A floating-point number
             *     * A boolean
             *
             *     You can store up to **50 key-value pairs**.
             */
            metadata?: {
                [key: string]: string | number | boolean;
            };
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            type: "select";
            /**
             * Slug
             * @description Identifier of the custom field. It'll be used as key when storing the value. Must be unique across the organization.It can only contain ASCII letters, numbers and hyphens.
             */
            slug: string;
            /**
             * Name
             * @description Name of the custom field.
             */
            name: string;
            /**
             * Organization Id
             * @description The ID of the organization owning the custom field. **Required unless you use an organization token.**
             */
            organization_id?: string | null;
            properties: components["schemas"]["CustomFieldSelectProperties"];
        };
        /**
         * CustomFieldCreateText
         * @description Schema to create a custom field of type text.
         */
        CustomFieldCreateText: {
            /**
             * Metadata
             * @description Key-value object allowing you to store additional information.
             *
             *     The key must be a string with a maximum length of **40 characters**.
             *     The value must be either:
             *
             *     * A string with a maximum length of **500 characters**
             *     * An integer
             *     * A floating-point number
             *     * A boolean
             *
             *     You can store up to **50 key-value pairs**.
             */
            metadata?: {
                [key: string]: string | number | boolean;
            };
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            type: "text";
            /**
             * Slug
             * @description Identifier of the custom field. It'll be used as key when storing the value. Must be unique across the organization.It can only contain ASCII letters, numbers and hyphens.
             */
            slug: string;
            /**
             * Name
             * @description Name of the custom field.
             */
            name: string;
            /**
             * Organization Id
             * @description The ID of the organization owning the custom field. **Required unless you use an organization token.**
             */
            organization_id?: string | null;
            properties: components["schemas"]["CustomFieldTextProperties"];
        };
        /**
         * CustomFieldDate
         * @description Schema for a custom field of type date.
         */
        CustomFieldDate: {
            /**
             * Created At
             * Format: date-time
             * @description Creation timestamp of the object.
             */
            created_at: string;
            /**
             * Modified At
             * @description Last modification timestamp of the object.
             */
            modified_at: string | null;
            /**
             * Id
             * Format: uuid4
             * @description The ID of the object.
             */
            id: string;
            /** Metadata */
            metadata: {
                [key: string]: string | number | boolean;
            };
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            type: "date";
            /**
             * Slug
             * @description Identifier of the custom field. It'll be used as key when storing the value.
             */
            slug: string;
            /**
             * Name
             * @description Name of the custom field.
             */
            name: string;
            /**
             * Organization Id
             * Format: uuid4
             * @description The ID of the organization owning the custom field.
             */
            organization_id: string;
            properties: components["schemas"]["CustomFieldDateProperties"];
        };
        /** CustomFieldDateProperties */
        CustomFieldDateProperties: {
            /** Form Label */
            form_label?: string;
            /** Form Help Text */
            form_help_text?: string;
            /** Form Placeholder */
            form_placeholder?: string;
            /** Ge */
            ge?: number;
            /** Le */
            le?: number;
        };
        /**
         * CustomFieldNumber
         * @description Schema for a custom field of type number.
         */
        CustomFieldNumber: {
            /**
             * Created At
             * Format: date-time
             * @description Creation timestamp of the object.
             */
            created_at: string;
            /**
             * Modified At
             * @description Last modification timestamp of the object.
             */
            modified_at: string | null;
            /**
             * Id
             * Format: uuid4
             * @description The ID of the object.
             */
            id: string;
            /** Metadata */
            metadata: {
                [key: string]: string | number | boolean;
            };
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            type: "number";
            /**
             * Slug
             * @description Identifier of the custom field. It'll be used as key when storing the value.
             */
            slug: string;
            /**
             * Name
             * @description Name of the custom field.
             */
            name: string;
            /**
             * Organization Id
             * Format: uuid4
             * @description The ID of the organization owning the custom field.
             */
            organization_id: string;
            properties: components["schemas"]["CustomFieldNumberProperties"];
        };
        /** CustomFieldNumberProperties */
        CustomFieldNumberProperties: {
            /** Form Label */
            form_label?: string;
            /** Form Help Text */
            form_help_text?: string;
            /** Form Placeholder */
            form_placeholder?: string;
            /** Ge */
            ge?: number;
            /** Le */
            le?: number;
        };
        /**
         * CustomFieldSelect
         * @description Schema for a custom field of type select.
         */
        CustomFieldSelect: {
            /**
             * Created At
             * Format: date-time
             * @description Creation timestamp of the object.
             */
            created_at: string;
            /**
             * Modified At
             * @description Last modification timestamp of the object.
             */
            modified_at: string | null;
            /**
             * Id
             * Format: uuid4
             * @description The ID of the object.
             */
            id: string;
            /** Metadata */
            metadata: {
                [key: string]: string | number | boolean;
            };
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            type: "select";
            /**
             * Slug
             * @description Identifier of the custom field. It'll be used as key when storing the value.
             */
            slug: string;
            /**
             * Name
             * @description Name of the custom field.
             */
            name: string;
            /**
             * Organization Id
             * Format: uuid4
             * @description The ID of the organization owning the custom field.
             */
            organization_id: string;
            properties: components["schemas"]["CustomFieldSelectProperties"];
        };
        /** CustomFieldSelectOption */
        CustomFieldSelectOption: {
            /** Value */
            value: string;
            /** Label */
            label: string;
        };
        /** CustomFieldSelectProperties */
        CustomFieldSelectProperties: {
            /** Form Label */
            form_label?: string;
            /** Form Help Text */
            form_help_text?: string;
            /** Form Placeholder */
            form_placeholder?: string;
            /** Options */
            options: components["schemas"]["CustomFieldSelectOption"][];
        };
        /**
         * CustomFieldSortProperty
         * @enum {string}
         */
        CustomFieldSortProperty: "created_at" | "-created_at" | "slug" | "-slug" | "name" | "-name" | "type" | "-type";
        /**
         * CustomFieldText
         * @description Schema for a custom field of type text.
         */
        CustomFieldText: {
            /**
             * Created At
             * Format: date-time
             * @description Creation timestamp of the object.
             */
            created_at: string;
            /**
             * Modified At
             * @description Last modification timestamp of the object.
             */
            modified_at: string | null;
            /**
             * Id
             * Format: uuid4
             * @description The ID of the object.
             */
            id: string;
            /** Metadata */
            metadata: {
                [key: string]: string | number | boolean;
            };
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            type: "text";
            /**
             * Slug
             * @description Identifier of the custom field. It'll be used as key when storing the value.
             */
            slug: string;
            /**
             * Name
             * @description Name of the custom field.
             */
            name: string;
            /**
             * Organization Id
             * Format: uuid4
             * @description The ID of the organization owning the custom field.
             */
            organization_id: string;
            properties: components["schemas"]["CustomFieldTextProperties"];
        };
        /** CustomFieldTextProperties */
        CustomFieldTextProperties: {
            /** Form Label */
            form_label?: string;
            /** Form Help Text */
            form_help_text?: string;
            /** Form Placeholder */
            form_placeholder?: string;
            /** Textarea */
            textarea?: boolean;
            /** Min Length */
            min_length?: number;
            /** Max Length */
            max_length?: number;
        };
        /**
         * CustomFieldType
         * @enum {string}
         */
        CustomFieldType: "text" | "number" | "date" | "checkbox" | "select";
        CustomFieldUpdate: components["schemas"]["CustomFieldUpdateText"] | components["schemas"]["CustomFieldUpdateNumber"] | components["schemas"]["CustomFieldUpdateDate"] | components["schemas"]["CustomFieldUpdateCheckbox"] | components["schemas"]["CustomFieldUpdateSelect"];
        /**
         * CustomFieldUpdateCheckbox
         * @description Schema to update a custom field of type checkbox.
         */
        CustomFieldUpdateCheckbox: {
            /**
             * Metadata
             * @description Key-value object allowing you to store additional information.
             *
             *     The key must be a string with a maximum length of **40 characters**.
             *     The value must be either:
             *
             *     * A string with a maximum length of **500 characters**
             *     * An integer
             *     * A floating-point number
             *     * A boolean
             *
             *     You can store up to **50 key-value pairs**.
             */
            metadata?: {
                [key: string]: string | number | boolean;
            };
            /** Name */
            name?: string | null;
            /** Slug */
            slug?: string | null;
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            type: "checkbox";
            properties?: components["schemas"]["CustomFieldCheckboxProperties"] | null;
        };
        /**
         * CustomFieldUpdateDate
         * @description Schema to update a custom field of type date.
         */
        CustomFieldUpdateDate: {
            /**
             * Metadata
             * @description Key-value object allowing you to store additional information.
             *
             *     The key must be a string with a maximum length of **40 characters**.
             *     The value must be either:
             *
             *     * A string with a maximum length of **500 characters**
             *     * An integer
             *     * A floating-point number
             *     * A boolean
             *
             *     You can store up to **50 key-value pairs**.
             */
            metadata?: {
                [key: string]: string | number | boolean;
            };
            /** Name */
            name?: string | null;
            /** Slug */
            slug?: string | null;
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            type: "date";
            properties?: components["schemas"]["CustomFieldDateProperties"] | null;
        };
        /**
         * CustomFieldUpdateNumber
         * @description Schema to update a custom field of type number.
         */
        CustomFieldUpdateNumber: {
            /**
             * Metadata
             * @description Key-value object allowing you to store additional information.
             *
             *     The key must be a string with a maximum length of **40 characters**.
             *     The value must be either:
             *
             *     * A string with a maximum length of **500 characters**
             *     * An integer
             *     * A floating-point number
             *     * A boolean
             *
             *     You can store up to **50 key-value pairs**.
             */
            metadata?: {
                [key: string]: string | number | boolean;
            };
            /** Name */
            name?: string | null;
            /** Slug */
            slug?: string | null;
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            type: "number";
            properties?: components["schemas"]["CustomFieldNumberProperties"] | null;
        };
        /**
         * CustomFieldUpdateSelect
         * @description Schema to update a custom field of type select.
         */
        CustomFieldUpdateSelect: {
            /**
             * Metadata
             * @description Key-value object allowing you to store additional information.
             *
             *     The key must be a string with a maximum length of **40 characters**.
             *     The value must be either:
             *
             *     * A string with a maximum length of **500 characters**
             *     * An integer
             *     * A floating-point number
             *     * A boolean
             *
             *     You can store up to **50 key-value pairs**.
             */
            metadata?: {
                [key: string]: string | number | boolean;
            };
            /** Name */
            name?: string | null;
            /** Slug */
            slug?: string | null;
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            type: "select";
            properties?: components["schemas"]["CustomFieldSelectProperties"] | null;
        };
        /**
         * CustomFieldUpdateText
         * @description Schema to update a custom field of type text.
         */
        CustomFieldUpdateText: {
            /**
             * Metadata
             * @description Key-value object allowing you to store additional information.
             *
             *     The key must be a string with a maximum length of **40 characters**.
             *     The value must be either:
             *
             *     * A string with a maximum length of **500 characters**
             *     * An integer
             *     * A floating-point number
             *     * A boolean
             *
             *     You can store up to **50 key-value pairs**.
             */
            metadata?: {
                [key: string]: string | number | boolean;
            };
            /** Name */
            name?: string | null;
            /** Slug */
            slug?: string | null;
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            type: "text";
            properties?: components["schemas"]["CustomFieldTextProperties"] | null;
        };
        /**
         * Customer
         * @description A customer in an organization.
         */
        Customer: {
            /**
             * Id
             * Format: uuid4
             * @description The ID of the customer.
             */
            id: string;
            /**
             * Created At
             * Format: date-time
             * @description Creation timestamp of the object.
             */
            created_at: string;
            /**
             * Modified At
             * @description Last modification timestamp of the object.
             */
            modified_at: string | null;
            /** Metadata */
            metadata: {
                [key: string]: string | number | boolean;
            };
            /**
             * External Id
             * @description The ID of the customer in your system. This must be unique within the organization. Once set, it can't be updated.
             */
            external_id: string | null;
            /**
             * Email
             * @description The email address of the customer. This must be unique within the organization.
             */
            email: string;
            /**
             * Email Verified
             * @description Whether the customer email address is verified. The address is automatically verified when the customer accesses the customer portal using their email address.
             */
            email_verified: boolean;
            /**
             * Name
             * @description The name of the customer.
             */
            name: string | null;
            billing_address: components["schemas"]["Address"] | null;
            /** Tax Id */
            tax_id: [
                string,
                components["schemas"]["TaxIDFormat"]
            ] | null;
            /**
             * Organization Id
             * Format: uuid4
             * @description The ID of the organization owning the customer.
             */
            organization_id: string;
            /**
             * Deleted At
             * @description Timestamp for when the customer was soft deleted.
             */
            deleted_at: string | null;
            /** Avatar Url */
            readonly avatar_url: string;
        };
        CustomerBenefitGrant: components["schemas"]["CustomerBenefitGrantDiscord"] | components["schemas"]["CustomerBenefitGrantGitHubRepository"] | components["schemas"]["CustomerBenefitGrantDownloadables"] | components["schemas"]["CustomerBenefitGrantLicenseKeys"] | components["schemas"]["CustomerBenefitGrantCustom"] | components["schemas"]["CustomerBenefitGrantMeterCredit"];
        /** CustomerBenefitGrantCustom */
        CustomerBenefitGrantCustom: {
            /**
             * Created At
             * Format: date-time
             * @description Creation timestamp of the object.
             */
            created_at: string;
            /**
             * Modified At
             * @description Last modification timestamp of the object.
             */
            modified_at: string | null;
            /**
             * Id
             * Format: uuid4
             * @description The ID of the object.
             */
            id: string;
            /** Granted At */
            granted_at: string | null;
            /** Revoked At */
            revoked_at: string | null;
            /**
             * Customer Id
             * Format: uuid4
             */
            customer_id: string;
            /**
             * Benefit Id
             * Format: uuid4
             */
            benefit_id: string;
            /** Subscription Id */
            subscription_id: string | null;
            /** Order Id */
            order_id: string | null;
            /** Is Granted */
            is_granted: boolean;
            /** Is Revoked */
            is_revoked: boolean;
            customer: components["schemas"]["CustomerPortalCustomer"];
            benefit: components["schemas"]["BenefitCustomSubscriber"];
            properties: components["schemas"]["BenefitGrantCustomProperties"];
        };
        /** CustomerBenefitGrantCustomUpdate */
        CustomerBenefitGrantCustomUpdate: {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            benefit_type: "custom";
        };
        /** CustomerBenefitGrantDiscord */
        CustomerBenefitGrantDiscord: {
            /**
             * Created At
             * Format: date-time
             * @description Creation timestamp of the object.
             */
            created_at: string;
            /**
             * Modified At
             * @description Last modification timestamp of the object.
             */
            modified_at: string | null;
            /**
             * Id
             * Format: uuid4
             * @description The ID of the object.
             */
            id: string;
            /** Granted At */
            granted_at: string | null;
            /** Revoked At */
            revoked_at: string | null;
            /**
             * Customer Id
             * Format: uuid4
             */
            customer_id: string;
            /**
             * Benefit Id
             * Format: uuid4
             */
            benefit_id: string;
            /** Subscription Id */
            subscription_id: string | null;
            /** Order Id */
            order_id: string | null;
            /** Is Granted */
            is_granted: boolean;
            /** Is Revoked */
            is_revoked: boolean;
            customer: components["schemas"]["CustomerPortalCustomer"];
            benefit: components["schemas"]["BenefitDiscordSubscriber"];
            properties: components["schemas"]["BenefitGrantDiscordProperties"];
        };
        /** CustomerBenefitGrantDiscordPropertiesUpdate */
        CustomerBenefitGrantDiscordPropertiesUpdate: {
            /** Account Id */
            account_id: string;
        };
        /** CustomerBenefitGrantDiscordUpdate */
        CustomerBenefitGrantDiscordUpdate: {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            benefit_type: "discord";
            properties: components["schemas"]["CustomerBenefitGrantDiscordPropertiesUpdate"];
        };
        /** CustomerBenefitGrantDownloadables */
        CustomerBenefitGrantDownloadables: {
            /**
             * Created At
             * Format: date-time
             * @description Creation timestamp of the object.
             */
            created_at: string;
            /**
             * Modified At
             * @description Last modification timestamp of the object.
             */
            modified_at: string | null;
            /**
             * Id
             * Format: uuid4
             * @description The ID of the object.
             */
            id: string;
            /** Granted At */
            granted_at: string | null;
            /** Revoked At */
            revoked_at: string | null;
            /**
             * Customer Id
             * Format: uuid4
             */
            customer_id: string;
            /**
             * Benefit Id
             * Format: uuid4
             */
            benefit_id: string;
            /** Subscription Id */
            subscription_id: string | null;
            /** Order Id */
            order_id: string | null;
            /** Is Granted */
            is_granted: boolean;
            /** Is Revoked */
            is_revoked: boolean;
            customer: components["schemas"]["CustomerPortalCustomer"];
            benefit: components["schemas"]["BenefitDownloadablesSubscriber"];
            properties: components["schemas"]["BenefitGrantDownloadablesProperties"];
        };
        /** CustomerBenefitGrantDownloadablesUpdate */
        CustomerBenefitGrantDownloadablesUpdate: {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            benefit_type: "downloadables";
        };
        /** CustomerBenefitGrantGitHubRepository */
        CustomerBenefitGrantGitHubRepository: {
            /**
             * Created At
             * Format: date-time
             * @description Creation timestamp of the object.
             */
            created_at: string;
            /**
             * Modified At
             * @description Last modification timestamp of the object.
             */
            modified_at: string | null;
            /**
             * Id
             * Format: uuid4
             * @description The ID of the object.
             */
            id: string;
            /** Granted At */
            granted_at: string | null;
            /** Revoked At */
            revoked_at: string | null;
            /**
             * Customer Id
             * Format: uuid4
             */
            customer_id: string;
            /**
             * Benefit Id
             * Format: uuid4
             */
            benefit_id: string;
            /** Subscription Id */
            subscription_id: string | null;
            /** Order Id */
            order_id: string | null;
            /** Is Granted */
            is_granted: boolean;
            /** Is Revoked */
            is_revoked: boolean;
            customer: components["schemas"]["CustomerPortalCustomer"];
            benefit: components["schemas"]["BenefitGitHubRepositorySubscriber"];
            properties: components["schemas"]["BenefitGrantGitHubRepositoryProperties"];
        };
        /** CustomerBenefitGrantGitHubRepositoryPropertiesUpdate */
        CustomerBenefitGrantGitHubRepositoryPropertiesUpdate: {
            /** Account Id */
            account_id: string;
        };
        /** CustomerBenefitGrantGitHubRepositoryUpdate */
        CustomerBenefitGrantGitHubRepositoryUpdate: {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            benefit_type: "github_repository";
            properties: components["schemas"]["CustomerBenefitGrantGitHubRepositoryPropertiesUpdate"];
        };
        /** CustomerBenefitGrantLicenseKeys */
        CustomerBenefitGrantLicenseKeys: {
            /**
             * Created At
             * Format: date-time
             * @description Creation timestamp of the object.
             */
            created_at: string;
            /**
             * Modified At
             * @description Last modification timestamp of the object.
             */
            modified_at: string | null;
            /**
             * Id
             * Format: uuid4
             * @description The ID of the object.
             */
            id: string;
            /** Granted At */
            granted_at: string | null;
            /** Revoked At */
            revoked_at: string | null;
            /**
             * Customer Id
             * Format: uuid4
             */
            customer_id: string;
            /**
             * Benefit Id
             * Format: uuid4
             */
            benefit_id: string;
            /** Subscription Id */
            subscription_id: string | null;
            /** Order Id */
            order_id: string | null;
            /** Is Granted */
            is_granted: boolean;
            /** Is Revoked */
            is_revoked: boolean;
            customer: components["schemas"]["CustomerPortalCustomer"];
            benefit: components["schemas"]["BenefitLicenseKeysSubscriber"];
            properties: components["schemas"]["BenefitGrantLicenseKeysProperties"];
        };
        /** CustomerBenefitGrantLicenseKeysUpdate */
        CustomerBenefitGrantLicenseKeysUpdate: {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            benefit_type: "license_keys";
        };
        /** CustomerBenefitGrantMeterCredit */
        CustomerBenefitGrantMeterCredit: {
            /**
             * Created At
             * Format: date-time
             * @description Creation timestamp of the object.
             */
            created_at: string;
            /**
             * Modified At
             * @description Last modification timestamp of the object.
             */
            modified_at: string | null;
            /**
             * Id
             * Format: uuid4
             * @description The ID of the object.
             */
            id: string;
            /** Granted At */
            granted_at: string | null;
            /** Revoked At */
            revoked_at: string | null;
            /**
             * Customer Id
             * Format: uuid4
             */
            customer_id: string;
            /**
             * Benefit Id
             * Format: uuid4
             */
            benefit_id: string;
            /** Subscription Id */
            subscription_id: string | null;
            /** Order Id */
            order_id: string | null;
            /** Is Granted */
            is_granted: boolean;
            /** Is Revoked */
            is_revoked: boolean;
            customer: components["schemas"]["CustomerPortalCustomer"];
            benefit: components["schemas"]["BenefitMeterCreditSubscriber"];
            properties: components["schemas"]["BenefitGrantMeterCreditProperties"];
        };
        /** CustomerBenefitGrantMeterCreditUpdate */
        CustomerBenefitGrantMeterCreditUpdate: {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            benefit_type: "meter_credit";
        };
        /**
         * CustomerBenefitGrantSortProperty
         * @enum {string}
         */
        CustomerBenefitGrantSortProperty: "granted_at" | "-granted_at" | "type" | "-type" | "organization" | "-organization";
        CustomerBenefitGrantUpdate: components["schemas"]["CustomerBenefitGrantDiscordUpdate"] | components["schemas"]["CustomerBenefitGrantGitHubRepositoryUpdate"] | components["schemas"]["CustomerBenefitGrantDownloadablesUpdate"] | components["schemas"]["CustomerBenefitGrantLicenseKeysUpdate"] | components["schemas"]["CustomerBenefitGrantCustomUpdate"] | components["schemas"]["CustomerBenefitGrantMeterCreditUpdate"];
        /**
         * CustomerCancellationReason
         * @enum {string}
         */
        CustomerCancellationReason: "customer_service" | "low_quality" | "missing_features" | "switched_service" | "too_complex" | "too_expensive" | "unused" | "other";
        /** CustomerCreate */
        CustomerCreate: {
            /**
             * Metadata
             * @description Key-value object allowing you to store additional information.
             *
             *     The key must be a string with a maximum length of **40 characters**.
             *     The value must be either:
             *
             *     * A string with a maximum length of **500 characters**
             *     * An integer
             *     * A floating-point number
             *     * A boolean
             *
             *     You can store up to **50 key-value pairs**.
             */
            metadata?: {
                [key: string]: string | number | boolean;
            };
            /**
             * External Id
             * @description The ID of the customer in your system. This must be unique within the organization. Once set, it can't be updated.
             */
            external_id?: string | null;
            /**
             * Email
             * Format: email
             * @description The email address of the customer. This must be unique within the organization.
             */
            email: string;
            /**
             * Name
             * @description The name of the customer.
             */
            name?: string | null;
            billing_address?: components["schemas"]["Address"] | null;
            /** Tax Id */
            tax_id?: [
                string,
                components["schemas"]["TaxIDFormat"]
            ] | null;
            /**
             * Organization Id
             * @description The ID of the organization owning the customer. **Required unless you use an organization token.**
             */
            organization_id?: string | null;
        };
        /** CustomerCustomerMeter */
        CustomerCustomerMeter: {
            /**
             * Id
             * Format: uuid4
             * @description The ID of the object.
             */
            id: string;
            /**
             * Created At
             * Format: date-time
             * @description Creation timestamp of the object.
             */
            created_at: string;
            /**
             * Modified At
             * @description Last modification timestamp of the object.
             */
            modified_at: string | null;
            /**
             * Customer Id
             * Format: uuid4
             * @description The ID of the customer.
             */
            customer_id: string;
            /**
             * Meter Id
             * Format: uuid4
             * @description The ID of the meter.
             */
            meter_id: string;
            /**
             * Consumed Units
             * @description The number of consumed units.
             */
            consumed_units: number;
            /**
             * Credited Units
             * @description The number of credited units.
             */
            credited_units: number;
            /**
             * Balance
             * @description The balance of the meter, i.e. the difference between credited and consumed units.
             */
            balance: number;
            meter: components["schemas"]["CustomerCustomerMeterMeter"];
        };
        /** CustomerCustomerMeterMeter */
        CustomerCustomerMeterMeter: {
            /**
             * Created At
             * Format: date-time
             * @description Creation timestamp of the object.
             */
            created_at: string;
            /**
             * Modified At
             * @description Last modification timestamp of the object.
             */
            modified_at: string | null;
            /**
             * Id
             * Format: uuid4
             * @description The ID of the object.
             */
            id: string;
            /**
             * Name
             * @description The name of the meter. Will be shown on customer's invoices and usage.
             */
            name: string;
        };
        /**
         * CustomerCustomerMeterSortProperty
         * @enum {string}
         */
        CustomerCustomerMeterSortProperty: "created_at" | "-created_at" | "modified_at" | "-modified_at" | "meter_id" | "-meter_id" | "meter_name" | "-meter_name" | "consumed_units" | "-consumed_units" | "credited_units" | "-credited_units" | "balance" | "-balance";
        /**
         * CustomerMeter
         * @description An active customer meter, with current consumed and credited units.
         */
        CustomerMeter: {
            /**
             * Id
             * Format: uuid4
             * @description The ID of the object.
             */
            id: string;
            /**
             * Created At
             * Format: date-time
             * @description Creation timestamp of the object.
             */
            created_at: string;
            /**
             * Modified At
             * @description Last modification timestamp of the object.
             */
            modified_at: string | null;
            /**
             * Customer Id
             * Format: uuid4
             * @description The ID of the customer.
             */
            customer_id: string;
            /**
             * Meter Id
             * Format: uuid4
             * @description The ID of the meter.
             */
            meter_id: string;
            /**
             * Consumed Units
             * @description The number of consumed units.
             */
            consumed_units: number;
            /**
             * Credited Units
             * @description The number of credited units.
             */
            credited_units: number;
            /**
             * Balance
             * @description The balance of the meter, i.e. the difference between credited and consumed units.
             */
            balance: number;
            /** @description The customer associated with this meter. */
            customer: components["schemas"]["Customer"];
            /** @description The meter associated with this customer. */
            meter: components["schemas"]["Meter"];
        };
        /**
         * CustomerMeterSortProperty
         * @enum {string}
         */
        CustomerMeterSortProperty: "created_at" | "-created_at" | "modified_at" | "-modified_at" | "customer_id" | "-customer_id" | "customer_name" | "-customer_name" | "meter_id" | "-meter_id" | "meter_name" | "-meter_name" | "consumed_units" | "-consumed_units" | "credited_units" | "-credited_units" | "balance" | "-balance";
        /**
         * CustomerOAuthPlatform
         * @enum {string}
         */
        CustomerOAuthPlatform: "github" | "discord";
        /** CustomerOrder */
        CustomerOrder: {
            /**
             * Id
             * Format: uuid4
             * @description The ID of the object.
             */
            id: string;
            /**
             * Created At
             * Format: date-time
             * @description Creation timestamp of the object.
             */
            created_at: string;
            /**
             * Modified At
             * @description Last modification timestamp of the object.
             */
            modified_at: string | null;
            status: components["schemas"]["OrderStatus"];
            /**
             * Paid
             * @description Whether the order has been paid for.
             */
            paid: boolean;
            /**
             * Subtotal Amount
             * @description Amount in cents, before discounts and taxes.
             */
            subtotal_amount: number;
            /**
             * Discount Amount
             * @description Discount amount in cents.
             */
            discount_amount: number;
            /**
             * Net Amount
             * @description Amount in cents, after discounts but before taxes.
             */
            net_amount: number;
            /**
             * Amount
             * @deprecated
             * @description Amount in cents, after discounts but before taxes.
             */
            amount: number;
            /**
             * Tax Amount
             * @description Sales tax amount in cents.
             */
            tax_amount: number;
            /**
             * Total Amount
             * @description Amount in cents, after discounts and taxes.
             */
            total_amount: number;
            /**
             * Refunded Amount
             * @description Amount refunded in cents.
             */
            refunded_amount: number;
            /**
             * Refunded Tax Amount
             * @description Sales tax refunded in cents.
             */
            refunded_tax_amount: number;
            /** Currency */
            currency: string;
            billing_reason: components["schemas"]["OrderBillingReason"];
            billing_address: components["schemas"]["Address"] | null;
            /**
             * Customer Id
             * Format: uuid4
             */
            customer_id: string;
            /**
             * Product Id
             * Format: uuid4
             */
            product_id: string;
            /** Discount Id */
            discount_id: string | null;
            /** Subscription Id */
            subscription_id: string | null;
            /** Checkout Id */
            checkout_id: string | null;
            /**
             * User Id
             * Format: uuid4
             * @deprecated
             */
            user_id: string;
            product: components["schemas"]["CustomerOrderProduct"];
            subscription: components["schemas"]["CustomerOrderSubscription"] | null;
            /**
             * Items
             * @description Line items composing the order.
             */
            items: components["schemas"]["OrderItemSchema"][];
        };
        /**
         * CustomerOrderInvoice
         * @description Order's invoice data.
         */
        CustomerOrderInvoice: {
            /**
             * Url
             * @description The URL to the invoice.
             */
            url: string;
        };
        /** CustomerOrderProduct */
        CustomerOrderProduct: {
            /**
             * Created At
             * Format: date-time
             * @description Creation timestamp of the object.
             */
            created_at: string;
            /**
             * Modified At
             * @description Last modification timestamp of the object.
             */
            modified_at: string | null;
            /**
             * Id
             * Format: uuid4
             * @description The ID of the product.
             */
            id: string;
            /**
             * Name
             * @description The name of the product.
             */
            name: string;
            /**
             * Description
             * @description The description of the product.
             */
            description: string | null;
            /** @description The recurring interval of the product. If `None`, the product is a one-time purchase. */
            recurring_interval: components["schemas"]["SubscriptionRecurringInterval"] | null;
            /**
             * Is Recurring
             * @description Whether the product is a subscription.
             */
            is_recurring: boolean;
            /**
             * Is Archived
             * @description Whether the product is archived and no longer available.
             */
            is_archived: boolean;
            /**
             * Organization Id
             * Format: uuid4
             * @description The ID of the organization owning the product.
             */
            organization_id: string;
            /**
             * Prices
             * @description List of prices for this product.
             */
            prices: (components["schemas"]["LegacyRecurringProductPrice"] | components["schemas"]["ProductPrice"])[];
            /**
             * BenefitPublic
             * @description List of benefits granted by the product.
             */
            benefits: components["schemas"]["BenefitPublic"][];
            /**
             * Medias
             * @description List of medias associated to the product.
             */
            medias: components["schemas"]["ProductMediaFileRead"][];
            organization: components["schemas"]["Organization"];
        };
        /**
         * CustomerOrderSortProperty
         * @enum {string}
         */
        CustomerOrderSortProperty: "created_at" | "-created_at" | "amount" | "-amount" | "net_amount" | "-net_amount" | "product" | "-product" | "subscription" | "-subscription";
        /** CustomerOrderSubscription */
        CustomerOrderSubscription: {
            /**
             * Created At
             * Format: date-time
             * @description Creation timestamp of the object.
             */
            created_at: string;
            /**
             * Modified At
             * @description Last modification timestamp of the object.
             */
            modified_at: string | null;
            /**
             * Id
             * Format: uuid4
             * @description The ID of the object.
             */
            id: string;
            /**
             * Amount
             * @description The amount of the subscription.
             */
            amount: number;
            /**
             * Currency
             * @description The currency of the subscription.
             */
            currency: string;
            /** @description The interval at which the subscription recurs. */
            recurring_interval: components["schemas"]["SubscriptionRecurringInterval"];
            /** @description The status of the subscription. */
            status: components["schemas"]["SubscriptionStatus"];
            /**
             * Current Period Start
             * Format: date-time
             * @description The start timestamp of the current billing period.
             */
            current_period_start: string;
            /**
             * Current Period End
             * @description The end timestamp of the current billing period.
             */
            current_period_end: string | null;
            /**
             * Cancel At Period End
             * @description Whether the subscription will be canceled at the end of the current period.
             */
            cancel_at_period_end: boolean;
            /**
             * Canceled At
             * @description The timestamp when the subscription was canceled. The subscription might still be active if `cancel_at_period_end` is `true`.
             */
            canceled_at: string | null;
            /**
             * Started At
             * @description The timestamp when the subscription started.
             */
            started_at: string | null;
            /**
             * Ends At
             * @description The timestamp when the subscription will end.
             */
            ends_at: string | null;
            /**
             * Ended At
             * @description The timestamp when the subscription ended.
             */
            ended_at: string | null;
            /**
             * Customer Id
             * Format: uuid4
             * @description The ID of the subscribed customer.
             */
            customer_id: string;
            /**
             * Product Id
             * Format: uuid4
             * @description The ID of the subscribed product.
             */
            product_id: string;
            /**
             * Discount Id
             * @description The ID of the applied discount, if any.
             */
            discount_id: string | null;
            /** Checkout Id */
            checkout_id: string | null;
            customer_cancellation_reason: components["schemas"]["CustomerCancellationReason"] | null;
            /** Customer Cancellation Comment */
            customer_cancellation_comment: string | null;
        };
        /**
         * CustomerOrganization
         * @description Schema of an organization and related data for customer portal.
         */
        CustomerOrganization: {
            organization: components["schemas"]["Organization"];
            /** Products */
            products: components["schemas"]["CustomerProduct"][];
        };
        /** CustomerPaymentMethodCreate */
        CustomerPaymentMethodCreate: {
            /** Confirmation Token Id */
            confirmation_token_id: string;
            /** Set Default */
            set_default: boolean;
            /** Return Url */
            return_url: string;
        };
        /** CustomerPortalCustomer */
        CustomerPortalCustomer: {
            /**
             * Created At
             * Format: date-time
             * @description Creation timestamp of the object.
             */
            created_at: string;
            /**
             * Modified At
             * @description Last modification timestamp of the object.
             */
            modified_at: string | null;
            /**
             * Id
             * Format: uuid4
             * @description The ID of the object.
             */
            id: string;
            /** Email */
            email: string;
            /** Email Verified */
            email_verified: boolean;
            /** Name */
            name: string | null;
            billing_address: components["schemas"]["Address"] | null;
            /** Tax Id */
            tax_id: [
                string,
                components["schemas"]["TaxIDFormat"]
            ] | null;
            /** Oauth Accounts */
            oauth_accounts: {
                [key: string]: components["schemas"]["CustomerPortalOAuthAccount"];
            };
        };
        /** CustomerPortalCustomerUpdate */
        CustomerPortalCustomerUpdate: {
            /** Email */
            email?: string | null;
            /** Name */
            name?: string | null;
            billing_address?: components["schemas"]["Address"] | null;
            /** Tax Id */
            tax_id?: string | null;
        };
        /** CustomerPortalOAuthAccount */
        CustomerPortalOAuthAccount: {
            /** Account Id */
            account_id: string;
            /** Account Username */
            account_username: string | null;
        };
        /**
         * CustomerProduct
         * @description Schema of a product for customer portal.
         */
        CustomerProduct: {
            /**
             * Created At
             * Format: date-time
             * @description Creation timestamp of the object.
             */
            created_at: string;
            /**
             * Modified At
             * @description Last modification timestamp of the object.
             */
            modified_at: string | null;
            /**
             * Id
             * Format: uuid4
             * @description The ID of the product.
             */
            id: string;
            /**
             * Name
             * @description The name of the product.
             */
            name: string;
            /**
             * Description
             * @description The description of the product.
             */
            description: string | null;
            /** @description The recurring interval of the product. If `None`, the product is a one-time purchase. */
            recurring_interval: components["schemas"]["SubscriptionRecurringInterval"] | null;
            /**
             * Is Recurring
             * @description Whether the product is a subscription.
             */
            is_recurring: boolean;
            /**
             * Is Archived
             * @description Whether the product is archived and no longer available.
             */
            is_archived: boolean;
            /**
             * Organization Id
             * Format: uuid4
             * @description The ID of the organization owning the product.
             */
            organization_id: string;
            /**
             * Prices
             * @description List of available prices for this product.
             */
            prices: (components["schemas"]["LegacyRecurringProductPrice"] | components["schemas"]["ProductPrice"])[];
            /**
             * BenefitPublic
             * @description The benefits granted by the product.
             */
            benefits: components["schemas"]["BenefitPublic"][];
            /**
             * Medias
             * @description The medias associated to the product.
             */
            medias: components["schemas"]["ProductMediaFileRead"][];
        };
        /**
         * CustomerSession
         * @description A customer session that can be used to authenticate as a customer.
         */
        CustomerSession: {
            /**
             * Created At
             * Format: date-time
             * @description Creation timestamp of the object.
             */
            created_at: string;
            /**
             * Modified At
             * @description Last modification timestamp of the object.
             */
            modified_at: string | null;
            /**
             * Id
             * Format: uuid4
             * @description The ID of the object.
             */
            id: string;
            /** Token */
            token: string;
            /**
             * Expires At
             * Format: date-time
             */
            expires_at: string;
            /** Customer Portal Url */
            customer_portal_url: string;
            /**
             * Customer Id
             * Format: uuid4
             */
            customer_id: string;
            customer: components["schemas"]["Customer"];
        };
        /** CustomerSessionCodeAuthenticateRequest */
        CustomerSessionCodeAuthenticateRequest: {
            /** Code */
            code: string;
        };
        /** CustomerSessionCodeAuthenticateResponse */
        CustomerSessionCodeAuthenticateResponse: {
            /** Token */
            token: string;
        };
        /** CustomerSessionCodeRequest */
        CustomerSessionCodeRequest: {
            /**
             * Email
             * Format: email
             */
            email: string;
            /**
             * Organization Id
             * Format: uuid4
             */
            organization_id: string;
        };
        /**
         * CustomerSessionCustomerExternalIDCreate
         * @description Schema for creating a customer session using an external customer ID.
         */
        CustomerSessionCustomerExternalIDCreate: {
            /**
             * Customer External Id
             * @description External ID of the customer to create a session for.
             */
            customer_external_id: string;
        };
        /**
         * CustomerSessionCustomerIDCreate
         * @description Schema for creating a customer session using a customer ID.
         */
        CustomerSessionCustomerIDCreate: {
            /**
             * Customer Id
             * Format: uuid4
             * @description ID of the customer to create a session for.
             */
            customer_id: string;
        };
        /**
         * CustomerSortProperty
         * @enum {string}
         */
        CustomerSortProperty: "created_at" | "-created_at" | "email" | "-email" | "name" | "-name";
        /**
         * CustomerState
         * @description A customer along with additional state information:
         *
         *     * Active subscriptions
         *     * Granted benefits
         *     * Active meters
         */
        CustomerState: {
            /**
             * Id
             * Format: uuid4
             * @description The ID of the customer.
             */
            id: string;
            /**
             * Created At
             * Format: date-time
             * @description Creation timestamp of the object.
             */
            created_at: string;
            /**
             * Modified At
             * @description Last modification timestamp of the object.
             */
            modified_at: string | null;
            /** Metadata */
            metadata: {
                [key: string]: string | number | boolean;
            };
            /**
             * External Id
             * @description The ID of the customer in your system. This must be unique within the organization. Once set, it can't be updated.
             */
            external_id: string | null;
            /**
             * Email
             * @description The email address of the customer. This must be unique within the organization.
             */
            email: string;
            /**
             * Email Verified
             * @description Whether the customer email address is verified. The address is automatically verified when the customer accesses the customer portal using their email address.
             */
            email_verified: boolean;
            /**
             * Name
             * @description The name of the customer.
             */
            name: string | null;
            billing_address: components["schemas"]["Address"] | null;
            /** Tax Id */
            tax_id: [
                string,
                components["schemas"]["TaxIDFormat"]
            ] | null;
            /**
             * Organization Id
             * Format: uuid4
             * @description The ID of the organization owning the customer.
             */
            organization_id: string;
            /**
             * Deleted At
             * @description Timestamp for when the customer was soft deleted.
             */
            deleted_at: string | null;
            /**
             * Active Subscriptions
             * @description The customer's active subscriptions.
             */
            active_subscriptions: components["schemas"]["CustomerStateSubscription"][];
            /**
             * Granted Benefits
             * @description The customer's active benefit grants.
             */
            granted_benefits: components["schemas"]["CustomerStateBenefitGrant"][];
            /**
             * Active Meters
             * @description The customer's active meters.
             */
            active_meters: components["schemas"]["CustomerStateMeter"][];
            /** Avatar Url */
            readonly avatar_url: string;
        };
        /**
         * CustomerStateBenefitGrant
         * @description An active benefit grant for a customer.
         */
        CustomerStateBenefitGrant: {
            /**
             * Id
             * Format: uuid4
             * @description The ID of the grant.
             */
            id: string;
            /**
             * Created At
             * Format: date-time
             * @description Creation timestamp of the object.
             */
            created_at: string;
            /**
             * Modified At
             * @description Last modification timestamp of the object.
             */
            modified_at: string | null;
            /**
             * Granted At
             * Format: date-time
             * @description The timestamp when the benefit was granted.
             */
            granted_at: string;
            /**
             * Benefit Id
             * Format: uuid4
             * @description The ID of the benefit concerned by this grant.
             */
            benefit_id: string;
            /** @description The type of the benefit concerned by this grant. */
            benefit_type: components["schemas"]["BenefitType"];
            /** Properties */
            properties: components["schemas"]["BenefitGrantDiscordProperties"] | components["schemas"]["BenefitGrantGitHubRepositoryProperties"] | components["schemas"]["BenefitGrantDownloadablesProperties"] | components["schemas"]["BenefitGrantLicenseKeysProperties"] | components["schemas"]["BenefitGrantCustomProperties"];
        };
        /**
         * CustomerStateMeter
         * @description An active meter for a customer, with latest consumed and credited units.
         */
        CustomerStateMeter: {
            /**
             * Created At
             * Format: date-time
             * @description Creation timestamp of the object.
             */
            created_at: string;
            /**
             * Modified At
             * @description Last modification timestamp of the object.
             */
            modified_at: string | null;
            /**
             * Meter Id
             * Format: uuid4
             * @description The ID of the meter.
             */
            meter_id: string;
            /**
             * Consumed Units
             * @description The number of consumed units.
             */
            consumed_units: number;
            /**
             * Credited Units
             * @description The number of credited units.
             */
            credited_units: number;
            /**
             * Balance
             * @description The balance of the meter, i.e. the difference between credited and consumed units.
             */
            balance: number;
        };
        /**
         * CustomerStateSubscription
         * @description An active customer subscription.
         */
        CustomerStateSubscription: {
            /**
             * Id
             * Format: uuid4
             * @description The ID of the subscription.
             */
            id: string;
            /**
             * Created At
             * Format: date-time
             * @description Creation timestamp of the object.
             */
            created_at: string;
            /**
             * Modified At
             * @description Last modification timestamp of the object.
             */
            modified_at: string | null;
            /**
             * Custom Field Data
             * @description Key-value object storing custom field values.
             */
            custom_field_data?: {
                [key: string]: string | number | boolean | null;
            };
            /** Metadata */
            metadata: {
                [key: string]: string | number | boolean;
            };
            /**
             * Status
             * @constant
             */
            status: "active";
            /**
             * Amount
             * @description The amount of the subscription.
             */
            amount: number;
            /**
             * Currency
             * @description The currency of the subscription.
             */
            currency: string;
            /** @description The interval at which the subscription recurs. */
            recurring_interval: components["schemas"]["SubscriptionRecurringInterval"];
            /**
             * Current Period Start
             * Format: date-time
             * @description The start timestamp of the current billing period.
             */
            current_period_start: string;
            /**
             * Current Period End
             * @description The end timestamp of the current billing period.
             */
            current_period_end: string | null;
            /**
             * Cancel At Period End
             * @description Whether the subscription will be canceled at the end of the current period.
             */
            cancel_at_period_end: boolean;
            /**
             * Canceled At
             * @description The timestamp when the subscription was canceled. The subscription might still be active if `cancel_at_period_end` is `true`.
             */
            canceled_at: string | null;
            /**
             * Started At
             * @description The timestamp when the subscription started.
             */
            started_at: string | null;
            /**
             * Ends At
             * @description The timestamp when the subscription will end.
             */
            ends_at: string | null;
            /**
             * Product Id
             * Format: uuid4
             * @description The ID of the subscribed product.
             */
            product_id: string;
            /**
             * Discount Id
             * @description The ID of the applied discount, if any.
             */
            discount_id: string | null;
            /**
             * Meters
             * @description List of meters associated with the subscription.
             */
            meters: components["schemas"]["CustomerStateSubscriptionMeter"][];
        };
        /**
         * CustomerStateSubscriptionMeter
         * @description Current consumption and spending for a subscription meter.
         */
        CustomerStateSubscriptionMeter: {
            /**
             * Created At
             * Format: date-time
             * @description Creation timestamp of the object.
             */
            created_at: string;
            /**
             * Modified At
             * @description Last modification timestamp of the object.
             */
            modified_at: string | null;
            /**
             * Id
             * Format: uuid4
             * @description The ID of the object.
             */
            id: string;
            /**
             * Consumed Units
             * @description The number of consumed units so far in this billing period.
             */
            consumed_units: number;
            /**
             * Credited Units
             * @description The number of credited units so far in this billing period.
             */
            credited_units: number;
            /**
             * Amount
             * @description The amount due in cents so far in this billing period.
             */
            amount: number;
            /**
             * Meter Id
             * Format: uuid4
             * @description The ID of the meter.
             */
            meter_id: string;
        };
        /** CustomerSubscription */
        CustomerSubscription: {
            /**
             * Created At
             * Format: date-time
             * @description Creation timestamp of the object.
             */
            created_at: string;
            /**
             * Modified At
             * @description Last modification timestamp of the object.
             */
            modified_at: string | null;
            /**
             * Id
             * Format: uuid4
             * @description The ID of the object.
             */
            id: string;
            /**
             * Amount
             * @description The amount of the subscription.
             */
            amount: number;
            /**
             * Currency
             * @description The currency of the subscription.
             */
            currency: string;
            /** @description The interval at which the subscription recurs. */
            recurring_interval: components["schemas"]["SubscriptionRecurringInterval"];
            /** @description The status of the subscription. */
            status: components["schemas"]["SubscriptionStatus"];
            /**
             * Current Period Start
             * Format: date-time
             * @description The start timestamp of the current billing period.
             */
            current_period_start: string;
            /**
             * Current Period End
             * @description The end timestamp of the current billing period.
             */
            current_period_end: string | null;
            /**
             * Cancel At Period End
             * @description Whether the subscription will be canceled at the end of the current period.
             */
            cancel_at_period_end: boolean;
            /**
             * Canceled At
             * @description The timestamp when the subscription was canceled. The subscription might still be active if `cancel_at_period_end` is `true`.
             */
            canceled_at: string | null;
            /**
             * Started At
             * @description The timestamp when the subscription started.
             */
            started_at: string | null;
            /**
             * Ends At
             * @description The timestamp when the subscription will end.
             */
            ends_at: string | null;
            /**
             * Ended At
             * @description The timestamp when the subscription ended.
             */
            ended_at: string | null;
            /**
             * Customer Id
             * Format: uuid4
             * @description The ID of the subscribed customer.
             */
            customer_id: string;
            /**
             * Product Id
             * Format: uuid4
             * @description The ID of the subscribed product.
             */
            product_id: string;
            /**
             * Discount Id
             * @description The ID of the applied discount, if any.
             */
            discount_id: string | null;
            /** Checkout Id */
            checkout_id: string | null;
            customer_cancellation_reason: components["schemas"]["CustomerCancellationReason"] | null;
            /** Customer Cancellation Comment */
            customer_cancellation_comment: string | null;
            product: components["schemas"]["CustomerSubscriptionProduct"];
            /**
             * Prices
             * @description List of enabled prices for the subscription.
             */
            prices: (components["schemas"]["LegacyRecurringProductPrice"] | components["schemas"]["ProductPrice"])[];
            /**
             * Meters
             * @description List of meters associated with the subscription.
             */
            meters: components["schemas"]["CustomerSubscriptionMeter"][];
        };
        /** CustomerSubscriptionCancel */
        CustomerSubscriptionCancel: {
            /**
             * Cancel At Period End
             * @description Cancel an active subscription once the current period ends.
             *
             *     Or uncancel a subscription currently set to be revoked at period end.
             */
            cancel_at_period_end?: boolean | null;
            /** @description Customers reason for cancellation.
             *
             *     * `too_expensive`: Too expensive for the customer.
             *     * `missing_features`: Customer is missing certain features.
             *     * `switched_service`: Customer switched to another service.
             *     * `unused`: Customer is not using it enough.
             *     * `customer_service`: Customer is not satisfied with the customer service.
             *     * `low_quality`: Customer is unhappy with the quality.
             *     * `too_complex`: Customer considers the service too complicated.
             *     * `other`: Other reason(s). */
            cancellation_reason?: components["schemas"]["CustomerCancellationReason"] | null;
            /**
             * Cancellation Comment
             * @description Customer feedback and why they decided to cancel.
             */
            cancellation_comment?: string | null;
        };
        /** CustomerSubscriptionMeter */
        CustomerSubscriptionMeter: {
            /**
             * Created At
             * Format: date-time
             * @description Creation timestamp of the object.
             */
            created_at: string;
            /**
             * Modified At
             * @description Last modification timestamp of the object.
             */
            modified_at: string | null;
            /**
             * Id
             * Format: uuid4
             * @description The ID of the object.
             */
            id: string;
            /**
             * Consumed Units
             * @description The number of consumed units so far in this billing period.
             */
            consumed_units: number;
            /**
             * Credited Units
             * @description The number of credited units so far in this billing period.
             */
            credited_units: number;
            /**
             * Amount
             * @description The amount due in cents so far in this billing period.
             */
            amount: number;
            /**
             * Meter Id
             * Format: uuid4
             * @description The ID of the meter.
             */
            meter_id: string;
            meter: components["schemas"]["CustomerSubscriptionMeterMeter"];
        };
        /** CustomerSubscriptionMeterMeter */
        CustomerSubscriptionMeterMeter: {
            /**
             * Created At
             * Format: date-time
             * @description Creation timestamp of the object.
             */
            created_at: string;
            /**
             * Modified At
             * @description Last modification timestamp of the object.
             */
            modified_at: string | null;
            /**
             * Id
             * Format: uuid4
             * @description The ID of the object.
             */
            id: string;
            /**
             * Name
             * @description The name of the meter. Will be shown on customer's invoices and usage.
             */
            name: string;
        };
        /** CustomerSubscriptionProduct */
        CustomerSubscriptionProduct: {
            /**
             * Created At
             * Format: date-time
             * @description Creation timestamp of the object.
             */
            created_at: string;
            /**
             * Modified At
             * @description Last modification timestamp of the object.
             */
            modified_at: string | null;
            /**
             * Id
             * Format: uuid4
             * @description The ID of the product.
             */
            id: string;
            /**
             * Name
             * @description The name of the product.
             */
            name: string;
            /**
             * Description
             * @description The description of the product.
             */
            description: string | null;
            /** @description The recurring interval of the product. If `None`, the product is a one-time purchase. */
            recurring_interval: components["schemas"]["SubscriptionRecurringInterval"] | null;
            /**
             * Is Recurring
             * @description Whether the product is a subscription.
             */
            is_recurring: boolean;
            /**
             * Is Archived
             * @description Whether the product is archived and no longer available.
             */
            is_archived: boolean;
            /**
             * Organization Id
             * Format: uuid4
             * @description The ID of the organization owning the product.
             */
            organization_id: string;
            /**
             * Prices
             * @description List of prices for this product.
             */
            prices: (components["schemas"]["LegacyRecurringProductPrice"] | components["schemas"]["ProductPrice"])[];
            /**
             * BenefitPublic
             * @description List of benefits granted by the product.
             */
            benefits: components["schemas"]["BenefitPublic"][];
            /**
             * Medias
             * @description List of medias associated to the product.
             */
            medias: components["schemas"]["ProductMediaFileRead"][];
            organization: components["schemas"]["Organization"];
        };
        /**
         * CustomerSubscriptionSortProperty
         * @enum {string}
         */
        CustomerSubscriptionSortProperty: "started_at" | "-started_at" | "amount" | "-amount" | "status" | "-status" | "organization" | "-organization" | "product" | "-product";
        CustomerSubscriptionUpdate: components["schemas"]["CustomerSubscriptionUpdateProduct"] | components["schemas"]["CustomerSubscriptionCancel"];
        /** CustomerSubscriptionUpdateProduct */
        CustomerSubscriptionUpdateProduct: {
            /**
             * Product Id
             * Format: uuid4
             * @description Update subscription to another product.
             */
            product_id: string;
        };
        /** CustomerUpdate */
        CustomerUpdate: {
            /**
             * Metadata
             * @description Key-value object allowing you to store additional information.
             *
             *     The key must be a string with a maximum length of **40 characters**.
             *     The value must be either:
             *
             *     * A string with a maximum length of **500 characters**
             *     * An integer
             *     * A floating-point number
             *     * A boolean
             *
             *     You can store up to **50 key-value pairs**.
             */
            metadata?: {
                [key: string]: string | number | boolean;
            };
            /**
             * Email
             * @description The email address of the customer. This must be unique within the organization.
             */
            email?: string | null;
            /**
             * Name
             * @description The name of the customer.
             */
            name?: string | null;
            billing_address?: components["schemas"]["Address"] | null;
            /** Tax Id */
            tax_id?: [
                string,
                components["schemas"]["TaxIDFormat"]
            ] | null;
            /**
             * External Id
             * @description The ID of the customer in your system. This must be unique within the organization. Once set, it can't be updated.
             */
            external_id?: string | null;
        };
        /** CustomerUpdateExternalID */
        CustomerUpdateExternalID: {
            /**
             * Metadata
             * @description Key-value object allowing you to store additional information.
             *
             *     The key must be a string with a maximum length of **40 characters**.
             *     The value must be either:
             *
             *     * A string with a maximum length of **500 characters**
             *     * An integer
             *     * A floating-point number
             *     * A boolean
             *
             *     You can store up to **50 key-value pairs**.
             */
            metadata?: {
                [key: string]: string | number | boolean;
            };
            /**
             * Email
             * @description The email address of the customer. This must be unique within the organization.
             */
            email?: string | null;
            /**
             * Name
             * @description The name of the customer.
             */
            name?: string | null;
            billing_address?: components["schemas"]["Address"] | null;
            /** Tax Id */
            tax_id?: [
                string,
                components["schemas"]["TaxIDFormat"]
            ] | null;
        };
        /** DiscordGuild */
        DiscordGuild: {
            /** Name */
            name: string;
            /** Roles */
            roles: components["schemas"]["DiscordGuildRole"][];
        };
        /** DiscordGuildRole */
        DiscordGuildRole: {
            /** Id */
            id: string;
            /** Name */
            name: string;
            /** Position */
            position: number;
            /** Is Polar Bot */
            is_polar_bot: boolean;
            /**
             * Color
             * Format: color
             */
            color: string;
        };
        Discount: components["schemas"]["DiscountFixedOnceForeverDuration"] | components["schemas"]["DiscountFixedRepeatDuration"] | components["schemas"]["DiscountPercentageOnceForeverDuration"] | components["schemas"]["DiscountPercentageRepeatDuration"];
        DiscountCreate: components["schemas"]["DiscountFixedOnceForeverDurationCreate"] | components["schemas"]["DiscountFixedRepeatDurationCreate"] | components["schemas"]["DiscountPercentageOnceForeverDurationCreate"] | components["schemas"]["DiscountPercentageRepeatDurationCreate"];
        /**
         * DiscountDuration
         * @enum {string}
         */
        DiscountDuration: "once" | "forever" | "repeating";
        /**
         * DiscountFixedOnceForeverDuration
         * @description Schema for a fixed amount discount that is applied once or forever.
         */
        DiscountFixedOnceForeverDuration: {
            duration: components["schemas"]["DiscountDuration"];
            type: components["schemas"]["DiscountType"];
            /** Amount */
            amount: number;
            /** Currency */
            currency: string;
            /**
             * Created At
             * Format: date-time
             * @description Creation timestamp of the object.
             */
            created_at: string;
            /**
             * Modified At
             * @description Last modification timestamp of the object.
             */
            modified_at: string | null;
            /**
             * Id
             * Format: uuid4
             * @description The ID of the object.
             */
            id: string;
            /** Metadata */
            metadata: {
                [key: string]: string | number | boolean;
            };
            /**
             * Name
             * @description Name of the discount. Will be displayed to the customer when the discount is applied.
             */
            name: string;
            /**
             * Code
             * @description Code customers can use to apply the discount during checkout.
             */
            code: string | null;
            /**
             * Starts At
             * @description Timestamp after which the discount is redeemable.
             */
            starts_at: string | null;
            /**
             * Ends At
             * @description Timestamp after which the discount is no longer redeemable.
             */
            ends_at: string | null;
            /**
             * Max Redemptions
             * @description Maximum number of times the discount can be redeemed.
             */
            max_redemptions: number | null;
            /**
             * Redemptions Count
             * @description Number of times the discount has been redeemed.
             */
            redemptions_count: number;
            /**
             * Organization Id
             * Format: uuid4
             * @description The organization ID.
             */
            organization_id: string;
            /** Products */
            products: components["schemas"]["DiscountProduct"][];
        };
        /** DiscountFixedOnceForeverDurationBase */
        DiscountFixedOnceForeverDurationBase: {
            duration: components["schemas"]["DiscountDuration"];
            type: components["schemas"]["DiscountType"];
            /** Amount */
            amount: number;
            /** Currency */
            currency: string;
            /**
             * Created At
             * Format: date-time
             * @description Creation timestamp of the object.
             */
            created_at: string;
            /**
             * Modified At
             * @description Last modification timestamp of the object.
             */
            modified_at: string | null;
            /**
             * Id
             * Format: uuid4
             * @description The ID of the object.
             */
            id: string;
            /** Metadata */
            metadata: {
                [key: string]: string | number | boolean;
            };
            /**
             * Name
             * @description Name of the discount. Will be displayed to the customer when the discount is applied.
             */
            name: string;
            /**
             * Code
             * @description Code customers can use to apply the discount during checkout.
             */
            code: string | null;
            /**
             * Starts At
             * @description Timestamp after which the discount is redeemable.
             */
            starts_at: string | null;
            /**
             * Ends At
             * @description Timestamp after which the discount is no longer redeemable.
             */
            ends_at: string | null;
            /**
             * Max Redemptions
             * @description Maximum number of times the discount can be redeemed.
             */
            max_redemptions: number | null;
            /**
             * Redemptions Count
             * @description Number of times the discount has been redeemed.
             */
            redemptions_count: number;
            /**
             * Organization Id
             * Format: uuid4
             * @description The organization ID.
             */
            organization_id: string;
        };
        /**
         * DiscountFixedOnceForeverDurationCreate
         * @description Schema to create a fixed amount discount that is applied once or forever.
         */
        DiscountFixedOnceForeverDurationCreate: {
            duration: components["schemas"]["DiscountDuration"];
            /** @description Type of the discount. */
            type: components["schemas"]["DiscountType"];
            /**
             * Amount
             * @description Fixed amount to discount from the invoice total.
             */
            amount: number;
            /**
             * Currency
             * @description The currency. Currently, only `usd` is supported.
             * @default usd
             */
            currency: string;
            /**
             * Metadata
             * @description Key-value object allowing you to store additional information.
             *
             *     The key must be a string with a maximum length of **40 characters**.
             *     The value must be either:
             *
             *     * A string with a maximum length of **500 characters**
             *     * An integer
             *     * A floating-point number
             *     * A boolean
             *
             *     You can store up to **50 key-value pairs**.
             */
            metadata?: {
                [key: string]: string | number | boolean;
            };
            /**
             * Name
             * @description Name of the discount. Will be displayed to the customer when the discount is applied.
             */
            name: string;
            /**
             * Code
             * @description Code customers can use to apply the discount during checkout. Must be between 3 and 256 characters long and contain only alphanumeric characters.If not provided, the discount can only be applied via the API.
             */
            code?: string | null;
            /**
             * Starts At
             * @description Optional timestamp after which the discount is redeemable.
             */
            starts_at?: string | null;
            /**
             * Ends At
             * @description Optional timestamp after which the discount is no longer redeemable.
             */
            ends_at?: string | null;
            /**
             * Max Redemptions
             * @description Optional maximum number of times the discount can be redeemed.
             */
            max_redemptions?: number | null;
            /** Products */
            products?: string[] | null;
            /**
             * Organization Id
             * @description The ID of the organization owning the discount. **Required unless you use an organization token.**
             */
            organization_id?: string | null;
        };
        /**
         * DiscountFixedRepeatDuration
         * @description Schema for a fixed amount discount that is applied on every invoice
         *     for a certain number of months.
         */
        DiscountFixedRepeatDuration: {
            duration: components["schemas"]["DiscountDuration"];
            /** Duration In Months */
            duration_in_months: number;
            type: components["schemas"]["DiscountType"];
            /** Amount */
            amount: number;
            /** Currency */
            currency: string;
            /**
             * Created At
             * Format: date-time
             * @description Creation timestamp of the object.
             */
            created_at: string;
            /**
             * Modified At
             * @description Last modification timestamp of the object.
             */
            modified_at: string | null;
            /**
             * Id
             * Format: uuid4
             * @description The ID of the object.
             */
            id: string;
            /** Metadata */
            metadata: {
                [key: string]: string | number | boolean;
            };
            /**
             * Name
             * @description Name of the discount. Will be displayed to the customer when the discount is applied.
             */
            name: string;
            /**
             * Code
             * @description Code customers can use to apply the discount during checkout.
             */
            code: string | null;
            /**
             * Starts At
             * @description Timestamp after which the discount is redeemable.
             */
            starts_at: string | null;
            /**
             * Ends At
             * @description Timestamp after which the discount is no longer redeemable.
             */
            ends_at: string | null;
            /**
             * Max Redemptions
             * @description Maximum number of times the discount can be redeemed.
             */
            max_redemptions: number | null;
            /**
             * Redemptions Count
             * @description Number of times the discount has been redeemed.
             */
            redemptions_count: number;
            /**
             * Organization Id
             * Format: uuid4
             * @description The organization ID.
             */
            organization_id: string;
            /** Products */
            products: components["schemas"]["DiscountProduct"][];
        };
        /** DiscountFixedRepeatDurationBase */
        DiscountFixedRepeatDurationBase: {
            duration: components["schemas"]["DiscountDuration"];
            /** Duration In Months */
            duration_in_months: number;
            type: components["schemas"]["DiscountType"];
            /** Amount */
            amount: number;
            /** Currency */
            currency: string;
            /**
             * Created At
             * Format: date-time
             * @description Creation timestamp of the object.
             */
            created_at: string;
            /**
             * Modified At
             * @description Last modification timestamp of the object.
             */
            modified_at: string | null;
            /**
             * Id
             * Format: uuid4
             * @description The ID of the object.
             */
            id: string;
            /** Metadata */
            metadata: {
                [key: string]: string | number | boolean;
            };
            /**
             * Name
             * @description Name of the discount. Will be displayed to the customer when the discount is applied.
             */
            name: string;
            /**
             * Code
             * @description Code customers can use to apply the discount during checkout.
             */
            code: string | null;
            /**
             * Starts At
             * @description Timestamp after which the discount is redeemable.
             */
            starts_at: string | null;
            /**
             * Ends At
             * @description Timestamp after which the discount is no longer redeemable.
             */
            ends_at: string | null;
            /**
             * Max Redemptions
             * @description Maximum number of times the discount can be redeemed.
             */
            max_redemptions: number | null;
            /**
             * Redemptions Count
             * @description Number of times the discount has been redeemed.
             */
            redemptions_count: number;
            /**
             * Organization Id
             * Format: uuid4
             * @description The organization ID.
             */
            organization_id: string;
        };
        /**
         * DiscountFixedRepeatDurationCreate
         * @description Schema to create a fixed amount discount that is applied on every invoice
         *     for a certain number of months.
         */
        DiscountFixedRepeatDurationCreate: {
            duration: components["schemas"]["DiscountDuration"];
            /**
             * Duration In Months
             * @description Number of months the discount should be applied.
             *
             *     For this to work on yearly pricing, you should multiply this by 12.
             *     For example, to apply the discount for 2 years, set this to 24.
             */
            duration_in_months: number;
            /** @description Type of the discount. */
            type: components["schemas"]["DiscountType"];
            /**
             * Amount
             * @description Fixed amount to discount from the invoice total.
             */
            amount: number;
            /**
             * Currency
             * @description The currency. Currently, only `usd` is supported.
             * @default usd
             */
            currency: string;
            /**
             * Metadata
             * @description Key-value object allowing you to store additional information.
             *
             *     The key must be a string with a maximum length of **40 characters**.
             *     The value must be either:
             *
             *     * A string with a maximum length of **500 characters**
             *     * An integer
             *     * A floating-point number
             *     * A boolean
             *
             *     You can store up to **50 key-value pairs**.
             */
            metadata?: {
                [key: string]: string | number | boolean;
            };
            /**
             * Name
             * @description Name of the discount. Will be displayed to the customer when the discount is applied.
             */
            name: string;
            /**
             * Code
             * @description Code customers can use to apply the discount during checkout. Must be between 3 and 256 characters long and contain only alphanumeric characters.If not provided, the discount can only be applied via the API.
             */
            code?: string | null;
            /**
             * Starts At
             * @description Optional timestamp after which the discount is redeemable.
             */
            starts_at?: string | null;
            /**
             * Ends At
             * @description Optional timestamp after which the discount is no longer redeemable.
             */
            ends_at?: string | null;
            /**
             * Max Redemptions
             * @description Optional maximum number of times the discount can be redeemed.
             */
            max_redemptions?: number | null;
            /** Products */
            products?: string[] | null;
            /**
             * Organization Id
             * @description The ID of the organization owning the discount. **Required unless you use an organization token.**
             */
            organization_id?: string | null;
        };
        /**
         * DiscountPercentageOnceForeverDuration
         * @description Schema for a percentage discount that is applied once or forever.
         */
        DiscountPercentageOnceForeverDuration: {
            duration: components["schemas"]["DiscountDuration"];
            type: components["schemas"]["DiscountType"];
            /** Basis Points */
            basis_points: number;
            /**
             * Created At
             * Format: date-time
             * @description Creation timestamp of the object.
             */
            created_at: string;
            /**
             * Modified At
             * @description Last modification timestamp of the object.
             */
            modified_at: string | null;
            /**
             * Id
             * Format: uuid4
             * @description The ID of the object.
             */
            id: string;
            /** Metadata */
            metadata: {
                [key: string]: string | number | boolean;
            };
            /**
             * Name
             * @description Name of the discount. Will be displayed to the customer when the discount is applied.
             */
            name: string;
            /**
             * Code
             * @description Code customers can use to apply the discount during checkout.
             */
            code: string | null;
            /**
             * Starts At
             * @description Timestamp after which the discount is redeemable.
             */
            starts_at: string | null;
            /**
             * Ends At
             * @description Timestamp after which the discount is no longer redeemable.
             */
            ends_at: string | null;
            /**
             * Max Redemptions
             * @description Maximum number of times the discount can be redeemed.
             */
            max_redemptions: number | null;
            /**
             * Redemptions Count
             * @description Number of times the discount has been redeemed.
             */
            redemptions_count: number;
            /**
             * Organization Id
             * Format: uuid4
             * @description The organization ID.
             */
            organization_id: string;
            /** Products */
            products: components["schemas"]["DiscountProduct"][];
        };
        /** DiscountPercentageOnceForeverDurationBase */
        DiscountPercentageOnceForeverDurationBase: {
            duration: components["schemas"]["DiscountDuration"];
            type: components["schemas"]["DiscountType"];
            /** Basis Points */
            basis_points: number;
            /**
             * Created At
             * Format: date-time
             * @description Creation timestamp of the object.
             */
            created_at: string;
            /**
             * Modified At
             * @description Last modification timestamp of the object.
             */
            modified_at: string | null;
            /**
             * Id
             * Format: uuid4
             * @description The ID of the object.
             */
            id: string;
            /** Metadata */
            metadata: {
                [key: string]: string | number | boolean;
            };
            /**
             * Name
             * @description Name of the discount. Will be displayed to the customer when the discount is applied.
             */
            name: string;
            /**
             * Code
             * @description Code customers can use to apply the discount during checkout.
             */
            code: string | null;
            /**
             * Starts At
             * @description Timestamp after which the discount is redeemable.
             */
            starts_at: string | null;
            /**
             * Ends At
             * @description Timestamp after which the discount is no longer redeemable.
             */
            ends_at: string | null;
            /**
             * Max Redemptions
             * @description Maximum number of times the discount can be redeemed.
             */
            max_redemptions: number | null;
            /**
             * Redemptions Count
             * @description Number of times the discount has been redeemed.
             */
            redemptions_count: number;
            /**
             * Organization Id
             * Format: uuid4
             * @description The organization ID.
             */
            organization_id: string;
        };
        /**
         * DiscountPercentageOnceForeverDurationCreate
         * @description Schema to create a percentage discount that is applied once or forever.
         */
        DiscountPercentageOnceForeverDurationCreate: {
            duration: components["schemas"]["DiscountDuration"];
            /** @description Type of the discount. */
            type: components["schemas"]["DiscountType"];
            /**
             * Basis Points
             * @description Discount percentage in basis points.
             *
             *     A basis point is 1/100th of a percent.
             *     For example, to create a 25.5% discount, set this to 2550.
             */
            basis_points: number;
            /**
             * Metadata
             * @description Key-value object allowing you to store additional information.
             *
             *     The key must be a string with a maximum length of **40 characters**.
             *     The value must be either:
             *
             *     * A string with a maximum length of **500 characters**
             *     * An integer
             *     * A floating-point number
             *     * A boolean
             *
             *     You can store up to **50 key-value pairs**.
             */
            metadata?: {
                [key: string]: string | number | boolean;
            };
            /**
             * Name
             * @description Name of the discount. Will be displayed to the customer when the discount is applied.
             */
            name: string;
            /**
             * Code
             * @description Code customers can use to apply the discount during checkout. Must be between 3 and 256 characters long and contain only alphanumeric characters.If not provided, the discount can only be applied via the API.
             */
            code?: string | null;
            /**
             * Starts At
             * @description Optional timestamp after which the discount is redeemable.
             */
            starts_at?: string | null;
            /**
             * Ends At
             * @description Optional timestamp after which the discount is no longer redeemable.
             */
            ends_at?: string | null;
            /**
             * Max Redemptions
             * @description Optional maximum number of times the discount can be redeemed.
             */
            max_redemptions?: number | null;
            /** Products */
            products?: string[] | null;
            /**
             * Organization Id
             * @description The ID of the organization owning the discount. **Required unless you use an organization token.**
             */
            organization_id?: string | null;
        };
        /**
         * DiscountPercentageRepeatDuration
         * @description Schema for a percentage discount that is applied on every invoice
         *     for a certain number of months.
         */
        DiscountPercentageRepeatDuration: {
            duration: components["schemas"]["DiscountDuration"];
            /** Duration In Months */
            duration_in_months: number;
            type: components["schemas"]["DiscountType"];
            /** Basis Points */
            basis_points: number;
            /**
             * Created At
             * Format: date-time
             * @description Creation timestamp of the object.
             */
            created_at: string;
            /**
             * Modified At
             * @description Last modification timestamp of the object.
             */
            modified_at: string | null;
            /**
             * Id
             * Format: uuid4
             * @description The ID of the object.
             */
            id: string;
            /** Metadata */
            metadata: {
                [key: string]: string | number | boolean;
            };
            /**
             * Name
             * @description Name of the discount. Will be displayed to the customer when the discount is applied.
             */
            name: string;
            /**
             * Code
             * @description Code customers can use to apply the discount during checkout.
             */
            code: string | null;
            /**
             * Starts At
             * @description Timestamp after which the discount is redeemable.
             */
            starts_at: string | null;
            /**
             * Ends At
             * @description Timestamp after which the discount is no longer redeemable.
             */
            ends_at: string | null;
            /**
             * Max Redemptions
             * @description Maximum number of times the discount can be redeemed.
             */
            max_redemptions: number | null;
            /**
             * Redemptions Count
             * @description Number of times the discount has been redeemed.
             */
            redemptions_count: number;
            /**
             * Organization Id
             * Format: uuid4
             * @description The organization ID.
             */
            organization_id: string;
            /** Products */
            products: components["schemas"]["DiscountProduct"][];
        };
        /** DiscountPercentageRepeatDurationBase */
        DiscountPercentageRepeatDurationBase: {
            duration: components["schemas"]["DiscountDuration"];
            /** Duration In Months */
            duration_in_months: number;
            type: components["schemas"]["DiscountType"];
            /** Basis Points */
            basis_points: number;
            /**
             * Created At
             * Format: date-time
             * @description Creation timestamp of the object.
             */
            created_at: string;
            /**
             * Modified At
             * @description Last modification timestamp of the object.
             */
            modified_at: string | null;
            /**
             * Id
             * Format: uuid4
             * @description The ID of the object.
             */
            id: string;
            /** Metadata */
            metadata: {
                [key: string]: string | number | boolean;
            };
            /**
             * Name
             * @description Name of the discount. Will be displayed to the customer when the discount is applied.
             */
            name: string;
            /**
             * Code
             * @description Code customers can use to apply the discount during checkout.
             */
            code: string | null;
            /**
             * Starts At
             * @description Timestamp after which the discount is redeemable.
             */
            starts_at: string | null;
            /**
             * Ends At
             * @description Timestamp after which the discount is no longer redeemable.
             */
            ends_at: string | null;
            /**
             * Max Redemptions
             * @description Maximum number of times the discount can be redeemed.
             */
            max_redemptions: number | null;
            /**
             * Redemptions Count
             * @description Number of times the discount has been redeemed.
             */
            redemptions_count: number;
            /**
             * Organization Id
             * Format: uuid4
             * @description The organization ID.
             */
            organization_id: string;
        };
        /**
         * DiscountPercentageRepeatDurationCreate
         * @description Schema to create a percentage discount that is applied on every invoice
         *     for a certain number of months.
         */
        DiscountPercentageRepeatDurationCreate: {
            duration: components["schemas"]["DiscountDuration"];
            /**
             * Duration In Months
             * @description Number of months the discount should be applied.
             *
             *     For this to work on yearly pricing, you should multiply this by 12.
             *     For example, to apply the discount for 2 years, set this to 24.
             */
            duration_in_months: number;
            /** @description Type of the discount. */
            type: components["schemas"]["DiscountType"];
            /**
             * Basis Points
             * @description Discount percentage in basis points.
             *
             *     A basis point is 1/100th of a percent.
             *     For example, to create a 25.5% discount, set this to 2550.
             */
            basis_points: number;
            /**
             * Metadata
             * @description Key-value object allowing you to store additional information.
             *
             *     The key must be a string with a maximum length of **40 characters**.
             *     The value must be either:
             *
             *     * A string with a maximum length of **500 characters**
             *     * An integer
             *     * A floating-point number
             *     * A boolean
             *
             *     You can store up to **50 key-value pairs**.
             */
            metadata?: {
                [key: string]: string | number | boolean;
            };
            /**
             * Name
             * @description Name of the discount. Will be displayed to the customer when the discount is applied.
             */
            name: string;
            /**
             * Code
             * @description Code customers can use to apply the discount during checkout. Must be between 3 and 256 characters long and contain only alphanumeric characters.If not provided, the discount can only be applied via the API.
             */
            code?: string | null;
            /**
             * Starts At
             * @description Optional timestamp after which the discount is redeemable.
             */
            starts_at?: string | null;
            /**
             * Ends At
             * @description Optional timestamp after which the discount is no longer redeemable.
             */
            ends_at?: string | null;
            /**
             * Max Redemptions
             * @description Optional maximum number of times the discount can be redeemed.
             */
            max_redemptions?: number | null;
            /** Products */
            products?: string[] | null;
            /**
             * Organization Id
             * @description The ID of the organization owning the discount. **Required unless you use an organization token.**
             */
            organization_id?: string | null;
        };
        /**
         * DiscountProduct
         * @description A product that a discount can be applied to.
         */
        DiscountProduct: {
            /** Metadata */
            metadata: {
                [key: string]: string | number | boolean;
            };
            /**
             * Created At
             * Format: date-time
             * @description Creation timestamp of the object.
             */
            created_at: string;
            /**
             * Modified At
             * @description Last modification timestamp of the object.
             */
            modified_at: string | null;
            /**
             * Id
             * Format: uuid4
             * @description The ID of the product.
             */
            id: string;
            /**
             * Name
             * @description The name of the product.
             */
            name: string;
            /**
             * Description
             * @description The description of the product.
             */
            description: string | null;
            /** @description The recurring interval of the product. If `None`, the product is a one-time purchase. */
            recurring_interval: components["schemas"]["SubscriptionRecurringInterval"] | null;
            /**
             * Is Recurring
             * @description Whether the product is a subscription.
             */
            is_recurring: boolean;
            /**
             * Is Archived
             * @description Whether the product is archived and no longer available.
             */
            is_archived: boolean;
            /**
             * Organization Id
             * Format: uuid4
             * @description The ID of the organization owning the product.
             */
            organization_id: string;
        };
        /**
         * DiscountSortProperty
         * @enum {string}
         */
        DiscountSortProperty: "created_at" | "-created_at" | "name" | "-name" | "code" | "-code" | "redemptions_count" | "-redemptions_count";
        /**
         * DiscountType
         * @enum {string}
         */
        DiscountType: "fixed" | "percentage";
        /**
         * DiscountUpdate
         * @description Schema to update a discount.
         */
        DiscountUpdate: {
            /**
             * Metadata
             * @description Key-value object allowing you to store additional information.
             *
             *     The key must be a string with a maximum length of **40 characters**.
             *     The value must be either:
             *
             *     * A string with a maximum length of **500 characters**
             *     * An integer
             *     * A floating-point number
             *     * A boolean
             *
             *     You can store up to **50 key-value pairs**.
             */
            metadata?: {
                [key: string]: string | number | boolean;
            };
            /** Name */
            name?: string | null;
            /** Code */
            code?: (string | null) | null;
            /** Starts At */
            starts_at?: (string | null) | null;
            /** Ends At */
            ends_at?: (string | null) | null;
            /** Max Redemptions */
            max_redemptions?: (number | null) | null;
            duration?: components["schemas"]["DiscountDuration"] | null;
            /** Duration In Months */
            duration_in_months?: number | null;
            type?: components["schemas"]["DiscountType"] | null;
            /** Amount */
            amount?: number | null;
            /** Currency */
            currency?: string | null;
            /** Basis Points */
            basis_points?: number | null;
            /** Products */
            products?: string[] | null;
        };
        /**
         * DownloadableFileCreate
         * @description Schema to create a file to be associated with the downloadables benefit.
         */
        DownloadableFileCreate: {
            /** Organization Id */
            organization_id?: string | null;
            /** Name */
            name: string;
            /** Mime Type */
            mime_type: string;
            /** Size */
            size: number;
            /** Checksum Sha256 Base64 */
            checksum_sha256_base64?: string | null;
            upload: components["schemas"]["S3FileCreateMultipart"];
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            service: "downloadable";
            /** Version */
            version?: string | null;
        };
        /**
         * DownloadableFileRead
         * @description File to be associated with the downloadables benefit.
         */
        DownloadableFileRead: {
            /**
             * Id
             * Format: uuid4
             * @description The ID of the object.
             */
            id: string;
            /**
             * Organization Id
             * Format: uuid4
             */
            organization_id: string;
            /** Name */
            name: string;
            /** Path */
            path: string;
            /** Mime Type */
            mime_type: string;
            /** Size */
            size: number;
            /** Storage Version */
            storage_version: string | null;
            /** Checksum Etag */
            checksum_etag: string | null;
            /** Checksum Sha256 Base64 */
            checksum_sha256_base64: string | null;
            /** Checksum Sha256 Hex */
            checksum_sha256_hex: string | null;
            /** Last Modified At */
            last_modified_at: string | null;
            /** Version */
            version: string | null;
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            service: "downloadable";
            /** Is Uploaded */
            is_uploaded: boolean;
            /**
             * Created At
             * Format: date-time
             */
            created_at: string;
            /** Size Readable */
            readonly size_readable: string;
        };
        /** DownloadableRead */
        DownloadableRead: {
            /**
             * Id
             * Format: uuid4
             */
            id: string;
            /**
             * Benefit Id
             * Format: uuid4
             */
            benefit_id: string;
            file: components["schemas"]["FileDownload"];
        };
        /** EmailUpdateRequest */
        EmailUpdateRequest: {
            /**
             * Email
             * Format: email
             */
            email: string;
            /** Return To */
            return_to?: string | null;
        };
        /** Event */
        Event: {
            /** Metadata */
            metadata: {
                [key: string]: string | number | boolean;
            };
            /**
             * Id
             * Format: uuid4
             * @description The ID of the object.
             */
            id: string;
            /**
             * Timestamp
             * Format: date-time
             * @description The timestamp of the event.
             */
            timestamp: string;
            /**
             * Name
             * @description The name of the event.
             */
            name: string;
            /** @description The source of the event. `system` events are created by Polar. `user` events are the one you create through our ingestion API. */
            source: components["schemas"]["EventSource"];
            /**
             * Organization Id
             * Format: uuid4
             * @description The ID of the organization owning the event.
             */
            organization_id: string;
            /**
             * Customer Id
             * @description ID of the customer in your Polar organization associated with the event.
             */
            customer_id: string | null;
            /** @description The customer associated with the event. */
            customer: components["schemas"]["Customer"] | null;
            /**
             * External Customer Id
             * @description ID of the customer in your system associated with the event.
             */
            external_customer_id: string | null;
        };
        /** EventCreateCustomer */
        EventCreateCustomer: {
            /**
             * Metadata
             * @description Key-value object allowing you to store additional information.
             *
             *     The key must be a string with a maximum length of **40 characters**.
             *     The value must be either:
             *
             *     * A string with a maximum length of **500 characters**
             *     * An integer
             *     * A floating-point number
             *     * A boolean
             *
             *     You can store up to **50 key-value pairs**.
             */
            metadata?: {
                [key: string]: string | number | boolean;
            };
            /**
             * Timestamp
             * Format: date-time
             * @description The timestamp of the event.
             */
            timestamp?: string;
            /**
             * Name
             * @description The name of the event.
             */
            name: string;
            /**
             * Organization Id
             * @description The ID of the organization owning the event. **Required unless you use an organization token.**
             */
            organization_id?: string | null;
            /**
             * Customer Id
             * Format: uuid4
             * @description ID of the customer in your Polar organization associated with the event.
             */
            customer_id: string;
        };
        /** EventCreateExternalCustomer */
        EventCreateExternalCustomer: {
            /**
             * Metadata
             * @description Key-value object allowing you to store additional information.
             *
             *     The key must be a string with a maximum length of **40 characters**.
             *     The value must be either:
             *
             *     * A string with a maximum length of **500 characters**
             *     * An integer
             *     * A floating-point number
             *     * A boolean
             *
             *     You can store up to **50 key-value pairs**.
             */
            metadata?: {
                [key: string]: string | number | boolean;
            };
            /**
             * Timestamp
             * Format: date-time
             * @description The timestamp of the event.
             */
            timestamp?: string;
            /**
             * Name
             * @description The name of the event.
             */
            name: string;
            /**
             * Organization Id
             * @description The ID of the organization owning the event. **Required unless you use an organization token.**
             */
            organization_id?: string | null;
            /**
             * External Customer Id
             * @description ID of the customer in your system associated with the event.
             */
            external_customer_id: string;
        };
        /** EventName */
        EventName: {
            /**
             * Name
             * @description The name of the event.
             */
            name: string;
            /** @description The source of the event. `system` events are created by Polar. `user` events are the one you create through our ingestion API. */
            source: components["schemas"]["EventSource"];
            /**
             * Occurrences
             * @description Number of times the event has occurred.
             */
            occurrences: number;
            /**
             * First Seen
             * Format: date-time
             * @description The first time the event occurred.
             */
            first_seen: string;
            /**
             * Last Seen
             * Format: date-time
             * @description The last time the event occurred.
             */
            last_seen: string;
        };
        /**
         * EventNamesSortProperty
         * @enum {string}
         */
        EventNamesSortProperty: "name" | "-name" | "occurrences" | "-occurrences" | "first_seen" | "-first_seen" | "last_seen" | "-last_seen";
        /**
         * EventSortProperty
         * @enum {string}
         */
        EventSortProperty: "timestamp" | "-timestamp";
        /**
         * EventSource
         * @enum {string}
         */
        EventSource: "system" | "user";
        /** EventsIngest */
        EventsIngest: {
            /**
             * Events
             * @description List of events to ingest.
             */
            events: (components["schemas"]["EventCreateCustomer"] | components["schemas"]["EventCreateExternalCustomer"])[];
        };
        /** EventsIngestResponse */
        EventsIngestResponse: {
            /**
             * Inserted
             * @description Number of events inserted.
             */
            inserted: number;
        };
        /**
         * ExistingProductPrice
         * @description A price that already exists for this product.
         *
         *     Useful when updating a product if you want to keep an existing price.
         */
        ExistingProductPrice: {
            /**
             * Id
             * Format: uuid4
             */
            id: string;
        };
        /** ExpiredCheckoutError */
        ExpiredCheckoutError: {
            /**
             * Error
             * @constant
             */
            error: "ExpiredCheckoutError";
            /** Detail */
            detail: string;
        };
        FileCreate: components["schemas"]["DownloadableFileCreate"] | components["schemas"]["ProductMediaFileCreate"] | components["schemas"]["OrganizationAvatarFileCreate"];
        /** FileDownload */
        FileDownload: {
            /**
             * Id
             * Format: uuid4
             * @description The ID of the object.
             */
            id: string;
            /**
             * Organization Id
             * Format: uuid4
             */
            organization_id: string;
            /** Name */
            name: string;
            /** Path */
            path: string;
            /** Mime Type */
            mime_type: string;
            /** Size */
            size: number;
            /** Storage Version */
            storage_version: string | null;
            /** Checksum Etag */
            checksum_etag: string | null;
            /** Checksum Sha256 Base64 */
            checksum_sha256_base64: string | null;
            /** Checksum Sha256 Hex */
            checksum_sha256_hex: string | null;
            /** Last Modified At */
            last_modified_at: string | null;
            download: components["schemas"]["S3DownloadURL"];
            /** Version */
            version: string | null;
            /** Is Uploaded */
            is_uploaded: boolean;
            service: components["schemas"]["FileServiceTypes"];
            /** Size Readable */
            readonly size_readable: string;
        };
        /** FilePatch */
        FilePatch: {
            /** Name */
            name?: string | null;
            /** Version */
            version?: string | null;
        };
        /**
         * FileServiceTypes
         * @enum {string}
         */
        FileServiceTypes: "downloadable" | "product_media" | "organization_avatar";
        /** FileUpload */
        FileUpload: {
            /**
             * Id
             * Format: uuid4
             * @description The ID of the object.
             */
            id: string;
            /**
             * Organization Id
             * Format: uuid4
             */
            organization_id: string;
            /** Name */
            name: string;
            /** Path */
            path: string;
            /** Mime Type */
            mime_type: string;
            /** Size */
            size: number;
            /** Storage Version */
            storage_version: string | null;
            /** Checksum Etag */
            checksum_etag: string | null;
            /** Checksum Sha256 Base64 */
            checksum_sha256_base64: string | null;
            /** Checksum Sha256 Hex */
            checksum_sha256_hex: string | null;
            /** Last Modified At */
            last_modified_at: string | null;
            upload: components["schemas"]["S3FileUploadMultipart"];
            /** Version */
            version: string | null;
            /**
             * Is Uploaded
             * @default false
             */
            is_uploaded: boolean;
            service: components["schemas"]["FileServiceTypes"];
            /** Size Readable */
            readonly size_readable: string;
        };
        /** FileUploadCompleted */
        FileUploadCompleted: {
            /** Id */
            id: string;
            /** Path */
            path: string;
            /** Parts */
            parts: components["schemas"]["S3FileUploadCompletedPart"][];
        };
        /** Filter */
        Filter: {
            conjunction: components["schemas"]["FilterConjunction"];
            /** Clauses */
            clauses: (components["schemas"]["FilterClause"] | components["schemas"]["Filter"])[];
        };
        /** FilterClause */
        FilterClause: {
            /** Property */
            property: string;
            operator: components["schemas"]["FilterOperator"];
            /** Value */
            value: string | number | boolean;
        };
        /**
         * FilterConjunction
         * @enum {string}
         */
        FilterConjunction: "and" | "or";
        /**
         * FilterOperator
         * @enum {string}
         */
        FilterOperator: "eq" | "ne" | "gt" | "gte" | "lt" | "lte" | "like" | "not_like";
        /**
         * GenericPayment
         * @description Schema of a payment with a generic payment method.
         */
        GenericPayment: {
            /**
             * Created At
             * Format: date-time
             * @description Creation timestamp of the object.
             */
            created_at: string;
            /**
             * Modified At
             * @description Last modification timestamp of the object.
             */
            modified_at: string | null;
            /**
             * Id
             * Format: uuid4
             * @description The ID of the object.
             */
            id: string;
            /** @description The payment processor. */
            processor: components["schemas"]["PaymentProcessor"];
            /** @description The payment status. */
            status: components["schemas"]["PaymentStatus"];
            /**
             * Amount
             * @description The payment amount in cents.
             */
            amount: number;
            /**
             * Currency
             * @description The payment currency. Currently, only `usd` is supported.
             */
            currency: string;
            /**
             * Method
             * @description The payment method used.
             */
            method: string;
            /**
             * Decline Reason
             * @description Error code, if the payment was declined.
             */
            decline_reason: string | null;
            /**
             * Decline Message
             * @description Human-reasable error message, if the payment was declined.
             */
            decline_message: string | null;
            /**
             * Organization Id
             * Format: uuid4
             * @description The ID of the organization that owns the payment.
             */
            organization_id: string;
            /**
             * Checkout Id
             * @description The ID of the checkout session associated with this payment.
             */
            checkout_id: string | null;
            /**
             * Order Id
             * @description The ID of the order associated with this payment.
             */
            order_id: string | null;
        };
        /** GitHubInvitesBenefitOrganization */
        GitHubInvitesBenefitOrganization: {
            /** Name */
            name: string;
            /** Is Personal */
            is_personal: boolean;
            /** Plan Name */
            plan_name: string;
            /** Is Free */
            is_free: boolean;
        };
        /** GitHubInvitesBenefitRepositories */
        GitHubInvitesBenefitRepositories: {
            /** Repositories */
            repositories: components["schemas"]["GitHubInvitesBenefitRepository"][];
            /** Organizations */
            organizations: components["schemas"]["GitHubInvitesBenefitOrganization"][];
        };
        /** GitHubInvitesBenefitRepository */
        GitHubInvitesBenefitRepository: {
            /** Repository Owner */
            repository_owner: string;
            /** Repository Name */
            repository_name: string;
        };
        /** HTTPValidationError */
        HTTPValidationError: {
            /** Detail */
            detail?: components["schemas"]["ValidationError"][];
        };
        /**
         * IdentityVerificationStatus
         * @enum {string}
         */
        IdentityVerificationStatus: "unverified" | "pending" | "verified" | "failed";
        /** IntrospectTokenResponse */
        IntrospectTokenResponse: {
            /** Active */
            active: boolean;
            /** Client Id */
            client_id: string;
            /**
             * Token Type
             * @enum {string}
             */
            token_type: "access_token" | "refresh_token";
            /** Scope */
            scope: string;
            sub_type: components["schemas"]["SubType"];
            /** Sub */
            sub: string;
            /** Aud */
            aud: string;
            /** Iss */
            iss: string;
            /** Exp */
            exp: number;
            /** Iat */
            iat: number;
        };
        LegacyRecurringProductPrice: components["schemas"]["LegacyRecurringProductPriceFixed"] | components["schemas"]["LegacyRecurringProductPriceCustom"] | components["schemas"]["LegacyRecurringProductPriceFree"];
        /**
         * LegacyRecurringProductPriceCustom
         * @description A pay-what-you-want recurring price for a product, i.e. a subscription.
         *
         *     **Deprecated**: The recurring interval should be set on the product itself.
         */
        LegacyRecurringProductPriceCustom: {
            /**
             * Created At
             * Format: date-time
             * @description Creation timestamp of the object.
             */
            created_at: string;
            /**
             * Modified At
             * @description Last modification timestamp of the object.
             */
            modified_at: string | null;
            /**
             * Id
             * Format: uuid4
             * @description The ID of the price.
             */
            id: string;
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            amount_type: "custom";
            /**
             * Is Archived
             * @description Whether the price is archived and no longer available.
             */
            is_archived: boolean;
            /**
             * Product Id
             * Format: uuid4
             * @description The ID of the product owning the price.
             */
            product_id: string;
            /**
             * Type
             * @description The type of the price.
             * @constant
             */
            type: "recurring";
            /** @description The recurring interval of the price. */
            recurring_interval: components["schemas"]["SubscriptionRecurringInterval"];
            /**
             * Price Currency
             * @description The currency.
             */
            price_currency: string;
            /**
             * Minimum Amount
             * @description The minimum amount the customer can pay.
             */
            minimum_amount: number | null;
            /**
             * Maximum Amount
             * @description The maximum amount the customer can pay.
             */
            maximum_amount: number | null;
            /**
             * Preset Amount
             * @description The initial amount shown to the customer.
             */
            preset_amount: number | null;
            /**
             * Legacy
             * @constant
             */
            readonly legacy: true;
        };
        /**
         * LegacyRecurringProductPriceFixed
         * @description A recurring price for a product, i.e. a subscription.
         *
         *     **Deprecated**: The recurring interval should be set on the product itself.
         */
        LegacyRecurringProductPriceFixed: {
            /**
             * Created At
             * Format: date-time
             * @description Creation timestamp of the object.
             */
            created_at: string;
            /**
             * Modified At
             * @description Last modification timestamp of the object.
             */
            modified_at: string | null;
            /**
             * Id
             * Format: uuid4
             * @description The ID of the price.
             */
            id: string;
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            amount_type: "fixed";
            /**
             * Is Archived
             * @description Whether the price is archived and no longer available.
             */
            is_archived: boolean;
            /**
             * Product Id
             * Format: uuid4
             * @description The ID of the product owning the price.
             */
            product_id: string;
            /**
             * Type
             * @description The type of the price.
             * @constant
             */
            type: "recurring";
            /** @description The recurring interval of the price. */
            recurring_interval: components["schemas"]["SubscriptionRecurringInterval"];
            /**
             * Price Currency
             * @description The currency.
             */
            price_currency: string;
            /**
             * Price Amount
             * @description The price in cents.
             */
            price_amount: number;
            /**
             * Legacy
             * @constant
             */
            readonly legacy: true;
        };
        /**
         * LegacyRecurringProductPriceFree
         * @description A free recurring price for a product, i.e. a subscription.
         *
         *     **Deprecated**: The recurring interval should be set on the product itself.
         */
        LegacyRecurringProductPriceFree: {
            /**
             * Created At
             * Format: date-time
             * @description Creation timestamp of the object.
             */
            created_at: string;
            /**
             * Modified At
             * @description Last modification timestamp of the object.
             */
            modified_at: string | null;
            /**
             * Id
             * Format: uuid4
             * @description The ID of the price.
             */
            id: string;
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            amount_type: "free";
            /**
             * Is Archived
             * @description Whether the price is archived and no longer available.
             */
            is_archived: boolean;
            /**
             * Product Id
             * Format: uuid4
             * @description The ID of the product owning the price.
             */
            product_id: string;
            /**
             * Type
             * @description The type of the price.
             * @constant
             */
            type: "recurring";
            /** @description The recurring interval of the price. */
            recurring_interval: components["schemas"]["SubscriptionRecurringInterval"];
            /**
             * Legacy
             * @constant
             */
            readonly legacy: true;
        };
        /** LicenseKeyActivate */
        LicenseKeyActivate: {
            /** Key */
            key: string;
            /**
             * Organization Id
             * Format: uuid4
             */
            organization_id: string;
            /** Label */
            label: string;
            /**
             * Conditions
             * @description Key-value object allowing you to set conditions that must match when validating the license key.
             *
             *     The key must be a string with a maximum length of **40 characters**.
             *     The value must be either:
             *
             *     * A string with a maximum length of **500 characters**
             *     * An integer
             *     * A floating-point number
             *     * A boolean
             *
             *     You can store up to **50 key-value pairs**.
             */
            conditions?: {
                [key: string]: string | number | boolean;
            };
            /**
             * Meta
             * @description Key-value object allowing you to store additional information about the activation
             *
             *     The key must be a string with a maximum length of **40 characters**.
             *     The value must be either:
             *
             *     * A string with a maximum length of **500 characters**
             *     * An integer
             *     * A floating-point number
             *     * A boolean
             *
             *     You can store up to **50 key-value pairs**.
             */
            meta?: {
                [key: string]: string | number | boolean;
            };
        };
        /** LicenseKeyActivationBase */
        LicenseKeyActivationBase: {
            /**
             * Id
             * Format: uuid4
             */
            id: string;
            /**
             * License Key Id
             * Format: uuid4
             */
            license_key_id: string;
            /** Label */
            label: string;
            /** Meta */
            meta: {
                [key: string]: string | number | boolean;
            };
            /**
             * Created At
             * Format: date-time
             */
            created_at: string;
            /** Modified At */
            modified_at: string | null;
        };
        /** LicenseKeyActivationRead */
        LicenseKeyActivationRead: {
            /**
             * Id
             * Format: uuid4
             */
            id: string;
            /**
             * License Key Id
             * Format: uuid4
             */
            license_key_id: string;
            /** Label */
            label: string;
            /** Meta */
            meta: {
                [key: string]: string | number | boolean;
            };
            /**
             * Created At
             * Format: date-time
             */
            created_at: string;
            /** Modified At */
            modified_at: string | null;
            license_key: components["schemas"]["LicenseKeyRead"];
        };
        /** LicenseKeyCustomer */
        LicenseKeyCustomer: {
            /**
             * Id
             * Format: uuid4
             * @description The ID of the customer.
             */
            id: string;
            /**
             * Created At
             * Format: date-time
             * @description Creation timestamp of the object.
             */
            created_at: string;
            /**
             * Modified At
             * @description Last modification timestamp of the object.
             */
            modified_at: string | null;
            /** Metadata */
            metadata: {
                [key: string]: string | number | boolean;
            };
            /**
             * External Id
             * @description The ID of the customer in your system. This must be unique within the organization. Once set, it can't be updated.
             */
            external_id: string | null;
            /**
             * Email
             * @description The email address of the customer. This must be unique within the organization.
             */
            email: string;
            /**
             * Email Verified
             * @description Whether the customer email address is verified. The address is automatically verified when the customer accesses the customer portal using their email address.
             */
            email_verified: boolean;
            /**
             * Name
             * @description The name of the customer.
             */
            name: string | null;
            billing_address: components["schemas"]["Address"] | null;
            /** Tax Id */
            tax_id: [
                string,
                components["schemas"]["TaxIDFormat"]
            ] | null;
            /**
             * Organization Id
             * Format: uuid4
             * @description The ID of the organization owning the customer.
             */
            organization_id: string;
            /**
             * Deleted At
             * @description Timestamp for when the customer was soft deleted.
             */
            deleted_at: string | null;
            /** Avatar Url */
            readonly avatar_url: string;
        };
        /** LicenseKeyDeactivate */
        LicenseKeyDeactivate: {
            /** Key */
            key: string;
            /**
             * Organization Id
             * Format: uuid4
             */
            organization_id: string;
            /**
             * Activation Id
             * Format: uuid4
             */
            activation_id: string;
        };
        /** LicenseKeyRead */
        LicenseKeyRead: {
            /**
             * Id
             * Format: uuid4
             * @description The ID of the object.
             */
            id: string;
            /**
             * Created At
             * Format: date-time
             * @description Creation timestamp of the object.
             */
            created_at: string;
            /**
             * Modified At
             * @description Last modification timestamp of the object.
             */
            modified_at: string | null;
            /**
             * Organization Id
             * Format: uuid4
             */
            organization_id: string;
            /**
             * Customer Id
             * Format: uuid4
             */
            customer_id: string;
            customer: components["schemas"]["LicenseKeyCustomer"];
            /**
             * Benefit Id
             * Format: uuid4
             * @description The benefit ID.
             */
            benefit_id: string;
            /** Key */
            key: string;
            /** Display Key */
            display_key: string;
            status: components["schemas"]["LicenseKeyStatus"];
            /** Limit Activations */
            limit_activations: number | null;
            /** Usage */
            usage: number;
            /** Limit Usage */
            limit_usage: number | null;
            /** Validations */
            validations: number;
            /** Last Validated At */
            last_validated_at: string | null;
            /** Expires At */
            expires_at: string | null;
        };
        /**
         * LicenseKeyStatus
         * @enum {string}
         */
        LicenseKeyStatus: "granted" | "revoked" | "disabled";
        /** LicenseKeyUpdate */
        LicenseKeyUpdate: {
            status?: components["schemas"]["LicenseKeyStatus"] | null;
            /**
             * Usage
             * @default 0
             */
            usage: number;
            /** Limit Activations */
            limit_activations?: number | null;
            /** Limit Usage */
            limit_usage?: number | null;
            /** Expires At */
            expires_at?: string | null;
        };
        /** LicenseKeyUser */
        LicenseKeyUser: {
            /**
             * Id
             * Format: uuid4
             */
            id: string;
            /** Email */
            email: string;
            /** Public Name */
            public_name: string;
            /** Avatar Url */
            avatar_url?: string | null;
        };
        /** LicenseKeyValidate */
        LicenseKeyValidate: {
            /** Key */
            key: string;
            /**
             * Organization Id
             * Format: uuid4
             */
            organization_id: string;
            /** Activation Id */
            activation_id?: string | null;
            /** Benefit Id */
            benefit_id?: string | null;
            /** Customer Id */
            customer_id?: string | null;
            /** Increment Usage */
            increment_usage?: number | null;
            /**
             * Conditions
             * @description Key-value object allowing you to set conditions that must match when validating the license key.
             *
             *     The key must be a string with a maximum length of **40 characters**.
             *     The value must be either:
             *
             *     * A string with a maximum length of **500 characters**
             *     * An integer
             *     * A floating-point number
             *     * A boolean
             *
             *     You can store up to **50 key-value pairs**.
             */
            conditions?: {
                [key: string]: string | number | boolean;
            };
        };
        /** LicenseKeyWithActivations */
        LicenseKeyWithActivations: {
            /**
             * Id
             * Format: uuid4
             * @description The ID of the object.
             */
            id: string;
            /**
             * Created At
             * Format: date-time
             * @description Creation timestamp of the object.
             */
            created_at: string;
            /**
             * Modified At
             * @description Last modification timestamp of the object.
             */
            modified_at: string | null;
            /**
             * Organization Id
             * Format: uuid4
             */
            organization_id: string;
            /**
             * Customer Id
             * Format: uuid4
             */
            customer_id: string;
            customer: components["schemas"]["LicenseKeyCustomer"];
            /**
             * Benefit Id
             * Format: uuid4
             * @description The benefit ID.
             */
            benefit_id: string;
            /** Key */
            key: string;
            /** Display Key */
            display_key: string;
            status: components["schemas"]["LicenseKeyStatus"];
            /** Limit Activations */
            limit_activations: number | null;
            /** Usage */
            usage: number;
            /** Limit Usage */
            limit_usage: number | null;
            /** Validations */
            validations: number;
            /** Last Validated At */
            last_validated_at: string | null;
            /** Expires At */
            expires_at: string | null;
            /** Activations */
            activations: components["schemas"]["LicenseKeyActivationBase"][];
        };
        /** ListResource[Account] */
        ListResource_Account_: {
            /** Items */
            items: components["schemas"]["Account"][];
            pagination: components["schemas"]["Pagination"];
        };
        /** ListResource[BenefitGrant] */
        ListResource_BenefitGrant_: {
            /** Items */
            items: components["schemas"]["BenefitGrant"][];
            pagination: components["schemas"]["Pagination"];
        };
        /** ListResource[Benefit] */
        ListResource_Benefit_: {
            /** Items */
            items: components["schemas"]["Benefit"][];
            pagination: components["schemas"]["Pagination"];
        };
        /** ListResource[CheckoutLink] */
        ListResource_CheckoutLink_: {
            /** Items */
            items: components["schemas"]["CheckoutLink"][];
            pagination: components["schemas"]["Pagination"];
        };
        /** ListResource[Checkout] */
        ListResource_Checkout_: {
            /** Items */
            items: components["schemas"]["Checkout"][];
            pagination: components["schemas"]["Pagination"];
        };
        /** ListResource[CustomField] */
        ListResource_CustomField_: {
            /** Items */
            items: components["schemas"]["CustomField"][];
            pagination: components["schemas"]["Pagination"];
        };
        /** ListResource[CustomerBenefitGrant] */
        ListResource_CustomerBenefitGrant_: {
            /** Items */
            items: components["schemas"]["CustomerBenefitGrant"][];
            pagination: components["schemas"]["Pagination"];
        };
        /** ListResource[CustomerCustomerMeter] */
        ListResource_CustomerCustomerMeter_: {
            /** Items */
            items: components["schemas"]["CustomerCustomerMeter"][];
            pagination: components["schemas"]["Pagination"];
        };
        /** ListResource[CustomerMeter] */
        ListResource_CustomerMeter_: {
            /** Items */
            items: components["schemas"]["CustomerMeter"][];
            pagination: components["schemas"]["Pagination"];
        };
        /** ListResource[CustomerOrder] */
        ListResource_CustomerOrder_: {
            /** Items */
            items: components["schemas"]["CustomerOrder"][];
            pagination: components["schemas"]["Pagination"];
        };
        /** ListResource[CustomerSubscription] */
        ListResource_CustomerSubscription_: {
            /** Items */
            items: components["schemas"]["CustomerSubscription"][];
            pagination: components["schemas"]["Pagination"];
        };
        /** ListResource[Customer] */
        ListResource_Customer_: {
            /** Items */
            items: components["schemas"]["Customer"][];
            pagination: components["schemas"]["Pagination"];
        };
        /** ListResource[Discount] */
        ListResource_Discount_: {
            /** Items */
            items: components["schemas"]["Discount"][];
            pagination: components["schemas"]["Pagination"];
        };
        /** ListResource[DownloadableRead] */
        ListResource_DownloadableRead_: {
            /** Items */
            items: components["schemas"]["DownloadableRead"][];
            pagination: components["schemas"]["Pagination"];
        };
        /** ListResource[EventName] */
        ListResource_EventName_: {
            /** Items */
            items: components["schemas"]["EventName"][];
            pagination: components["schemas"]["Pagination"];
        };
        /** ListResource[Event] */
        ListResource_Event_: {
            /** Items */
            items: components["schemas"]["Event"][];
            pagination: components["schemas"]["Pagination"];
        };
        /** ListResource[FileRead] */
        ListResource_FileRead_: {
            /** Items */
            items: (components["schemas"]["DownloadableFileRead"] | components["schemas"]["ProductMediaFileRead"] | components["schemas"]["OrganizationAvatarFileRead"])[];
            pagination: components["schemas"]["Pagination"];
        };
        /** ListResource[LicenseKeyRead] */
        ListResource_LicenseKeyRead_: {
            /** Items */
            items: components["schemas"]["LicenseKeyRead"][];
            pagination: components["schemas"]["Pagination"];
        };
        /** ListResource[Meter] */
        ListResource_Meter_: {
            /** Items */
            items: components["schemas"]["Meter"][];
            pagination: components["schemas"]["Pagination"];
        };
        /** ListResource[NotificationRecipientSchema] */
        ListResource_NotificationRecipientSchema_: {
            /** Items */
            items: components["schemas"]["NotificationRecipientSchema"][];
            pagination: components["schemas"]["Pagination"];
        };
        /** ListResource[OAuth2Client] */
        ListResource_OAuth2Client_: {
            /** Items */
            items: components["schemas"]["OAuth2Client"][];
            pagination: components["schemas"]["Pagination"];
        };
        /** ListResource[Order] */
        ListResource_Order_: {
            /** Items */
            items: components["schemas"]["Order"][];
            pagination: components["schemas"]["Pagination"];
        };
        /** ListResource[OrganizationAccessToken] */
        ListResource_OrganizationAccessToken_: {
            /** Items */
            items: components["schemas"]["OrganizationAccessToken"][];
            pagination: components["schemas"]["Pagination"];
        };
        /** ListResource[OrganizationMember] */
        ListResource_OrganizationMember_: {
            /** Items */
            items: components["schemas"]["OrganizationMember"][];
            pagination: components["schemas"]["Pagination"];
        };
        /** ListResource[Organization] */
        ListResource_Organization_: {
            /** Items */
            items: components["schemas"]["Organization"][];
            pagination: components["schemas"]["Pagination"];
        };
        /** ListResource[PersonalAccessToken] */
        ListResource_PersonalAccessToken_: {
            /** Items */
            items: components["schemas"]["PersonalAccessToken"][];
            pagination: components["schemas"]["Pagination"];
        };
        /** ListResource[Product] */
        ListResource_Product_: {
            /** Items */
            items: components["schemas"]["Product"][];
            pagination: components["schemas"]["Pagination"];
        };
        /** ListResource[Refund] */
        ListResource_Refund_: {
            /** Items */
            items: components["schemas"]["Refund"][];
            pagination: components["schemas"]["Pagination"];
        };
        /** ListResource[Subscription] */
        ListResource_Subscription_: {
            /** Items */
            items: components["schemas"]["Subscription"][];
            pagination: components["schemas"]["Pagination"];
        };
        /** ListResource[Transaction] */
        ListResource_Transaction_: {
            /** Items */
            items: components["schemas"]["Transaction"][];
            pagination: components["schemas"]["Pagination"];
        };
        /** ListResource[Union[PaymentMethodCard, PaymentMethodGeneric]] */
        ListResource_Union_PaymentMethodCard__PaymentMethodGeneric__: {
            /** Items */
            items: (components["schemas"]["PaymentMethodCard"] | components["schemas"]["PaymentMethodGeneric"])[];
            pagination: components["schemas"]["Pagination"];
        };
        /** ListResource[WebhookDelivery] */
        ListResource_WebhookDelivery_: {
            /** Items */
            items: components["schemas"]["WebhookDelivery"][];
            pagination: components["schemas"]["Pagination"];
        };
        /** ListResource[WebhookEndpoint] */
        ListResource_WebhookEndpoint_: {
            /** Items */
            items: components["schemas"]["WebhookEndpoint"][];
            pagination: components["schemas"]["Pagination"];
        };
        /** ListResource[] */
        ListResource__: {
            /** Items */
            items: components["schemas"]["Payment"][];
            pagination: components["schemas"]["Pagination"];
        };
        /** MagicLinkRequest */
        MagicLinkRequest: {
            /**
             * Email
             * Format: email
             */
            email: string;
            /** Return To */
            return_to?: string | null;
            attribution?: components["schemas"]["UserSignupAttribution"] | null;
        };
        /** MaintainerAccountReviewedNotification */
        MaintainerAccountReviewedNotification: {
            /**
             * Id
             * Format: uuid4
             */
            id: string;
            /**
             * Created At
             * Format: date-time
             */
            created_at: string;
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            type: "MaintainerAccountReviewedNotification";
            payload: components["schemas"]["MaintainerAccountReviewedNotificationPayload"];
        };
        /** MaintainerAccountReviewedNotificationPayload */
        MaintainerAccountReviewedNotificationPayload: {
            /** Account Type */
            account_type: string;
        };
        /** MaintainerAccountUnderReviewNotification */
        MaintainerAccountUnderReviewNotification: {
            /**
             * Id
             * Format: uuid4
             */
            id: string;
            /**
             * Created At
             * Format: date-time
             */
            created_at: string;
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            type: "MaintainerAccountUnderReviewNotification";
            payload: components["schemas"]["MaintainerAccountUnderReviewNotificationPayload"];
        };
        /** MaintainerAccountUnderReviewNotificationPayload */
        MaintainerAccountUnderReviewNotificationPayload: {
            /** Account Type */
            account_type: string;
        };
        /** MaintainerCreateAccountNotification */
        MaintainerCreateAccountNotification: {
            /**
             * Id
             * Format: uuid4
             */
            id: string;
            /**
             * Created At
             * Format: date-time
             */
            created_at: string;
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            type: "MaintainerCreateAccountNotification";
            payload: components["schemas"]["MaintainerCreateAccountNotificationPayload"];
        };
        /** MaintainerCreateAccountNotificationPayload */
        MaintainerCreateAccountNotificationPayload: {
            /** Organization Name */
            organization_name: string;
            /** Url */
            url: string;
        };
        /** MaintainerNewPaidSubscriptionNotification */
        MaintainerNewPaidSubscriptionNotification: {
            /**
             * Id
             * Format: uuid4
             */
            id: string;
            /**
             * Created At
             * Format: date-time
             */
            created_at: string;
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            type: "MaintainerNewPaidSubscriptionNotification";
            payload: components["schemas"]["MaintainerNewPaidSubscriptionNotificationPayload"];
        };
        /** MaintainerNewPaidSubscriptionNotificationPayload */
        MaintainerNewPaidSubscriptionNotificationPayload: {
            /** Subscriber Name */
            subscriber_name: string;
            /** Tier Name */
            tier_name: string;
            /** Tier Price Amount */
            tier_price_amount: number | null;
            /** Tier Price Recurring Interval */
            tier_price_recurring_interval: string;
            /** Tier Organization Name */
            tier_organization_name: string;
        };
        /** MaintainerNewProductSaleNotification */
        MaintainerNewProductSaleNotification: {
            /**
             * Id
             * Format: uuid4
             */
            id: string;
            /**
             * Created At
             * Format: date-time
             */
            created_at: string;
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            type: "MaintainerNewProductSaleNotification";
            payload: components["schemas"]["MaintainerNewProductSaleNotificationPayload"];
        };
        /** MaintainerNewProductSaleNotificationPayload */
        MaintainerNewProductSaleNotificationPayload: {
            /** Customer Name */
            customer_name: string;
            /** Product Name */
            product_name: string;
            /** Product Price Amount */
            product_price_amount: number;
            /** Organization Name */
            organization_name: string;
        };
        /** Meter */
        Meter: {
            /** Metadata */
            metadata: {
                [key: string]: string | number | boolean;
            };
            /**
             * Created At
             * Format: date-time
             * @description Creation timestamp of the object.
             */
            created_at: string;
            /**
             * Modified At
             * @description Last modification timestamp of the object.
             */
            modified_at: string | null;
            /**
             * Id
             * Format: uuid4
             * @description The ID of the object.
             */
            id: string;
            /**
             * Name
             * @description The name of the meter. Will be shown on customer's invoices and usage.
             */
            name: string;
            /** @description The filter to apply on events that'll be used to calculate the meter. */
            filter: components["schemas"]["Filter"];
            /**
             * Aggregation
             * @description The aggregation to apply on the filtered events to calculate the meter.
             */
            aggregation: components["schemas"]["CountAggregation"] | components["schemas"]["PropertyAggregation"];
            /**
             * Organization Id
             * Format: uuid4
             * @description The ID of the organization owning the meter.
             */
            organization_id: string;
        };
        /** MeterCreate */
        MeterCreate: {
            /**
             * Metadata
             * @description Key-value object allowing you to store additional information.
             *
             *     The key must be a string with a maximum length of **40 characters**.
             *     The value must be either:
             *
             *     * A string with a maximum length of **500 characters**
             *     * An integer
             *     * A floating-point number
             *     * A boolean
             *
             *     You can store up to **50 key-value pairs**.
             */
            metadata?: {
                [key: string]: string | number | boolean;
            };
            /**
             * Name
             * @description The name of the meter. Will be shown on customer's invoices and usage.
             */
            name: string;
            /** @description The filter to apply on events that'll be used to calculate the meter. */
            filter: components["schemas"]["Filter"];
            /**
             * Aggregation
             * @description The aggregation to apply on the filtered events to calculate the meter.
             */
            aggregation: components["schemas"]["CountAggregation"] | components["schemas"]["PropertyAggregation"];
            /**
             * Organization Id
             * @description The ID of the organization owning the meter. **Required unless you use an organization token.**
             */
            organization_id?: string | null;
        };
        /** MeterQuantities */
        MeterQuantities: {
            /** Quantities */
            quantities: components["schemas"]["MeterQuantity"][];
            /**
             * Total
             * @description The total quantity for the period.
             */
            total: number;
        };
        /** MeterQuantity */
        MeterQuantity: {
            /**
             * Timestamp
             * Format: date-time
             * @description The timestamp for the current period.
             */
            timestamp: string;
            /**
             * Quantity
             * @description The quantity for the current period.
             */
            quantity: number;
        };
        /**
         * MeterSortProperty
         * @enum {string}
         */
        MeterSortProperty: "created_at" | "-created_at" | "name" | "-name";
        /** MeterUpdate */
        MeterUpdate: {
            /**
             * Metadata
             * @description Key-value object allowing you to store additional information.
             *
             *     The key must be a string with a maximum length of **40 characters**.
             *     The value must be either:
             *
             *     * A string with a maximum length of **500 characters**
             *     * An integer
             *     * A floating-point number
             *     * A boolean
             *
             *     You can store up to **50 key-value pairs**.
             */
            metadata?: {
                [key: string]: string | number | boolean;
            };
            /**
             * Name
             * @description The name of the meter. Will be shown on customer's invoices and usage.
             */
            name?: string | null;
            /** @description The filter to apply on events that'll be used to calculate the meter. */
            filter?: components["schemas"]["Filter"] | null;
            /**
             * Aggregation
             * @description The aggregation to apply on the filtered events to calculate the meter.
             */
            aggregation?: (components["schemas"]["CountAggregation"] | components["schemas"]["PropertyAggregation"]) | null;
        };
        /**
         * Metric
         * @description Information about a metric.
         */
        Metric: {
            /**
             * Slug
             * @description Unique identifier for the metric.
             */
            slug: string;
            /**
             * Display Name
             * @description Human-readable name for the metric.
             */
            display_name: string;
            /** @description Type of the metric, useful to know the unit or format of the value. */
            type: components["schemas"]["MetricType"];
        };
        /** MetricPeriod */
        MetricPeriod: {
            /**
             * Timestamp
             * Format: date-time
             * @description Timestamp of this period data.
             */
            timestamp: string;
            /** Orders */
            orders: number;
            /** Revenue */
            revenue: number;
            /** Cumulative Revenue */
            cumulative_revenue: number;
            /** Average Order Value */
            average_order_value: number;
            /** One Time Products */
            one_time_products: number;
            /** One Time Products Revenue */
            one_time_products_revenue: number;
            /** New Subscriptions */
            new_subscriptions: number;
            /** New Subscriptions Revenue */
            new_subscriptions_revenue: number;
            /** Renewed Subscriptions */
            renewed_subscriptions: number;
            /** Renewed Subscriptions Revenue */
            renewed_subscriptions_revenue: number;
            /** Active Subscriptions */
            active_subscriptions: number;
            /** Monthly Recurring Revenue */
            monthly_recurring_revenue: number;
            /** Checkouts */
            checkouts: number;
            /** Succeeded Checkouts */
            succeeded_checkouts: number;
            /** Checkouts Conversion */
            checkouts_conversion: number;
        };
        /**
         * MetricType
         * @enum {string}
         */
        MetricType: "scalar" | "currency" | "percentage";
        /** Metrics */
        Metrics: {
            orders: components["schemas"]["Metric"];
            revenue: components["schemas"]["Metric"];
            cumulative_revenue: components["schemas"]["Metric"];
            average_order_value: components["schemas"]["Metric"];
            one_time_products: components["schemas"]["Metric"];
            one_time_products_revenue: components["schemas"]["Metric"];
            new_subscriptions: components["schemas"]["Metric"];
            new_subscriptions_revenue: components["schemas"]["Metric"];
            renewed_subscriptions: components["schemas"]["Metric"];
            renewed_subscriptions_revenue: components["schemas"]["Metric"];
            active_subscriptions: components["schemas"]["Metric"];
            monthly_recurring_revenue: components["schemas"]["Metric"];
            checkouts: components["schemas"]["Metric"];
            succeeded_checkouts: components["schemas"]["Metric"];
            checkouts_conversion: components["schemas"]["Metric"];
        };
        /**
         * MetricsIntervalLimit
         * @description Date interval limit to get metrics for a given interval.
         */
        MetricsIntervalLimit: {
            /**
             * Max Days
             * @description Maximum number of days for this interval.
             */
            max_days: number;
        };
        /**
         * MetricsIntervalsLimits
         * @description Date interval limits to get metrics for each interval.
         */
        MetricsIntervalsLimits: {
            /** @description Limits for the hour interval. */
            hour: components["schemas"]["MetricsIntervalLimit"];
            /** @description Limits for the day interval. */
            day: components["schemas"]["MetricsIntervalLimit"];
            /** @description Limits for the week interval. */
            week: components["schemas"]["MetricsIntervalLimit"];
            /** @description Limits for the month interval. */
            month: components["schemas"]["MetricsIntervalLimit"];
            /** @description Limits for the year interval. */
            year: components["schemas"]["MetricsIntervalLimit"];
        };
        /**
         * MetricsLimits
         * @description Date limits to get metrics.
         */
        MetricsLimits: {
            /**
             * Min Date
             * Format: date
             * @description Minimum date to get metrics.
             */
            min_date: string;
            /** @description Limits for each interval. */
            intervals: components["schemas"]["MetricsIntervalsLimits"];
        };
        /**
         * MetricsResponse
         * @description Metrics response schema.
         */
        MetricsResponse: {
            /**
             * Periods
             * @description List of data for each timestamp.
             */
            periods: components["schemas"]["MetricPeriod"][];
            /** @description Totals for the whole selected period. */
            totals: components["schemas"]["MetricsTotals"];
            /** @description Information about the returned metrics. */
            metrics: components["schemas"]["Metrics"];
        };
        /** MetricsTotals */
        MetricsTotals: {
            /** Orders */
            orders: number;
            /** Revenue */
            revenue: number;
            /** Cumulative Revenue */
            cumulative_revenue: number;
            /** Average Order Value */
            average_order_value: number;
            /** One Time Products */
            one_time_products: number;
            /** One Time Products Revenue */
            one_time_products_revenue: number;
            /** New Subscriptions */
            new_subscriptions: number;
            /** New Subscriptions Revenue */
            new_subscriptions_revenue: number;
            /** Renewed Subscriptions */
            renewed_subscriptions: number;
            /** Renewed Subscriptions Revenue */
            renewed_subscriptions_revenue: number;
            /** Active Subscriptions */
            active_subscriptions: number;
            /** Monthly Recurring Revenue */
            monthly_recurring_revenue: number;
            /** Checkouts */
            checkouts: number;
            /** Succeeded Checkouts */
            succeeded_checkouts: number;
            /** Checkouts Conversion */
            checkouts_conversion: number;
        };
        /** NotOpenCheckout */
        NotOpenCheckout: {
            /**
             * Error
             * @constant
             */
            error: "NotOpenCheckout";
            /** Detail */
            detail: string;
        };
        /** NotPermitted */
        NotPermitted: {
            /**
             * Error
             * @constant
             */
            error: "NotPermitted";
            /** Detail */
            detail: string;
        };
        /** NotificationRecipientCreate */
        NotificationRecipientCreate: {
            /** @description Platform of the notification recipient. */
            platform: components["schemas"]["NotificationRecipientPlatform"];
            /**
             * Expo Push Token
             * @description Expo push token for the notification recipient.
             */
            expo_push_token: string;
        };
        /**
         * NotificationRecipientPlatform
         * @enum {string}
         */
        NotificationRecipientPlatform: "ios" | "android";
        /** NotificationRecipientSchema */
        NotificationRecipientSchema: {
            /**
             * Created At
             * Format: date-time
             * @description Creation timestamp of the object.
             */
            created_at: string;
            /**
             * Modified At
             * @description Last modification timestamp of the object.
             */
            modified_at: string | null;
            /**
             * Id
             * Format: uuid4
             */
            id: string;
            /**
             * User Id
             * Format: uuid4
             * @description ID of the user the notification recipient belongs to.
             */
            user_id: string;
            /** @description Platform of the notification recipient. */
            platform: components["schemas"]["NotificationRecipientPlatform"];
            /**
             * Expo Push Token
             * @description Expo push token for the notification recipient.
             */
            expo_push_token: string;
        };
        /** NotificationsList */
        NotificationsList: {
            /** Notifications */
            notifications: (components["schemas"]["MaintainerAccountUnderReviewNotification"] | components["schemas"]["MaintainerAccountReviewedNotification"] | components["schemas"]["MaintainerNewPaidSubscriptionNotification"] | components["schemas"]["MaintainerNewProductSaleNotification"] | components["schemas"]["MaintainerCreateAccountNotification"])[];
            /** Last Read Notification Id */
            last_read_notification_id: string | null;
        };
        /** NotificationsMarkRead */
        NotificationsMarkRead: {
            /**
             * Notification Id
             * Format: uuid4
             */
            notification_id: string;
        };
        /** OAuth2Client */
        OAuth2Client: {
            /** Redirect Uris */
            redirect_uris: string[];
            /**
             * Token Endpoint Auth Method
             * @default client_secret_post
             * @enum {string}
             */
            token_endpoint_auth_method: "client_secret_basic" | "client_secret_post" | "none";
            /**
             * Grant Types
             * @default [
             *       "authorization_code",
             *       "refresh_token"
             *     ]
             */
            grant_types: ("authorization_code" | "refresh_token")[];
            /**
             * Response Types
             * @default [
             *       "code"
             *     ]
             */
            response_types: "code"[];
            /**
             * Scope
             * @default openid profile email user:read organizations:read organizations:write custom_fields:read custom_fields:write discounts:read discounts:write checkout_links:read checkout_links:write checkouts:read checkouts:write products:read products:write benefits:read benefits:write events:read events:write meters:read meters:write files:read files:write subscriptions:read subscriptions:write customers:read customers:write customer_meters:read customer_sessions:write orders:read refunds:read refunds:write payments:read metrics:read webhooks:read webhooks:write external_organizations:read license_keys:read license_keys:write repositories:read repositories:write issues:read issues:write customer_portal:read customer_portal:write notification_recipients:read notification_recipients:write
             */
            scope: string;
            /** Client Name */
            client_name: string;
            /** Client Uri */
            client_uri?: string | null;
            /** Logo Uri */
            logo_uri?: string | null;
            /** Tos Uri */
            tos_uri?: string | null;
            /** Policy Uri */
            policy_uri?: string | null;
            /**
             * Created At
             * Format: date-time
             * @description Creation timestamp of the object.
             */
            created_at: string;
            /**
             * Modified At
             * @description Last modification timestamp of the object.
             */
            modified_at: string | null;
            /** Client Id */
            client_id: string;
            /** Client Secret */
            client_secret: string;
            /** Client Id Issued At */
            client_id_issued_at: number;
            /** Client Secret Expires At */
            client_secret_expires_at: number;
        };
        /** OAuth2ClientConfiguration */
        OAuth2ClientConfiguration: {
            /** Redirect Uris */
            redirect_uris: string[];
            /**
             * Token Endpoint Auth Method
             * @default client_secret_post
             * @enum {string}
             */
            token_endpoint_auth_method: "client_secret_basic" | "client_secret_post" | "none";
            /**
             * Grant Types
             * @default [
             *       "authorization_code",
             *       "refresh_token"
             *     ]
             */
            grant_types: ("authorization_code" | "refresh_token")[];
            /**
             * Response Types
             * @default [
             *       "code"
             *     ]
             */
            response_types: "code"[];
            /**
             * Scope
             * @default openid profile email user:read organizations:read organizations:write custom_fields:read custom_fields:write discounts:read discounts:write checkout_links:read checkout_links:write checkouts:read checkouts:write products:read products:write benefits:read benefits:write events:read events:write meters:read meters:write files:read files:write subscriptions:read subscriptions:write customers:read customers:write customer_meters:read customer_sessions:write orders:read refunds:read refunds:write payments:read metrics:read webhooks:read webhooks:write external_organizations:read license_keys:read license_keys:write repositories:read repositories:write issues:read issues:write customer_portal:read customer_portal:write notification_recipients:read notification_recipients:write
             */
            scope: string;
            /** Client Name */
            client_name: string;
            /** Client Uri */
            client_uri?: string | null;
            /** Logo Uri */
            logo_uri?: string | null;
            /** Tos Uri */
            tos_uri?: string | null;
            /** Policy Uri */
            policy_uri?: string | null;
        };
        /** OAuth2ClientConfigurationUpdate */
        OAuth2ClientConfigurationUpdate: {
            /** Redirect Uris */
            redirect_uris: string[];
            /**
             * Token Endpoint Auth Method
             * @default client_secret_post
             * @enum {string}
             */
            token_endpoint_auth_method: "client_secret_basic" | "client_secret_post" | "none";
            /**
             * Grant Types
             * @default [
             *       "authorization_code",
             *       "refresh_token"
             *     ]
             */
            grant_types: ("authorization_code" | "refresh_token")[];
            /**
             * Response Types
             * @default [
             *       "code"
             *     ]
             */
            response_types: "code"[];
            /**
             * Scope
             * @default openid profile email user:read organizations:read organizations:write custom_fields:read custom_fields:write discounts:read discounts:write checkout_links:read checkout_links:write checkouts:read checkouts:write products:read products:write benefits:read benefits:write events:read events:write meters:read meters:write files:read files:write subscriptions:read subscriptions:write customers:read customers:write customer_meters:read customer_sessions:write orders:read refunds:read refunds:write payments:read metrics:read webhooks:read webhooks:write external_organizations:read license_keys:read license_keys:write repositories:read repositories:write issues:read issues:write customer_portal:read customer_portal:write notification_recipients:read notification_recipients:write
             */
            scope: string;
            /** Client Name */
            client_name: string;
            /** Client Uri */
            client_uri?: string | null;
            /** Logo Uri */
            logo_uri?: string | null;
            /** Tos Uri */
            tos_uri?: string | null;
            /** Policy Uri */
            policy_uri?: string | null;
            /** Client Id */
            client_id: string;
        };
        /** OAuth2ClientPublic */
        OAuth2ClientPublic: {
            /**
             * Created At
             * Format: date-time
             * @description Creation timestamp of the object.
             */
            created_at: string;
            /**
             * Modified At
             * @description Last modification timestamp of the object.
             */
            modified_at: string | null;
            /** Client Id */
            client_id: string;
            /** Client Name */
            client_name: string | null;
            /** Client Uri */
            client_uri: string | null;
            /** Logo Uri */
            logo_uri: string | null;
            /** Tos Uri */
            tos_uri: string | null;
            /** Policy Uri */
            policy_uri: string | null;
        };
        /** OAuthAccountRead */
        OAuthAccountRead: {
            /**
             * Created At
             * Format: date-time
             * @description Creation timestamp of the object.
             */
            created_at: string;
            /**
             * Modified At
             * @description Last modification timestamp of the object.
             */
            modified_at: string | null;
            platform: components["schemas"]["OAuthPlatform"];
            /** Account Id */
            account_id: string;
            /** Account Email */
            account_email: string;
            /** Account Username */
            account_username: string | null;
        };
        /**
         * OAuthPlatform
         * @enum {string}
         */
        OAuthPlatform: "github" | "github_repository_benefit" | "google";
        /** Order */
        Order: {
            /**
             * Id
             * Format: uuid4
             * @description The ID of the object.
             */
            id: string;
            /**
             * Created At
             * Format: date-time
             * @description Creation timestamp of the object.
             */
            created_at: string;
            /**
             * Modified At
             * @description Last modification timestamp of the object.
             */
            modified_at: string | null;
            status: components["schemas"]["OrderStatus"];
            /**
             * Paid
             * @description Whether the order has been paid for.
             */
            paid: boolean;
            /**
             * Subtotal Amount
             * @description Amount in cents, before discounts and taxes.
             */
            subtotal_amount: number;
            /**
             * Discount Amount
             * @description Discount amount in cents.
             */
            discount_amount: number;
            /**
             * Net Amount
             * @description Amount in cents, after discounts but before taxes.
             */
            net_amount: number;
            /**
             * Amount
             * @deprecated
             * @description Amount in cents, after discounts but before taxes.
             */
            amount: number;
            /**
             * Tax Amount
             * @description Sales tax amount in cents.
             */
            tax_amount: number;
            /**
             * Total Amount
             * @description Amount in cents, after discounts and taxes.
             */
            total_amount: number;
            /**
             * Refunded Amount
             * @description Amount refunded in cents.
             */
            refunded_amount: number;
            /**
             * Refunded Tax Amount
             * @description Sales tax refunded in cents.
             */
            refunded_tax_amount: number;
            /** Currency */
            currency: string;
            billing_reason: components["schemas"]["OrderBillingReason"];
            billing_address: components["schemas"]["Address"] | null;
            /**
             * Customer Id
             * Format: uuid4
             */
            customer_id: string;
            /**
             * Product Id
             * Format: uuid4
             */
            product_id: string;
            /** Discount Id */
            discount_id: string | null;
            /** Subscription Id */
            subscription_id: string | null;
            /** Checkout Id */
            checkout_id: string | null;
            /** Metadata */
            metadata: {
                [key: string]: string | number | boolean;
            };
            /**
             * Custom Field Data
             * @description Key-value object storing custom field values.
             */
            custom_field_data?: {
                [key: string]: string | number | boolean | null;
            };
            customer: components["schemas"]["OrderCustomer"];
            /**
             * User Id
             * Format: uuid4
             * @deprecated
             */
            user_id: string;
            product: components["schemas"]["OrderProduct"];
            /** Discount */
            discount: (components["schemas"]["DiscountFixedOnceForeverDurationBase"] | components["schemas"]["DiscountFixedRepeatDurationBase"] | components["schemas"]["DiscountPercentageOnceForeverDurationBase"] | components["schemas"]["DiscountPercentageRepeatDurationBase"]) | null;
            subscription: components["schemas"]["OrderSubscription"] | null;
            /**
             * Items
             * @description Line items composing the order.
             */
            items: components["schemas"]["OrderItemSchema"][];
        };
        /**
         * OrderBillingReason
         * @enum {string}
         */
        OrderBillingReason: "purchase" | "subscription_create" | "subscription_cycle" | "subscription_update";
        /** OrderCustomer */
        OrderCustomer: {
            /**
             * Id
             * Format: uuid4
             * @description The ID of the customer.
             */
            id: string;
            /**
             * Created At
             * Format: date-time
             * @description Creation timestamp of the object.
             */
            created_at: string;
            /**
             * Modified At
             * @description Last modification timestamp of the object.
             */
            modified_at: string | null;
            /** Metadata */
            metadata: {
                [key: string]: string | number | boolean;
            };
            /**
             * External Id
             * @description The ID of the customer in your system. This must be unique within the organization. Once set, it can't be updated.
             */
            external_id: string | null;
            /**
             * Email
             * @description The email address of the customer. This must be unique within the organization.
             */
            email: string;
            /**
             * Email Verified
             * @description Whether the customer email address is verified. The address is automatically verified when the customer accesses the customer portal using their email address.
             */
            email_verified: boolean;
            /**
             * Name
             * @description The name of the customer.
             */
            name: string | null;
            billing_address: components["schemas"]["Address"] | null;
            /** Tax Id */
            tax_id: [
                string,
                components["schemas"]["TaxIDFormat"]
            ] | null;
            /**
             * Organization Id
             * Format: uuid4
             * @description The ID of the organization owning the customer.
             */
            organization_id: string;
            /**
             * Deleted At
             * @description Timestamp for when the customer was soft deleted.
             */
            deleted_at: string | null;
            /** Avatar Url */
            readonly avatar_url: string;
        };
        /**
         * OrderInvoice
         * @description Order's invoice data.
         */
        OrderInvoice: {
            /**
             * Url
             * @description The URL to the invoice.
             */
            url: string;
        };
        /**
         * OrderItemSchema
         * @description An order line item.
         */
        OrderItemSchema: {
            /**
             * Created At
             * Format: date-time
             * @description Creation timestamp of the object.
             */
            created_at: string;
            /**
             * Modified At
             * @description Last modification timestamp of the object.
             */
            modified_at: string | null;
            /**
             * Id
             * Format: uuid4
             * @description The ID of the object.
             */
            id: string;
            /**
             * Label
             * @description Description of the line item charge.
             */
            label: string;
            /**
             * Amount
             * @description Amount in cents, before discounts and taxes.
             */
            amount: number;
            /**
             * Tax Amount
             * @description Sales tax amount in cents.
             */
            tax_amount: number;
            /**
             * Proration
             * @description Whether this charge is due to a proration.
             */
            proration: boolean;
            /**
             * Product Price Id
             * @description Associated price ID, if any.
             */
            product_price_id: string | null;
        };
        /** OrderProduct */
        OrderProduct: {
            /** Metadata */
            metadata: {
                [key: string]: string | number | boolean;
            };
            /**
             * Created At
             * Format: date-time
             * @description Creation timestamp of the object.
             */
            created_at: string;
            /**
             * Modified At
             * @description Last modification timestamp of the object.
             */
            modified_at: string | null;
            /**
             * Id
             * Format: uuid4
             * @description The ID of the product.
             */
            id: string;
            /**
             * Name
             * @description The name of the product.
             */
            name: string;
            /**
             * Description
             * @description The description of the product.
             */
            description: string | null;
            /** @description The recurring interval of the product. If `None`, the product is a one-time purchase. */
            recurring_interval: components["schemas"]["SubscriptionRecurringInterval"] | null;
            /**
             * Is Recurring
             * @description Whether the product is a subscription.
             */
            is_recurring: boolean;
            /**
             * Is Archived
             * @description Whether the product is archived and no longer available.
             */
            is_archived: boolean;
            /**
             * Organization Id
             * Format: uuid4
             * @description The ID of the organization owning the product.
             */
            organization_id: string;
        };
        /**
         * OrderSortProperty
         * @enum {string}
         */
        OrderSortProperty: "created_at" | "-created_at" | "amount" | "-amount" | "net_amount" | "-net_amount" | "customer" | "-customer" | "product" | "-product" | "discount" | "-discount" | "subscription" | "-subscription";
        /**
         * OrderStatus
         * @enum {string}
         */
        OrderStatus: "pending" | "paid" | "refunded" | "partially_refunded";
        /** OrderSubscription */
        OrderSubscription: {
            /** Metadata */
            metadata: {
                [key: string]: string | number | boolean;
            };
            /**
             * Created At
             * Format: date-time
             * @description Creation timestamp of the object.
             */
            created_at: string;
            /**
             * Modified At
             * @description Last modification timestamp of the object.
             */
            modified_at: string | null;
            /**
             * Id
             * Format: uuid4
             * @description The ID of the object.
             */
            id: string;
            /**
             * Amount
             * @description The amount of the subscription.
             */
            amount: number;
            /**
             * Currency
             * @description The currency of the subscription.
             */
            currency: string;
            /** @description The interval at which the subscription recurs. */
            recurring_interval: components["schemas"]["SubscriptionRecurringInterval"];
            /** @description The status of the subscription. */
            status: components["schemas"]["SubscriptionStatus"];
            /**
             * Current Period Start
             * Format: date-time
             * @description The start timestamp of the current billing period.
             */
            current_period_start: string;
            /**
             * Current Period End
             * @description The end timestamp of the current billing period.
             */
            current_period_end: string | null;
            /**
             * Cancel At Period End
             * @description Whether the subscription will be canceled at the end of the current period.
             */
            cancel_at_period_end: boolean;
            /**
             * Canceled At
             * @description The timestamp when the subscription was canceled. The subscription might still be active if `cancel_at_period_end` is `true`.
             */
            canceled_at: string | null;
            /**
             * Started At
             * @description The timestamp when the subscription started.
             */
            started_at: string | null;
            /**
             * Ends At
             * @description The timestamp when the subscription will end.
             */
            ends_at: string | null;
            /**
             * Ended At
             * @description The timestamp when the subscription ended.
             */
            ended_at: string | null;
            /**
             * Customer Id
             * Format: uuid4
             * @description The ID of the subscribed customer.
             */
            customer_id: string;
            /**
             * Product Id
             * Format: uuid4
             * @description The ID of the subscribed product.
             */
            product_id: string;
            /**
             * Discount Id
             * @description The ID of the applied discount, if any.
             */
            discount_id: string | null;
            /** Checkout Id */
            checkout_id: string | null;
            customer_cancellation_reason: components["schemas"]["CustomerCancellationReason"] | null;
            /** Customer Cancellation Comment */
            customer_cancellation_comment: string | null;
        };
        /** OrderUser */
        OrderUser: {
            /**
             * Id
             * Format: uuid4
             */
            id: string;
            /** Email */
            email: string;
            /** Public Name */
            public_name: string;
            /** Avatar Url */
            avatar_url?: string | null;
            /** Github Username */
            github_username?: string | null;
        };
        /** Organization */
        Organization: {
            /**
             * Created At
             * Format: date-time
             * @description Creation timestamp of the object.
             */
            created_at: string;
            /**
             * Modified At
             * @description Last modification timestamp of the object.
             */
            modified_at: string | null;
            /**
             * Id
             * Format: uuid4
             * @description The organization ID.
             */
            id: string;
            /**
             * Name
             * @description Organization name shown in checkout, customer portal, emails etc.
             */
            name: string;
            /**
             * Slug
             * @description Unique organization slug in checkout, customer portal and credit card statements.
             */
            slug: string;
            /**
             * Avatar Url
             * @description Avatar URL shown in checkout, customer portal, emails etc.
             */
            avatar_url: string | null;
            /**
             * Email
             * @description Public support email.
             */
            email: string | null;
            /**
             * Website
             * @description Official website of the organization.
             */
            website: string | null;
            /**
             * Socials
             * @description Links to social profiles.
             */
            socials: components["schemas"]["OrganizationSocialLink"][];
            /**
             * Details Submitted At
             * @description When the business details were submitted.
             */
            details_submitted_at: string | null;
            /** @description Organization feature settings */
            feature_settings: components["schemas"]["OrganizationFeatureSettings"] | null;
            /** @description Settings related to subscriptions management */
            subscription_settings: components["schemas"]["OrganizationSubscriptionSettings"];
        };
        /** OrganizationAccessToken */
        OrganizationAccessToken: {
            /**
             * Created At
             * Format: date-time
             * @description Creation timestamp of the object.
             */
            created_at: string;
            /**
             * Modified At
             * @description Last modification timestamp of the object.
             */
            modified_at: string | null;
            /**
             * Id
             * Format: uuid4
             */
            id: string;
            /** Scopes */
            scopes: components["schemas"]["Scope"][];
            /** Expires At */
            expires_at: string | null;
            /** Comment */
            comment: string;
            /** Last Used At */
            last_used_at: string | null;
            /**
             * Organization Id
             * Format: uuid4
             * @description The organization ID.
             */
            organization_id: string;
        };
        /** OrganizationAccessTokenCreate */
        OrganizationAccessTokenCreate: {
            /**
             * Organization Id
             * Format: uuid4
             */
            organization_id: string;
            /** Comment */
            comment: string;
            /** Expires In */
            expires_in?: string | null;
            /** Scopes */
            scopes: components["schemas"]["AvailableScope"][];
        };
        /** OrganizationAccessTokenCreateResponse */
        OrganizationAccessTokenCreateResponse: {
            organization_access_token: components["schemas"]["OrganizationAccessToken"];
            /** Token */
            token: string;
        };
        /**
         * OrganizationAccessTokenSortProperty
         * @enum {string}
         */
        OrganizationAccessTokenSortProperty: "created_at" | "-created_at" | "comment" | "-comment" | "last_used_at" | "-last_used_at" | "organization_id" | "-organization_id";
        /** OrganizationAccessTokenUpdate */
        OrganizationAccessTokenUpdate: {
            /** Comment */
            comment?: string | null;
            /** Scopes */
            scopes?: components["schemas"]["AvailableScope"][] | null;
        };
        /**
         * OrganizationAvatarFileCreate
         * @description Schema to create a file to be used as an organization avatar.
         */
        OrganizationAvatarFileCreate: {
            /** Organization Id */
            organization_id?: string | null;
            /** Name */
            name: string;
            /**
             * Mime Type
             * @description MIME type of the file. Only images are supported for this type of file.
             */
            mime_type: string;
            /**
             * Size
             * @description Size of the file. A maximum of 1 MB is allowed for this type of file.
             */
            size: number;
            /** Checksum Sha256 Base64 */
            checksum_sha256_base64?: string | null;
            upload: components["schemas"]["S3FileCreateMultipart"];
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            service: "organization_avatar";
            /** Version */
            version?: string | null;
        };
        /**
         * OrganizationAvatarFileRead
         * @description File to be used as an organization avatar.
         */
        OrganizationAvatarFileRead: {
            /**
             * Id
             * Format: uuid4
             * @description The ID of the object.
             */
            id: string;
            /**
             * Organization Id
             * Format: uuid4
             */
            organization_id: string;
            /** Name */
            name: string;
            /** Path */
            path: string;
            /** Mime Type */
            mime_type: string;
            /** Size */
            size: number;
            /** Storage Version */
            storage_version: string | null;
            /** Checksum Etag */
            checksum_etag: string | null;
            /** Checksum Sha256 Base64 */
            checksum_sha256_base64: string | null;
            /** Checksum Sha256 Hex */
            checksum_sha256_hex: string | null;
            /** Last Modified At */
            last_modified_at: string | null;
            /** Version */
            version: string | null;
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            service: "organization_avatar";
            /** Is Uploaded */
            is_uploaded: boolean;
            /**
             * Created At
             * Format: date-time
             */
            created_at: string;
            /** Size Readable */
            readonly size_readable: string;
            /** Public Url */
            readonly public_url: string;
        };
        /** OrganizationCreate */
        OrganizationCreate: {
            /** Name */
            name: string;
            /** Slug */
            slug: string;
            /** Avatar Url */
            avatar_url?: string | null;
            /**
             * Email
             * @description Public support email.
             */
            email?: string | null;
            /**
             * Website
             * @description Official website of the organization.
             */
            website?: string | null;
            /**
             * Socials
             * @description Link to social profiles.
             */
            socials?: components["schemas"]["OrganizationSocialLink"][] | null;
            /** @description Additional, private, business details Polar needs about active organizations for compliance (KYC). */
            details?: components["schemas"]["OrganizationDetails"] | null;
            feature_settings?: components["schemas"]["OrganizationFeatureSettings"] | null;
            subscription_settings?: components["schemas"]["OrganizationSubscriptionSettings"] | null;
        };
        /** OrganizationDetails */
        OrganizationDetails: {
            /**
             * About
             * @description Brief information about you and your business.
             */
            about: string;
            /**
             * Product Description
             * @description Description of digital products being sold.
             */
            product_description: string;
            /**
             * Intended Use
             * @description How the organization will integrate and use Polar.
             */
            intended_use: string;
            /**
             * Customer Acquisition
             * @description Main customer acquisition channels.
             */
            customer_acquisition: string[];
            /**
             * Future Annual Revenue
             * @description Estimated revenue in the next 12 months
             */
            future_annual_revenue: number;
            /**
             * Switching
             * @description Switching from another platform?
             * @default true
             */
            switching: boolean;
            /**
             * Switching From
             * @description Which platform the organization is migrating from.
             */
            switching_from?: ("paddle" | "lemon_squeezy" | "gumroad" | "stripe" | "other") | null;
            /**
             * Previous Annual Revenue
             * @description Revenue from last year if applicable.
             * @default 0
             */
            previous_annual_revenue: number;
        };
        /** OrganizationFeatureSettings */
        OrganizationFeatureSettings: {
            /**
             * Issue Funding Enabled
             * @description If this organization has issue funding enabled
             * @default false
             */
            issue_funding_enabled: boolean;
            /**
             * Usage Based Billing Enabled
             * @description If this organization has usage-based billing enabled
             * @default false
             */
            usage_based_billing_enabled: boolean;
        };
        /** OrganizationMember */
        OrganizationMember: {
            /** Email */
            email: string;
            /** Avatar Url */
            avatar_url: string | null;
        };
        /** OrganizationProfileSettings */
        OrganizationProfileSettings: {
            /**
             * Enabled
             * @description If this organization has a profile enabled
             */
            enabled?: boolean | null;
            /**
             * Description
             * @description A description of the organization
             */
            description?: string | null;
            /**
             * Featured Projects
             * @description A list of featured projects
             */
            featured_projects?: string[] | null;
            /**
             * Featured Organizations
             * @description A list of featured organizations
             */
            featured_organizations?: string[] | null;
            /**
             * Links
             * @description A list of links associated with the organization
             */
            links?: string[] | null;
            /**
             * @description Subscription promotion settings
             * @default {
             *       "promote": true,
             *       "show_count": true,
             *       "count_free": true
             *     }
             */
            subscribe: components["schemas"]["OrganizationSubscribePromoteSettings"] | null;
            /**
             * Accent Color
             * @description Accent color for the organization
             */
            accent_color?: string | null;
        };
        /** OrganizationSetAccount */
        OrganizationSetAccount: {
            /**
             * Account Id
             * Format: uuid4
             */
            account_id: string;
        };
        /** OrganizationSocialLink */
        OrganizationSocialLink: {
            /** @description The social platform of the URL */
            platform: components["schemas"]["OrganizationSocialPlatforms"];
            /**
             * Url
             * Format: uri
             * @description The URL to the organization profile
             */
            url: string;
        };
        /**
         * OrganizationSocialPlatforms
         * @enum {string}
         */
        OrganizationSocialPlatforms: "x" | "github" | "facebook" | "instagram" | "youtube" | "tiktok" | "linkedin" | "other";
        /**
         * OrganizationSortProperty
         * @enum {string}
         */
        OrganizationSortProperty: "created_at" | "-created_at" | "slug" | "-slug" | "name" | "-name";
        /** OrganizationSubscribePromoteSettings */
        OrganizationSubscribePromoteSettings: {
            /**
             * Promote
             * @description Promote email subscription (free)
             * @default true
             */
            promote: boolean;
            /**
             * Show Count
             * @description Show subscription count publicly
             * @default true
             */
            show_count: boolean;
            /**
             * Count Free
             * @description Include free subscribers in total count
             * @default true
             */
            count_free: boolean;
        };
        /** OrganizationSubscriptionSettings */
        OrganizationSubscriptionSettings: {
            /** Allow Multiple Subscriptions */
            allow_multiple_subscriptions: boolean;
            /** Allow Customer Updates */
            allow_customer_updates: boolean;
            proration_behavior: components["schemas"]["SubscriptionProrationBehavior"];
        };
        /** OrganizationUpdate */
        OrganizationUpdate: {
            /** Name */
            name?: string | null;
            /** Avatar Url */
            avatar_url?: string | null;
            /**
             * Email
             * @description Public support email.
             */
            email?: string | null;
            /**
             * Website
             * @description Official website of the organization.
             */
            website?: string | null;
            /**
             * Socials
             * @description Links to social profiles.
             */
            socials?: components["schemas"]["OrganizationSocialLink"][] | null;
            /** @description Additional, private, business details Polar needs about active organizations for compliance (KYC). */
            details?: components["schemas"]["OrganizationDetails"] | null;
            feature_settings?: components["schemas"]["OrganizationFeatureSettings"] | null;
            subscription_settings?: components["schemas"]["OrganizationSubscriptionSettings"] | null;
        };
        /** Pagination */
        Pagination: {
            /** Total Count */
            total_count: number;
            /** Max Page */
            max_page: number;
        };
        Payment: components["schemas"]["CardPayment"] | components["schemas"]["GenericPayment"];
        /** PaymentError */
        PaymentError: {
            /**
             * Error
             * @constant
             */
            error: "PaymentError";
            /** Detail */
            detail: string;
        };
        /** PaymentMethodCard */
        PaymentMethodCard: {
            /** Id */
            id: string;
            /**
             * Type
             * @constant
             */
            type: "card";
            /**
             * Created At
             * Format: date-time
             */
            created_at: string;
            /** Default */
            default: boolean;
            card: components["schemas"]["PaymentMethodCardData"];
        };
        /** PaymentMethodCardData */
        PaymentMethodCardData: {
            /** Brand */
            brand: string;
            /** Last4 */
            last4: string;
            /** Exp Month */
            exp_month: number;
            /** Exp Year */
            exp_year: number;
            /** Wallet */
            wallet?: string | null;
        };
        /** PaymentMethodGeneric */
        PaymentMethodGeneric: {
            /** Id */
            id: string;
            /** Type */
            type: string;
            /**
             * Created At
             * Format: date-time
             */
            created_at: string;
            /** Default */
            default: boolean;
        };
        /**
         * PaymentProcessor
         * @enum {string}
         */
        PaymentProcessor: "stripe";
        /**
         * PaymentSortProperty
         * @enum {string}
         */
        PaymentSortProperty: "created_at" | "-created_at" | "status" | "-status" | "amount" | "-amount" | "method" | "-method";
        /**
         * PaymentStatus
         * @enum {string}
         */
        PaymentStatus: "pending" | "succeeded" | "failed";
        /** PayoutCreate */
        PayoutCreate: {
            /**
             * Account Id
             * Format: uuid4
             */
            account_id: string;
        };
        /** PayoutEstimate */
        PayoutEstimate: {
            /**
             * Account Id
             * Format: uuid4
             */
            account_id: string;
            /** Gross Amount */
            gross_amount: number;
            /** Fees Amount */
            fees_amount: number;
            /** Net Amount */
            net_amount: number;
        };
        /** PersonalAccessToken */
        PersonalAccessToken: {
            /**
             * Created At
             * Format: date-time
             * @description Creation timestamp of the object.
             */
            created_at: string;
            /**
             * Modified At
             * @description Last modification timestamp of the object.
             */
            modified_at: string | null;
            /**
             * Id
             * Format: uuid4
             */
            id: string;
            /** Scopes */
            scopes: components["schemas"]["Scope"][];
            /** Expires At */
            expires_at: string | null;
            /** Comment */
            comment: string;
            /** Last Used At */
            last_used_at: string | null;
        };
        /**
         * PlatformFeeType
         * @description Type of fees applied by Polar, and billed to the users.
         * @enum {string}
         */
        PlatformFeeType: "payment" | "international_payment" | "subscription" | "invoice" | "cross_border_transfer" | "payout" | "account" | "dispute" | "platform";
        /**
         * PledgeState
         * @enum {string}
         */
        PledgeState: "initiated" | "created" | "pending" | "refunded" | "disputed" | "charge_disputed" | "cancelled";
        /**
         * Processor
         * @description Supported payment or payout processors, i.e rails for transactions.
         * @enum {string}
         */
        Processor: "stripe" | "open_collective";
        /**
         * Product
         * @description A product.
         */
        Product: {
            /**
             * Created At
             * Format: date-time
             * @description Creation timestamp of the object.
             */
            created_at: string;
            /**
             * Modified At
             * @description Last modification timestamp of the object.
             */
            modified_at: string | null;
            /**
             * Id
             * Format: uuid4
             * @description The ID of the product.
             */
            id: string;
            /**
             * Name
             * @description The name of the product.
             */
            name: string;
            /**
             * Description
             * @description The description of the product.
             */
            description: string | null;
            /** @description The recurring interval of the product. If `None`, the product is a one-time purchase. */
            recurring_interval: components["schemas"]["SubscriptionRecurringInterval"] | null;
            /**
             * Is Recurring
             * @description Whether the product is a subscription.
             */
            is_recurring: boolean;
            /**
             * Is Archived
             * @description Whether the product is archived and no longer available.
             */
            is_archived: boolean;
            /**
             * Organization Id
             * Format: uuid4
             * @description The ID of the organization owning the product.
             */
            organization_id: string;
            /** Metadata */
            metadata: {
                [key: string]: string | number | boolean;
            };
            /**
             * Prices
             * @description List of prices for this product.
             */
            prices: (components["schemas"]["LegacyRecurringProductPrice"] | components["schemas"]["ProductPrice"])[];
            /**
             * Benefits
             * @description List of benefits granted by the product.
             */
            benefits: components["schemas"]["Benefit"][];
            /**
             * Medias
             * @description List of medias associated to the product.
             */
            medias: components["schemas"]["ProductMediaFileRead"][];
            /**
             * Attached Custom Fields
             * @description List of custom fields attached to the product.
             */
            attached_custom_fields: components["schemas"]["AttachedCustomField"][];
        };
        /**
         * ProductBenefitsUpdate
         * @description Schema to update the benefits granted by a product.
         */
        ProductBenefitsUpdate: {
            /**
             * Benefits
             * @description List of benefit IDs. Each one must be on the same organization as the product.
             */
            benefits: string[];
        };
        /**
         * ProductBillingType
         * @enum {string}
         */
        ProductBillingType: "one_time" | "recurring";
        /**
         * ProductCreate
         * @description Schema to create a product.
         */
        ProductCreate: {
            /**
             * Metadata
             * @description Key-value object allowing you to store additional information.
             *
             *     The key must be a string with a maximum length of **40 characters**.
             *     The value must be either:
             *
             *     * A string with a maximum length of **500 characters**
             *     * An integer
             *     * A floating-point number
             *     * A boolean
             *
             *     You can store up to **50 key-value pairs**.
             */
            metadata?: {
                [key: string]: string | number | boolean;
            };
            /**
             * Name
             * @description The name of the product.
             */
            name: string;
            /**
             * Description
             * @description The description of the product.
             */
            description?: string | null;
            /** @description The recurring interval of the product. If `None`, the product is a one-time purchase. */
            recurring_interval: components["schemas"]["SubscriptionRecurringInterval"] | null;
            /**
             * ProductPriceCreateList
             * @description List of available prices for this product. It should contain at most one static price (fixed, custom or free), and any number of metered prices. Metered prices are not supported on one-time purchase products.
             */
            prices: (components["schemas"]["ProductPriceFixedCreate"] | components["schemas"]["ProductPriceCustomCreate"] | components["schemas"]["ProductPriceFreeCreate"] | components["schemas"]["ProductPriceMeteredUnitCreate"])[];
            /**
             * Medias
             * @description List of file IDs. Each one must be on the same organization as the product, of type `product_media` and correctly uploaded.
             */
            medias?: string[] | null;
            /**
             * Attached Custom Fields
             * @description List of custom fields to attach.
             */
            attached_custom_fields?: components["schemas"]["AttachedCustomFieldCreate"][];
            /**
             * Organization Id
             * @description The ID of the organization owning the product. **Required unless you use an organization token.**
             */
            organization_id?: string | null;
        };
        /** ProductEmbed */
        ProductEmbed: {
            /**
             * Id
             * Format: uuid4
             */
            id: string;
            /** Name */
            name: string;
            /** Description */
            description: string | null;
            /** Is Recurring */
            is_recurring: boolean;
            recurring_interval: components["schemas"]["SubscriptionRecurringInterval"] | null;
            /**
             * Organization Id
             * Format: uuid4
             */
            organization_id: string;
            /** Price */
            price: components["schemas"]["LegacyRecurringProductPrice"] | components["schemas"]["ProductPrice"];
            cover: components["schemas"]["ProductMediaFileRead"] | null;
            /**
             * Benefits
             * @description List of benefits granted by the product.
             */
            benefits: components["schemas"]["Benefit"][];
            /** Etag */
            etag: string;
        };
        /**
         * ProductMediaFileCreate
         * @description Schema to create a file to be used as a product media file.
         */
        ProductMediaFileCreate: {
            /** Organization Id */
            organization_id?: string | null;
            /** Name */
            name: string;
            /**
             * Mime Type
             * @description MIME type of the file. Only images are supported for this type of file.
             */
            mime_type: string;
            /**
             * Size
             * @description Size of the file. A maximum of 10 MB is allowed for this type of file.
             */
            size: number;
            /** Checksum Sha256 Base64 */
            checksum_sha256_base64?: string | null;
            upload: components["schemas"]["S3FileCreateMultipart"];
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            service: "product_media";
            /** Version */
            version?: string | null;
        };
        /**
         * ProductMediaFileRead
         * @description File to be used as a product media file.
         */
        ProductMediaFileRead: {
            /**
             * Id
             * Format: uuid4
             * @description The ID of the object.
             */
            id: string;
            /**
             * Organization Id
             * Format: uuid4
             */
            organization_id: string;
            /** Name */
            name: string;
            /** Path */
            path: string;
            /** Mime Type */
            mime_type: string;
            /** Size */
            size: number;
            /** Storage Version */
            storage_version: string | null;
            /** Checksum Etag */
            checksum_etag: string | null;
            /** Checksum Sha256 Base64 */
            checksum_sha256_base64: string | null;
            /** Checksum Sha256 Hex */
            checksum_sha256_hex: string | null;
            /** Last Modified At */
            last_modified_at: string | null;
            /** Version */
            version: string | null;
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            service: "product_media";
            /** Is Uploaded */
            is_uploaded: boolean;
            /**
             * Created At
             * Format: date-time
             */
            created_at: string;
            /** Size Readable */
            readonly size_readable: string;
            /** Public Url */
            readonly public_url: string;
        };
        ProductPrice: components["schemas"]["ProductPriceFixed"] | components["schemas"]["ProductPriceCustom"] | components["schemas"]["ProductPriceFree"] | components["schemas"]["ProductPriceMeteredUnit"];
        /**
         * ProductPriceCustom
         * @description A pay-what-you-want price for a product.
         */
        ProductPriceCustom: {
            /**
             * Created At
             * Format: date-time
             * @description Creation timestamp of the object.
             */
            created_at: string;
            /**
             * Modified At
             * @description Last modification timestamp of the object.
             */
            modified_at: string | null;
            /**
             * Id
             * Format: uuid4
             * @description The ID of the price.
             */
            id: string;
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            amount_type: "custom";
            /**
             * Is Archived
             * @description Whether the price is archived and no longer available.
             */
            is_archived: boolean;
            /**
             * Product Id
             * Format: uuid4
             * @description The ID of the product owning the price.
             */
            product_id: string;
            /** @deprecated */
            type: components["schemas"]["ProductPriceType"];
            /** @deprecated */
            recurring_interval: components["schemas"]["SubscriptionRecurringInterval"] | null;
            /**
             * Price Currency
             * @description The currency.
             */
            price_currency: string;
            /**
             * Minimum Amount
             * @description The minimum amount the customer can pay.
             */
            minimum_amount: number | null;
            /**
             * Maximum Amount
             * @description The maximum amount the customer can pay.
             */
            maximum_amount: number | null;
            /**
             * Preset Amount
             * @description The initial amount shown to the customer.
             */
            preset_amount: number | null;
        };
        /**
         * ProductPriceCustomCreate
         * @description Schema to create a pay-what-you-want price.
         */
        ProductPriceCustomCreate: {
            /**
             * Amount Type
             * @constant
             */
            amount_type: "custom";
            /**
             * Price Currency
             * @description The currency. Currently, only `usd` is supported.
             * @default usd
             */
            price_currency: string;
            /**
             * Minimum Amount
             * @description The minimum amount the customer can pay.
             */
            minimum_amount?: number | null;
            /**
             * Maximum Amount
             * @description The maximum amount the customer can pay.
             */
            maximum_amount?: number | null;
            /**
             * Preset Amount
             * @description The initial amount shown to the customer.
             */
            preset_amount?: number | null;
        };
        /**
         * ProductPriceFixed
         * @description A fixed price for a product.
         */
        ProductPriceFixed: {
            /**
             * Created At
             * Format: date-time
             * @description Creation timestamp of the object.
             */
            created_at: string;
            /**
             * Modified At
             * @description Last modification timestamp of the object.
             */
            modified_at: string | null;
            /**
             * Id
             * Format: uuid4
             * @description The ID of the price.
             */
            id: string;
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            amount_type: "fixed";
            /**
             * Is Archived
             * @description Whether the price is archived and no longer available.
             */
            is_archived: boolean;
            /**
             * Product Id
             * Format: uuid4
             * @description The ID of the product owning the price.
             */
            product_id: string;
            /** @deprecated */
            type: components["schemas"]["ProductPriceType"];
            /** @deprecated */
            recurring_interval: components["schemas"]["SubscriptionRecurringInterval"] | null;
            /**
             * Price Currency
             * @description The currency.
             */
            price_currency: string;
            /**
             * Price Amount
             * @description The price in cents.
             */
            price_amount: number;
        };
        /**
         * ProductPriceFixedCreate
         * @description Schema to create a fixed price.
         */
        ProductPriceFixedCreate: {
            /**
             * Amount Type
             * @constant
             */
            amount_type: "fixed";
            /**
             * Price Amount
             * @description The price in cents.
             */
            price_amount: number;
            /**
             * Price Currency
             * @description The currency. Currently, only `usd` is supported.
             * @default usd
             */
            price_currency: string;
        };
        /**
         * ProductPriceFree
         * @description A free price for a product.
         */
        ProductPriceFree: {
            /**
             * Created At
             * Format: date-time
             * @description Creation timestamp of the object.
             */
            created_at: string;
            /**
             * Modified At
             * @description Last modification timestamp of the object.
             */
            modified_at: string | null;
            /**
             * Id
             * Format: uuid4
             * @description The ID of the price.
             */
            id: string;
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            amount_type: "free";
            /**
             * Is Archived
             * @description Whether the price is archived and no longer available.
             */
            is_archived: boolean;
            /**
             * Product Id
             * Format: uuid4
             * @description The ID of the product owning the price.
             */
            product_id: string;
            /** @deprecated */
            type: components["schemas"]["ProductPriceType"];
            /** @deprecated */
            recurring_interval: components["schemas"]["SubscriptionRecurringInterval"] | null;
        };
        /**
         * ProductPriceFreeCreate
         * @description Schema to create a free price.
         */
        ProductPriceFreeCreate: {
            /**
             * Amount Type
             * @constant
             */
            amount_type: "free";
        };
        /**
         * ProductPriceMeter
         * @description A meter associated to a metered price.
         */
        ProductPriceMeter: {
            /**
             * Id
             * Format: uuid4
             * @description The ID of the object.
             */
            id: string;
            /**
             * Name
             * @description The name of the meter.
             */
            name: string;
        };
        /**
         * ProductPriceMeteredUnit
         * @description A metered, usage-based, price for a product, with a fixed unit price.
         */
        ProductPriceMeteredUnit: {
            /**
             * Created At
             * Format: date-time
             * @description Creation timestamp of the object.
             */
            created_at: string;
            /**
             * Modified At
             * @description Last modification timestamp of the object.
             */
            modified_at: string | null;
            /**
             * Id
             * Format: uuid4
             * @description The ID of the price.
             */
            id: string;
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            amount_type: "metered_unit";
            /**
             * Is Archived
             * @description Whether the price is archived and no longer available.
             */
            is_archived: boolean;
            /**
             * Product Id
             * Format: uuid4
             * @description The ID of the product owning the price.
             */
            product_id: string;
            /** @deprecated */
            type: components["schemas"]["ProductPriceType"];
            /** @deprecated */
            recurring_interval: components["schemas"]["SubscriptionRecurringInterval"] | null;
            /**
             * Price Currency
             * @description The currency.
             */
            price_currency: string;
            /**
             * Unit Amount
             * @description The price per unit in cents.
             */
            unit_amount: string;
            /**
             * Cap Amount
             * @description The maximum amount in cents that can be charged, regardless of the number of units consumed.
             */
            cap_amount: number | null;
            /**
             * Meter Id
             * Format: uuid4
             * @description The ID of the meter associated to the price.
             */
            meter_id: string;
            /** @description The meter associated to the price. */
            meter: components["schemas"]["ProductPriceMeter"];
        };
        /**
         * ProductPriceMeteredUnitCreate
         * @description Schema to create a metered price with a fixed unit price.
         */
        ProductPriceMeteredUnitCreate: {
            /**
             * Amount Type
             * @constant
             */
            amount_type: "metered_unit";
            /**
             * Meter Id
             * Format: uuid4
             * @description The ID of the meter associated to the price.
             */
            meter_id: string;
            /**
             * Price Currency
             * @description The currency. Currently, only `usd` is supported.
             * @default usd
             */
            price_currency: string;
            /**
             * Unit Amount
             * @description The price per unit in cents. Supports up to 12 decimal places.
             */
            unit_amount: number | string;
            /**
             * Cap Amount
             * @description Optional maximum amount in cents that can be charged, regardless of the number of units consumed.
             */
            cap_amount?: number | null;
        };
        /**
         * ProductPriceType
         * @enum {string}
         */
        ProductPriceType: "one_time" | "recurring";
        /**
         * ProductSortProperty
         * @enum {string}
         */
        ProductSortProperty: "created_at" | "-created_at" | "name" | "-name" | "price_amount_type" | "-price_amount_type" | "price_amount" | "-price_amount";
        /**
         * ProductStorefront
         * @description Schema of a public product.
         */
        ProductStorefront: {
            /**
             * Created At
             * Format: date-time
             * @description Creation timestamp of the object.
             */
            created_at: string;
            /**
             * Modified At
             * @description Last modification timestamp of the object.
             */
            modified_at: string | null;
            /**
             * Id
             * Format: uuid4
             * @description The ID of the product.
             */
            id: string;
            /**
             * Name
             * @description The name of the product.
             */
            name: string;
            /**
             * Description
             * @description The description of the product.
             */
            description: string | null;
            /** @description The recurring interval of the product. If `None`, the product is a one-time purchase. */
            recurring_interval: components["schemas"]["SubscriptionRecurringInterval"] | null;
            /**
             * Is Recurring
             * @description Whether the product is a subscription.
             */
            is_recurring: boolean;
            /**
             * Is Archived
             * @description Whether the product is archived and no longer available.
             */
            is_archived: boolean;
            /**
             * Organization Id
             * Format: uuid4
             * @description The ID of the organization owning the product.
             */
            organization_id: string;
            /**
             * Prices
             * @description List of available prices for this product.
             */
            prices: (components["schemas"]["LegacyRecurringProductPrice"] | components["schemas"]["ProductPrice"])[];
            /**
             * BenefitPublic
             * @description The benefits granted by the product.
             */
            benefits: components["schemas"]["BenefitPublic"][];
            /**
             * Medias
             * @description The medias associated to the product.
             */
            medias: components["schemas"]["ProductMediaFileRead"][];
        };
        /**
         * ProductUpdate
         * @description Schema to update a product.
         */
        ProductUpdate: {
            /**
             * Metadata
             * @description Key-value object allowing you to store additional information.
             *
             *     The key must be a string with a maximum length of **40 characters**.
             *     The value must be either:
             *
             *     * A string with a maximum length of **500 characters**
             *     * An integer
             *     * A floating-point number
             *     * A boolean
             *
             *     You can store up to **50 key-value pairs**.
             */
            metadata?: {
                [key: string]: string | number | boolean;
            };
            /** Name */
            name?: string | null;
            /**
             * Description
             * @description The description of the product.
             */
            description?: string | null;
            /** @description The recurring interval of the product. If `None`, the product is a one-time purchase. **Can only be set on legacy recurring products. Once set, it can't be changed.** */
            recurring_interval?: components["schemas"]["SubscriptionRecurringInterval"] | null;
            /**
             * Is Archived
             * @description Whether the product is archived. If `true`, the product won't be available for purchase anymore. Existing customers will still have access to their benefits, and subscriptions will continue normally.
             */
            is_archived?: boolean | null;
            /**
             * Prices
             * @description List of available prices for this product. If you want to keep existing prices, include them in the list as an `ExistingProductPrice` object.
             */
            prices?: (components["schemas"]["ExistingProductPrice"] | components["schemas"]["ProductPriceFixedCreate"] | components["schemas"]["ProductPriceCustomCreate"] | components["schemas"]["ProductPriceFreeCreate"] | components["schemas"]["ProductPriceMeteredUnitCreate"])[] | null;
            /**
             * Medias
             * @description List of file IDs. Each one must be on the same organization as the product, of type `product_media` and correctly uploaded.
             */
            medias?: string[] | null;
            /** Attached Custom Fields */
            attached_custom_fields?: components["schemas"]["AttachedCustomFieldCreate"][] | null;
        };
        /** PropertyAggregation */
        PropertyAggregation: {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            func: "avg" | "max" | "min" | "sum";
            /** Property */
            property: string;
        };
        /** Refund */
        Refund: {
            /**
             * Created At
             * Format: date-time
             * @description Creation timestamp of the object.
             */
            created_at: string;
            /**
             * Modified At
             * @description Last modification timestamp of the object.
             */
            modified_at: string | null;
            /**
             * Id
             * Format: uuid4
             * @description The ID of the object.
             */
            id: string;
            /** Metadata */
            metadata: {
                [key: string]: string | number | boolean;
            };
            status: components["schemas"]["RefundStatus"];
            reason: components["schemas"]["RefundReason"];
            /** Amount */
            amount: number;
            /** Tax Amount */
            tax_amount: number;
            /** Currency */
            currency: string;
            /**
             * Organization Id
             * Format: uuid4
             */
            organization_id: string;
            /**
             * Order Id
             * Format: uuid4
             */
            order_id: string;
            /** Subscription Id */
            subscription_id: string | null;
            /**
             * Customer Id
             * Format: uuid4
             */
            customer_id: string;
            /** Revoke Benefits */
            revoke_benefits: boolean;
        };
        /** RefundAmountTooHigh */
        RefundAmountTooHigh: {
            /**
             * Error
             * @constant
             */
            error: "RefundAmountTooHigh";
            /** Detail */
            detail: string;
        };
        /** RefundCreate */
        RefundCreate: {
            /**
             * Metadata
             * @description Key-value object allowing you to store additional information.
             *
             *     The key must be a string with a maximum length of **40 characters**.
             *     The value must be either:
             *
             *     * A string with a maximum length of **500 characters**
             *     * An integer
             *     * A floating-point number
             *     * A boolean
             *
             *     You can store up to **50 key-value pairs**.
             */
            metadata?: {
                [key: string]: string | number | boolean;
            };
            /**
             * Order Id
             * Format: uuid4
             */
            order_id: string;
            reason: components["schemas"]["RefundReason"];
            /**
             * Amount
             * @description Amount to refund in cents. Minimum is 1.
             */
            amount: number;
            /**
             * Comment
             * @description An internal comment about the refund.
             */
            comment?: string | null;
            /**
             * Revoke Benefits
             * @description Should this refund trigger the associated customer benefits to be revoked?
             *
             *     **Note:**
             *     Only allowed in case the `order` is a one-time purchase.
             *     Subscriptions automatically revoke customer benefits once the
             *     subscription itself is revoked, i.e fully canceled.
             * @default false
             */
            revoke_benefits: boolean;
        };
        /**
         * RefundReason
         * @enum {string}
         */
        RefundReason: "duplicate" | "fraudulent" | "customer_request" | "service_disruption" | "satisfaction_guarantee" | "other";
        /**
         * RefundSortProperty
         * @enum {string}
         */
        RefundSortProperty: "created_at" | "-created_at" | "amount" | "-amount";
        /**
         * RefundStatus
         * @enum {string}
         */
        RefundStatus: "pending" | "succeeded" | "failed" | "canceled";
        /** RefundedAlready */
        RefundedAlready: {
            /**
             * Error
             * @constant
             */
            error: "RefundedAlready";
            /** Detail */
            detail: string;
        };
        /** ResourceNotFound */
        ResourceNotFound: {
            /**
             * Error
             * @constant
             */
            error: "ResourceNotFound";
            /** Detail */
            detail: string;
        };
        /** RevokeTokenResponse */
        RevokeTokenResponse: Record<string, never>;
        /** S3DownloadURL */
        S3DownloadURL: {
            /** Url */
            url: string;
            /**
             * Headers
             * @default {}
             */
            headers: {
                [key: string]: string;
            };
            /**
             * Expires At
             * Format: date-time
             */
            expires_at: string;
        };
        /** S3FileCreateMultipart */
        S3FileCreateMultipart: {
            /** Parts */
            parts: components["schemas"]["S3FileCreatePart"][];
        };
        /** S3FileCreatePart */
        S3FileCreatePart: {
            /** Number */
            number: number;
            /** Chunk Start */
            chunk_start: number;
            /** Chunk End */
            chunk_end: number;
            /** Checksum Sha256 Base64 */
            checksum_sha256_base64?: string | null;
        };
        /** S3FileUploadCompletedPart */
        S3FileUploadCompletedPart: {
            /** Number */
            number: number;
            /** Checksum Etag */
            checksum_etag: string;
            /** Checksum Sha256 Base64 */
            checksum_sha256_base64: string | null;
        };
        /** S3FileUploadMultipart */
        S3FileUploadMultipart: {
            /** Id */
            id: string;
            /** Path */
            path: string;
            /** Parts */
            parts: components["schemas"]["S3FileUploadPart"][];
        };
        /** S3FileUploadPart */
        S3FileUploadPart: {
            /** Number */
            number: number;
            /** Chunk Start */
            chunk_start: number;
            /** Chunk End */
            chunk_end: number;
            /** Checksum Sha256 Base64 */
            checksum_sha256_base64?: string | null;
            /** Url */
            url: string;
            /**
             * Expires At
             * Format: date-time
             */
            expires_at: string;
            /**
             * Headers
             * @default {}
             */
            headers: {
                [key: string]: string;
            };
        };
        /**
         * Scope
         * @enum {string}
         */
        Scope: "openid" | "profile" | "email" | "user:read" | "admin" | "web_default" | "organizations:read" | "organizations:write" | "custom_fields:read" | "custom_fields:write" | "discounts:read" | "discounts:write" | "checkout_links:read" | "checkout_links:write" | "checkouts:read" | "checkouts:write" | "products:read" | "products:write" | "benefits:read" | "benefits:write" | "events:read" | "events:write" | "meters:read" | "meters:write" | "files:read" | "files:write" | "subscriptions:read" | "subscriptions:write" | "customers:read" | "customers:write" | "customer_meters:read" | "customer_sessions:write" | "orders:read" | "refunds:read" | "refunds:write" | "payments:read" | "metrics:read" | "webhooks:read" | "webhooks:write" | "external_organizations:read" | "license_keys:read" | "license_keys:write" | "repositories:read" | "repositories:write" | "issues:read" | "issues:write" | "customer_portal:read" | "customer_portal:write" | "notification_recipients:read" | "notification_recipients:write";
        /**
         * Status
         * @enum {string}
         */
        Status: "created" | "onboarding_started" | "under_review" | "denied" | "active";
        /**
         * Storefront
         * @description Schema of a public storefront.
         */
        Storefront: {
            organization: components["schemas"]["Organization"];
            /** Products */
            products: components["schemas"]["ProductStorefront"][];
            donation_product: components["schemas"]["ProductStorefront"] | null;
            customers: components["schemas"]["StorefrontCustomers"];
        };
        /** StorefrontCustomer */
        StorefrontCustomer: {
            /** Name */
            name: string;
        };
        /** StorefrontCustomers */
        StorefrontCustomers: {
            /** Total */
            total: number;
            /** Customers */
            customers: components["schemas"]["StorefrontCustomer"][];
        };
        /**
         * SubType
         * @enum {string}
         */
        SubType: "user" | "organization";
        /** Subscription */
        Subscription: {
            /**
             * Created At
             * Format: date-time
             * @description Creation timestamp of the object.
             */
            created_at: string;
            /**
             * Modified At
             * @description Last modification timestamp of the object.
             */
            modified_at: string | null;
            /**
             * Id
             * Format: uuid4
             * @description The ID of the object.
             */
            id: string;
            /**
             * Amount
             * @description The amount of the subscription.
             */
            amount: number;
            /**
             * Currency
             * @description The currency of the subscription.
             */
            currency: string;
            /** @description The interval at which the subscription recurs. */
            recurring_interval: components["schemas"]["SubscriptionRecurringInterval"];
            /** @description The status of the subscription. */
            status: components["schemas"]["SubscriptionStatus"];
            /**
             * Current Period Start
             * Format: date-time
             * @description The start timestamp of the current billing period.
             */
            current_period_start: string;
            /**
             * Current Period End
             * @description The end timestamp of the current billing period.
             */
            current_period_end: string | null;
            /**
             * Cancel At Period End
             * @description Whether the subscription will be canceled at the end of the current period.
             */
            cancel_at_period_end: boolean;
            /**
             * Canceled At
             * @description The timestamp when the subscription was canceled. The subscription might still be active if `cancel_at_period_end` is `true`.
             */
            canceled_at: string | null;
            /**
             * Started At
             * @description The timestamp when the subscription started.
             */
            started_at: string | null;
            /**
             * Ends At
             * @description The timestamp when the subscription will end.
             */
            ends_at: string | null;
            /**
             * Ended At
             * @description The timestamp when the subscription ended.
             */
            ended_at: string | null;
            /**
             * Customer Id
             * Format: uuid4
             * @description The ID of the subscribed customer.
             */
            customer_id: string;
            /**
             * Product Id
             * Format: uuid4
             * @description The ID of the subscribed product.
             */
            product_id: string;
            /**
             * Discount Id
             * @description The ID of the applied discount, if any.
             */
            discount_id: string | null;
            /** Checkout Id */
            checkout_id: string | null;
            customer_cancellation_reason: components["schemas"]["CustomerCancellationReason"] | null;
            /** Customer Cancellation Comment */
            customer_cancellation_comment: string | null;
            /** Metadata */
            metadata: {
                [key: string]: string | number | boolean;
            };
            /**
             * Custom Field Data
             * @description Key-value object storing custom field values.
             */
            custom_field_data?: {
                [key: string]: string | number | boolean | null;
            };
            customer: components["schemas"]["SubscriptionCustomer"];
            product: components["schemas"]["Product"];
            /** Discount */
            discount: (components["schemas"]["DiscountFixedOnceForeverDurationBase"] | components["schemas"]["DiscountFixedRepeatDurationBase"] | components["schemas"]["DiscountPercentageOnceForeverDurationBase"] | components["schemas"]["DiscountPercentageRepeatDurationBase"]) | null;
            /**
             * Prices
             * @description List of enabled prices for the subscription.
             */
            prices: (components["schemas"]["LegacyRecurringProductPrice"] | components["schemas"]["ProductPrice"])[];
            /**
             * Meters
             * @description List of meters associated with the subscription.
             */
            meters: components["schemas"]["SubscriptionMeter"][];
        };
        /** SubscriptionCancel */
        SubscriptionCancel: {
            /** @description Customer reason for cancellation.
             *
             *     Helpful to monitor reasons behind churn for future improvements.
             *
             *     Only set this in case your own service is requesting the reason from the
             *     customer. Or you know based on direct conversations, i.e support, with
             *     the customer.
             *
             *     * `too_expensive`: Too expensive for the customer.
             *     * `missing_features`: Customer is missing certain features.
             *     * `switched_service`: Customer switched to another service.
             *     * `unused`: Customer is not using it enough.
             *     * `customer_service`: Customer is not satisfied with the customer service.
             *     * `low_quality`: Customer is unhappy with the quality.
             *     * `too_complex`: Customer considers the service too complicated.
             *     * `other`: Other reason(s). */
            customer_cancellation_reason?: components["schemas"]["CustomerCancellationReason"] | null;
            /**
             * Customer Cancellation Comment
             * @description Customer feedback and why they decided to cancel.
             *
             *     **IMPORTANT:**
             *     Do not use this to store internal notes! It's intended to be input
             *     from the customer and is therefore also available in their Polar
             *     purchases library.
             *
             *     Only set this in case your own service is requesting the reason from the
             *     customer. Or you copy a message directly from a customer
             *     conversation, i.e support.
             */
            customer_cancellation_comment?: string | null;
            /**
             * Cancel At Period End
             * @description Cancel an active subscription once the current period ends.
             *
             *     Or uncancel a subscription currently set to be revoked at period end.
             */
            cancel_at_period_end: boolean;
        };
        /** SubscriptionCustomer */
        SubscriptionCustomer: {
            /**
             * Id
             * Format: uuid4
             * @description The ID of the customer.
             */
            id: string;
            /**
             * Created At
             * Format: date-time
             * @description Creation timestamp of the object.
             */
            created_at: string;
            /**
             * Modified At
             * @description Last modification timestamp of the object.
             */
            modified_at: string | null;
            /** Metadata */
            metadata: {
                [key: string]: string | number | boolean;
            };
            /**
             * External Id
             * @description The ID of the customer in your system. This must be unique within the organization. Once set, it can't be updated.
             */
            external_id: string | null;
            /**
             * Email
             * @description The email address of the customer. This must be unique within the organization.
             */
            email: string;
            /**
             * Email Verified
             * @description Whether the customer email address is verified. The address is automatically verified when the customer accesses the customer portal using their email address.
             */
            email_verified: boolean;
            /**
             * Name
             * @description The name of the customer.
             */
            name: string | null;
            billing_address: components["schemas"]["Address"] | null;
            /** Tax Id */
            tax_id: [
                string,
                components["schemas"]["TaxIDFormat"]
            ] | null;
            /**
             * Organization Id
             * Format: uuid4
             * @description The ID of the organization owning the customer.
             */
            organization_id: string;
            /**
             * Deleted At
             * @description Timestamp for when the customer was soft deleted.
             */
            deleted_at: string | null;
            /** Avatar Url */
            readonly avatar_url: string;
        };
        /**
         * SubscriptionMeter
         * @description Current consumption and spending for a subscription meter.
         */
        SubscriptionMeter: {
            /**
             * Created At
             * Format: date-time
             * @description Creation timestamp of the object.
             */
            created_at: string;
            /**
             * Modified At
             * @description Last modification timestamp of the object.
             */
            modified_at: string | null;
            /**
             * Id
             * Format: uuid4
             * @description The ID of the object.
             */
            id: string;
            /**
             * Consumed Units
             * @description The number of consumed units so far in this billing period.
             */
            consumed_units: number;
            /**
             * Credited Units
             * @description The number of credited units so far in this billing period.
             */
            credited_units: number;
            /**
             * Amount
             * @description The amount due in cents so far in this billing period.
             */
            amount: number;
            /**
             * Meter Id
             * Format: uuid4
             * @description The ID of the meter.
             */
            meter_id: string;
            /** @description The meter associated with this subscription. */
            meter: components["schemas"]["Meter"];
        };
        /**
         * SubscriptionProrationBehavior
         * @enum {string}
         */
        SubscriptionProrationBehavior: "invoice" | "prorate";
        /**
         * SubscriptionRecurringInterval
         * @enum {string}
         */
        SubscriptionRecurringInterval: "month" | "year";
        /** SubscriptionRevoke */
        SubscriptionRevoke: {
            /** @description Customer reason for cancellation.
             *
             *     Helpful to monitor reasons behind churn for future improvements.
             *
             *     Only set this in case your own service is requesting the reason from the
             *     customer. Or you know based on direct conversations, i.e support, with
             *     the customer.
             *
             *     * `too_expensive`: Too expensive for the customer.
             *     * `missing_features`: Customer is missing certain features.
             *     * `switched_service`: Customer switched to another service.
             *     * `unused`: Customer is not using it enough.
             *     * `customer_service`: Customer is not satisfied with the customer service.
             *     * `low_quality`: Customer is unhappy with the quality.
             *     * `too_complex`: Customer considers the service too complicated.
             *     * `other`: Other reason(s). */
            customer_cancellation_reason?: components["schemas"]["CustomerCancellationReason"] | null;
            /**
             * Customer Cancellation Comment
             * @description Customer feedback and why they decided to cancel.
             *
             *     **IMPORTANT:**
             *     Do not use this to store internal notes! It's intended to be input
             *     from the customer and is therefore also available in their Polar
             *     purchases library.
             *
             *     Only set this in case your own service is requesting the reason from the
             *     customer. Or you copy a message directly from a customer
             *     conversation, i.e support.
             */
            customer_cancellation_comment?: string | null;
            /**
             * Revoke
             * @description Cancel and revoke an active subscription immediately
             * @constant
             */
            revoke: true;
        };
        /**
         * SubscriptionSortProperty
         * @enum {string}
         */
        SubscriptionSortProperty: "customer" | "-customer" | "status" | "-status" | "started_at" | "-started_at" | "current_period_end" | "-current_period_end" | "amount" | "-amount" | "product" | "-product" | "discount" | "-discount";
        /**
         * SubscriptionStatus
         * @enum {string}
         */
        SubscriptionStatus: "incomplete" | "incomplete_expired" | "trialing" | "active" | "past_due" | "canceled" | "unpaid";
        SubscriptionUpdate: components["schemas"]["SubscriptionUpdateProduct"] | components["schemas"]["SubscriptionCancel"] | components["schemas"]["SubscriptionRevoke"];
        /** SubscriptionUpdateProduct */
        SubscriptionUpdateProduct: {
            /**
             * Product Id
             * Format: uuid4
             * @description Update subscription to another product.
             */
            product_id: string;
            /** @description Determine how to handle the proration billing. If not provided, will use the default organization setting. */
            proration_behavior?: components["schemas"]["SubscriptionProrationBehavior"] | null;
        };
        /** SubscriptionUser */
        SubscriptionUser: {
            /**
             * Id
             * Format: uuid4
             */
            id: string;
            /** Email */
            email: string;
            /** Public Name */
            public_name: string;
            /** Avatar Url */
            avatar_url?: string | null;
            /** Github Username */
            github_username?: string | null;
        };
        /**
         * TaxIDFormat
         * @description List of supported tax ID formats.
         *
         *     Ref: https://docs.stripe.com/billing/customer/tax-ids#supported-tax-id
         * @enum {string}
         */
        TaxIDFormat: "ad_nrt" | "ae_trn" | "ar_cuit" | "au_abn" | "au_arn" | "bg_uic" | "bh_vat" | "bo_tin" | "br_cnpj" | "br_cpf" | "ca_bn" | "ca_gst_hst" | "ca_pst_bc" | "ca_pst_mb" | "ca_pst_sk" | "ca_qst" | "ch_uid" | "ch_vat" | "cl_tin" | "cn_tin" | "co_nit" | "cr_tin" | "de_stn" | "do_rcn" | "ec_ruc" | "eg_tin" | "es_cif" | "eu_oss_vat" | "eu_vat" | "gb_vat" | "ge_vat" | "hk_br" | "hr_oib" | "hu_tin" | "id_npwp" | "il_vat" | "in_gst" | "is_vat" | "jp_cn" | "jp_rn" | "jp_trn" | "ke_pin" | "kr_brn" | "kz_bin" | "li_uid" | "mx_rfc" | "my_frp" | "my_itn" | "my_sst" | "ng_tin" | "no_vat" | "no_voec" | "nz_gst" | "om_vat" | "pe_ruc" | "ph_tin" | "ro_tin" | "rs_pib" | "ru_inn" | "ru_kpp" | "sa_vat" | "sg_gst" | "sg_uen" | "si_tin" | "sv_nit" | "th_vat" | "tr_tin" | "tw_vat" | "ua_vat" | "us_ein" | "uy_ruc" | "ve_rif" | "vn_tin" | "za_vat";
        /**
         * TimeInterval
         * @enum {string}
         */
        TimeInterval: "year" | "month" | "week" | "day" | "hour";
        /** TokenResponse */
        TokenResponse: {
            /** Access Token */
            access_token: string;
            /**
             * Token Type
             * @constant
             */
            token_type: "Bearer";
            /** Expires In */
            expires_in: number;
            /** Refresh Token */
            refresh_token: string | null;
            /** Scope */
            scope: string;
            /** Id Token */
            id_token: string;
        };
        /** Transaction */
        Transaction: {
            /**
             * Created At
             * Format: date-time
             * @description Creation timestamp of the object.
             */
            created_at: string;
            /**
             * Modified At
             * @description Last modification timestamp of the object.
             */
            modified_at: string | null;
            /**
             * Id
             * Format: uuid4
             * @description The ID of the object.
             */
            id: string;
            type: components["schemas"]["TransactionType"];
            processor: components["schemas"]["Processor"] | null;
            /** Currency */
            currency: string;
            /** Amount */
            amount: number;
            /** Account Currency */
            account_currency: string;
            /** Account Amount */
            account_amount: number;
            platform_fee_type: components["schemas"]["PlatformFeeType"] | null;
            /** Pledge Id */
            pledge_id: string | null;
            /** Issue Reward Id */
            issue_reward_id: string | null;
            /** Order Id */
            order_id: string | null;
            /** Payout Transaction Id */
            payout_transaction_id: string | null;
            /** Incurred By Transaction Id */
            incurred_by_transaction_id: string | null;
            pledge: components["schemas"]["TransactionPledge"] | null;
            issue_reward: components["schemas"]["TransactionIssueReward"] | null;
            order: components["schemas"]["TransactionOrder"] | null;
            /** Account Incurred Transactions */
            account_incurred_transactions: components["schemas"]["TransactionEmbedded"][];
            /** Incurred Amount */
            incurred_amount: number;
            /** Gross Amount */
            gross_amount: number;
            /** Net Amount */
            net_amount: number;
        };
        /** TransactionDetails */
        TransactionDetails: {
            /**
             * Created At
             * Format: date-time
             * @description Creation timestamp of the object.
             */
            created_at: string;
            /**
             * Modified At
             * @description Last modification timestamp of the object.
             */
            modified_at: string | null;
            /**
             * Id
             * Format: uuid4
             * @description The ID of the object.
             */
            id: string;
            type: components["schemas"]["TransactionType"];
            processor: components["schemas"]["Processor"] | null;
            /** Currency */
            currency: string;
            /** Amount */
            amount: number;
            /** Account Currency */
            account_currency: string;
            /** Account Amount */
            account_amount: number;
            platform_fee_type: components["schemas"]["PlatformFeeType"] | null;
            /** Pledge Id */
            pledge_id: string | null;
            /** Issue Reward Id */
            issue_reward_id: string | null;
            /** Order Id */
            order_id: string | null;
            /** Payout Transaction Id */
            payout_transaction_id: string | null;
            /** Incurred By Transaction Id */
            incurred_by_transaction_id: string | null;
            pledge: components["schemas"]["TransactionPledge"] | null;
            issue_reward: components["schemas"]["TransactionIssueReward"] | null;
            order: components["schemas"]["TransactionOrder"] | null;
            /** Account Incurred Transactions */
            account_incurred_transactions: components["schemas"]["TransactionEmbedded"][];
            /** Incurred Amount */
            incurred_amount: number;
            /** Gross Amount */
            gross_amount: number;
            /** Net Amount */
            net_amount: number;
            /** Paid Transactions */
            paid_transactions: components["schemas"]["Transaction"][];
        };
        /** TransactionEmbedded */
        TransactionEmbedded: {
            /**
             * Created At
             * Format: date-time
             * @description Creation timestamp of the object.
             */
            created_at: string;
            /**
             * Modified At
             * @description Last modification timestamp of the object.
             */
            modified_at: string | null;
            /**
             * Id
             * Format: uuid4
             * @description The ID of the object.
             */
            id: string;
            type: components["schemas"]["TransactionType"];
            processor: components["schemas"]["Processor"] | null;
            /** Currency */
            currency: string;
            /** Amount */
            amount: number;
            /** Account Currency */
            account_currency: string;
            /** Account Amount */
            account_amount: number;
            platform_fee_type: components["schemas"]["PlatformFeeType"] | null;
            /** Pledge Id */
            pledge_id: string | null;
            /** Issue Reward Id */
            issue_reward_id: string | null;
            /** Order Id */
            order_id: string | null;
            /** Payout Transaction Id */
            payout_transaction_id: string | null;
            /** Incurred By Transaction Id */
            incurred_by_transaction_id: string | null;
        };
        /** TransactionIssueReward */
        TransactionIssueReward: {
            /**
             * Created At
             * Format: date-time
             * @description Creation timestamp of the object.
             */
            created_at: string;
            /**
             * Modified At
             * @description Last modification timestamp of the object.
             */
            modified_at: string | null;
            /**
             * Id
             * Format: uuid4
             * @description The ID of the object.
             */
            id: string;
            /** Issue Reference */
            issue_reference: string;
            /** Share Thousands */
            share_thousands: number;
        };
        /** TransactionOrder */
        TransactionOrder: {
            /**
             * Created At
             * Format: date-time
             * @description Creation timestamp of the object.
             */
            created_at: string;
            /**
             * Modified At
             * @description Last modification timestamp of the object.
             */
            modified_at: string | null;
            /**
             * Id
             * Format: uuid4
             * @description The ID of the object.
             */
            id: string;
            product: components["schemas"]["TransactionProduct"];
            /** Subscription Id */
            subscription_id: string | null;
        };
        /** TransactionOrganization */
        TransactionOrganization: {
            /**
             * Created At
             * Format: date-time
             * @description Creation timestamp of the object.
             */
            created_at: string;
            /**
             * Modified At
             * @description Last modification timestamp of the object.
             */
            modified_at: string | null;
            /**
             * Id
             * Format: uuid4
             * @description The ID of the object.
             */
            id: string;
            /** Name */
            name: string;
            /** Slug */
            slug: string;
            /** Avatar Url */
            avatar_url: string | null;
        };
        /** TransactionPledge */
        TransactionPledge: {
            /**
             * Created At
             * Format: date-time
             * @description Creation timestamp of the object.
             */
            created_at: string;
            /**
             * Modified At
             * @description Last modification timestamp of the object.
             */
            modified_at: string | null;
            /**
             * Id
             * Format: uuid4
             * @description The ID of the object.
             */
            id: string;
            state: components["schemas"]["PledgeState"];
            /** Issue Reference */
            issue_reference: string;
        };
        /** TransactionProduct */
        TransactionProduct: {
            /**
             * Created At
             * Format: date-time
             * @description Creation timestamp of the object.
             */
            created_at: string;
            /**
             * Modified At
             * @description Last modification timestamp of the object.
             */
            modified_at: string | null;
            /**
             * Id
             * Format: uuid4
             * @description The ID of the object.
             */
            id: string;
            /** Name */
            name: string;
            recurring_interval: components["schemas"]["SubscriptionRecurringInterval"] | null;
            /** Organization Id */
            organization_id: string | null;
            organization: components["schemas"]["TransactionOrganization"] | null;
        };
        /**
         * TransactionSortProperty
         * @enum {string}
         */
        TransactionSortProperty: "created_at" | "-created_at" | "amount" | "-amount";
        /**
         * TransactionType
         * @description Type of transactions.
         * @enum {string}
         */
        TransactionType: "payment" | "processor_fee" | "refund" | "refund_reversal" | "dispute" | "dispute_reversal" | "balance" | "payout";
        /** TransactionsBalance */
        TransactionsBalance: {
            /** Currency */
            currency: string;
            /** Amount */
            amount: number;
            /** Account Currency */
            account_currency: string;
            /** Account Amount */
            account_amount: number;
        };
        /** TransactionsSummary */
        TransactionsSummary: {
            balance: components["schemas"]["TransactionsBalance"];
            payout: components["schemas"]["TransactionsBalance"];
        };
        /** Unauthorized */
        Unauthorized: {
            /**
             * Error
             * @constant
             */
            error: "Unauthorized";
            /** Detail */
            detail: string;
        };
        /** UserBase */
        UserBase: {
            /**
             * Email
             * Format: email
             */
            email: string;
            /** Avatar Url */
            avatar_url: string | null;
            /** Account Id */
            account_id: string | null;
        };
        /** UserIdentityVerification */
        UserIdentityVerification: {
            /** Id */
            id: string;
            /** Client Secret */
            client_secret: string;
        };
        /** UserInfoOrganization */
        UserInfoOrganization: {
            /** Sub */
            sub: string;
            /** Name */
            name?: string | null;
        };
        /** UserInfoUser */
        UserInfoUser: {
            /** Sub */
            sub: string;
            /** Name */
            name?: string | null;
            /** Email */
            email?: string | null;
            /** Email Verified */
            email_verified?: boolean | null;
        };
        /** UserRead */
        UserRead: {
            /**
             * Created At
             * Format: date-time
             * @description Creation timestamp of the object.
             */
            created_at: string;
            /**
             * Modified At
             * @description Last modification timestamp of the object.
             */
            modified_at: string | null;
            /**
             * Email
             * Format: email
             */
            email: string;
            /** Avatar Url */
            avatar_url: string | null;
            /** Account Id */
            account_id: string | null;
            /**
             * Id
             * Format: uuid
             */
            id: string;
            /** Accepted Terms Of Service */
            accepted_terms_of_service: boolean;
            /** Identity Verified */
            identity_verified: boolean;
            identity_verification_status: components["schemas"]["IdentityVerificationStatus"];
            /** Oauth Accounts */
            oauth_accounts: components["schemas"]["OAuthAccountRead"][];
        };
        /** UserScopes */
        UserScopes: {
            /** Scopes */
            scopes: components["schemas"]["Scope"][];
        };
        /** UserSignupAttribution */
        UserSignupAttribution: {
            /** Intent */
            intent?: ("creator" | "pledge" | "purchase" | "subscription" | "newsletter_subscription") | null;
            /** Order */
            order?: string | null;
            /** Subscription */
            subscription?: string | null;
            /** Pledge */
            pledge?: string | null;
            /** From Storefront */
            from_storefront?: string | null;
            /** Path */
            path?: string | null;
            /** Host */
            host?: string | null;
            /** Utm Source */
            utm_source?: string | null;
            /** Utm Medium */
            utm_medium?: string | null;
            /** Utm Campaign */
            utm_campaign?: string | null;
            /** Campaign */
            campaign?: string | null;
        };
        /** UserStripePortalSession */
        UserStripePortalSession: {
            /** Url */
            url: string;
        };
        /** ValidatedLicenseKey */
        ValidatedLicenseKey: {
            /**
             * Id
             * Format: uuid4
             * @description The ID of the object.
             */
            id: string;
            /**
             * Created At
             * Format: date-time
             * @description Creation timestamp of the object.
             */
            created_at: string;
            /**
             * Modified At
             * @description Last modification timestamp of the object.
             */
            modified_at: string | null;
            /**
             * Organization Id
             * Format: uuid4
             */
            organization_id: string;
            /**
             * Customer Id
             * Format: uuid4
             */
            customer_id: string;
            customer: components["schemas"]["LicenseKeyCustomer"];
            /**
             * Benefit Id
             * Format: uuid4
             * @description The benefit ID.
             */
            benefit_id: string;
            /** Key */
            key: string;
            /** Display Key */
            display_key: string;
            status: components["schemas"]["LicenseKeyStatus"];
            /** Limit Activations */
            limit_activations: number | null;
            /** Usage */
            usage: number;
            /** Limit Usage */
            limit_usage: number | null;
            /** Validations */
            validations: number;
            /** Last Validated At */
            last_validated_at: string | null;
            /** Expires At */
            expires_at: string | null;
            activation?: components["schemas"]["LicenseKeyActivationBase"] | null;
        };
        /** ValidationError */
        ValidationError: {
            /** Location */
            loc: (string | number)[];
            /** Message */
            msg: string;
            /** Error Type */
            type: string;
        };
        /**
         * WebhookBenefitCreatedPayload
         * @description Sent when a new benefit is created.
         *
         *     **Discord & Slack support:** Basic
         */
        WebhookBenefitCreatedPayload: {
            /**
             * Type
             * @constant
             */
            type: "benefit.created";
            /** Benefit */
            data: components["schemas"]["Benefit"];
        };
        /**
         * WebhookBenefitGrantCreatedPayload
         * @description Sent when a new benefit grant is created.
         *
         *     **Discord & Slack support:** Basic
         */
        WebhookBenefitGrantCreatedPayload: {
            /**
             * Type
             * @constant
             */
            type: "benefit_grant.created";
            data: components["schemas"]["BenefitGrantWebhook"];
        };
        /**
         * WebhookBenefitGrantCycledPayload
         * @description Sent when a benefit grant is cycled,
         *     meaning the related subscription has been renewed for another period.
         *
         *     **Discord & Slack support:** Basic
         */
        WebhookBenefitGrantCycledPayload: {
            /**
             * Type
             * @constant
             */
            type: "benefit_grant.cycled";
            data: components["schemas"]["BenefitGrantWebhook"];
        };
        /**
         * WebhookBenefitGrantRevokedPayload
         * @description Sent when a benefit grant is revoked.
         *
         *     **Discord & Slack support:** Basic
         */
        WebhookBenefitGrantRevokedPayload: {
            /**
             * Type
             * @constant
             */
            type: "benefit_grant.revoked";
            data: components["schemas"]["BenefitGrantWebhook"];
        };
        /**
         * WebhookBenefitGrantUpdatedPayload
         * @description Sent when a benefit grant is updated.
         *
         *     **Discord & Slack support:** Basic
         */
        WebhookBenefitGrantUpdatedPayload: {
            /**
             * Type
             * @constant
             */
            type: "benefit_grant.updated";
            data: components["schemas"]["BenefitGrantWebhook"];
        };
        /**
         * WebhookBenefitUpdatedPayload
         * @description Sent when a benefit is updated.
         *
         *     **Discord & Slack support:** Basic
         */
        WebhookBenefitUpdatedPayload: {
            /**
             * Type
             * @constant
             */
            type: "benefit.updated";
            /** Benefit */
            data: components["schemas"]["Benefit"];
        };
        /**
         * WebhookCheckoutCreatedPayload
         * @description Sent when a new checkout is created.
         *
         *     **Discord & Slack support:** Basic
         */
        WebhookCheckoutCreatedPayload: {
            /**
             * Type
             * @constant
             */
            type: "checkout.created";
            data: components["schemas"]["Checkout"];
        };
        /**
         * WebhookCheckoutUpdatedPayload
         * @description Sent when a checkout is updated.
         *
         *     **Discord & Slack support:** Basic
         */
        WebhookCheckoutUpdatedPayload: {
            /**
             * Type
             * @constant
             */
            type: "checkout.updated";
            data: components["schemas"]["Checkout"];
        };
        /**
         * WebhookCustomerCreatedPayload
         * @description Sent when a new customer is created.
         *
         *     A customer can be created:
         *
         *     * After a successful checkout.
         *     * Programmatically via the API.
         *
         *     **Discord & Slack support:** Basic
         */
        WebhookCustomerCreatedPayload: {
            /**
             * Type
             * @constant
             */
            type: "customer.created";
            data: components["schemas"]["Customer"];
        };
        /**
         * WebhookCustomerDeletedPayload
         * @description Sent when a customer is deleted.
         *
         *     **Discord & Slack support:** Basic
         */
        WebhookCustomerDeletedPayload: {
            /**
             * Type
             * @constant
             */
            type: "customer.deleted";
            data: components["schemas"]["Customer"];
        };
        /**
         * WebhookCustomerStateChangedPayload
         * @description Sent when a customer state has changed.
         *
         *     It's triggered when:
         *
         *     * Customer is created, updated or deleted.
         *     * A subscription is created or updated.
         *     * A benefit is granted or revoked.
         *
         *     **Discord & Slack support:** Basic
         */
        WebhookCustomerStateChangedPayload: {
            /**
             * Type
             * @constant
             */
            type: "customer.state_changed";
            data: components["schemas"]["CustomerState"];
        };
        /**
         * WebhookCustomerUpdatedPayload
         * @description Sent when a customer is updated.
         *
         *     This event is fired when the customer details are updated.
         *
         *     If you want to be notified when a customer subscription or benefit state changes, you should listen to the `customer_state_changed` event.
         *
         *     **Discord & Slack support:** Basic
         */
        WebhookCustomerUpdatedPayload: {
            /**
             * Type
             * @constant
             */
            type: "customer.updated";
            data: components["schemas"]["Customer"];
        };
        /**
         * WebhookDelivery
         * @description A webhook delivery for a webhook event.
         */
        WebhookDelivery: {
            /**
             * Created At
             * Format: date-time
             * @description Creation timestamp of the object.
             */
            created_at: string;
            /**
             * Modified At
             * @description Last modification timestamp of the object.
             */
            modified_at: string | null;
            /**
             * Id
             * Format: uuid4
             * @description The webhook delivery ID.
             */
            id: string;
            /**
             * Http Code
             * @description The HTTP code returned by the URL. `null` if the endpoint was unreachable.
             */
            http_code?: number | null;
            /**
             * Succeeded
             * @description Whether the delivery was successful.
             */
            succeeded: boolean;
            /** @description The webhook event sent by this delivery. */
            webhook_event: components["schemas"]["WebhookEvent"];
        };
        /**
         * WebhookEndpoint
         * @description A webhook endpoint.
         */
        WebhookEndpoint: {
            /**
             * Created At
             * Format: date-time
             * @description Creation timestamp of the object.
             */
            created_at: string;
            /**
             * Modified At
             * @description Last modification timestamp of the object.
             */
            modified_at: string | null;
            /**
             * Id
             * Format: uuid4
             * @description The webhook endpoint ID.
             */
            id: string;
            /**
             * Url
             * Format: uri
             * @description The URL where the webhook events will be sent.
             */
            url: string;
            /** @description The format of the webhook payload. */
            format: components["schemas"]["WebhookFormat"];
            /**
             * Organization Id
             * Format: uuid4
             * @description The organization ID associated with the webhook endpoint.
             */
            organization_id: string;
            /**
             * Events
             * @description The events that will trigger the webhook.
             */
            events: components["schemas"]["WebhookEventType"][];
        };
        /**
         * WebhookEndpointCreate
         * @description Schema to create a webhook endpoint.
         */
        WebhookEndpointCreate: {
            /**
             * Url
             * Format: uri
             * @description The URL where the webhook events will be sent.
             */
            url: string;
            /** @description The format of the webhook payload. */
            format: components["schemas"]["WebhookFormat"];
            /**
             * Secret
             * @description The secret used to sign the webhook events.
             */
            secret: string;
            /**
             * Events
             * @description The events that will trigger the webhook.
             */
            events: components["schemas"]["WebhookEventType"][];
            /**
             * Organization Id
             * @description The organization ID associated with the webhook endpoint. **Required unless you use an organization token.**
             */
            organization_id?: string | null;
        };
        /**
         * WebhookEndpointUpdate
         * @description Schema to update a webhook endpoint.
         */
        WebhookEndpointUpdate: {
            /** Url */
            url?: string | null;
            format?: components["schemas"]["WebhookFormat"] | null;
            /** Secret */
            secret?: string | null;
            /** Events */
            events?: components["schemas"]["WebhookEventType"][] | null;
        };
        /**
         * WebhookEvent
         * @description A webhook event.
         *
         *     An event represent something that happened in the system
         *     that should be sent to the webhook endpoint.
         *
         *     It can be delivered multiple times until it's marked as succeeded,
         *     each one creating a new delivery.
         */
        WebhookEvent: {
            /**
             * Created At
             * Format: date-time
             * @description Creation timestamp of the object.
             */
            created_at: string;
            /**
             * Modified At
             * @description Last modification timestamp of the object.
             */
            modified_at: string | null;
            /**
             * Id
             * Format: uuid4
             * @description The webhook event ID.
             */
            id: string;
            /**
             * Last Http Code
             * @description Last HTTP code returned by the URL. `null` if no delviery has been attempted or if the endpoint was unreachable.
             */
            last_http_code?: number | null;
            /**
             * Succeeded
             * @description Whether this event was successfully delivered. `null` if no delivery has been attempted.
             */
            succeeded?: boolean | null;
            /**
             * Payload
             * @description The payload of the webhook event.
             */
            payload: string;
        };
        /**
         * WebhookEventType
         * @enum {string}
         */
        WebhookEventType: "checkout.created" | "checkout.updated" | "customer.created" | "customer.updated" | "customer.deleted" | "customer.state_changed" | "order.created" | "order.updated" | "order.paid" | "order.refunded" | "subscription.created" | "subscription.updated" | "subscription.active" | "subscription.canceled" | "subscription.uncanceled" | "subscription.revoked" | "refund.created" | "refund.updated" | "product.created" | "product.updated" | "benefit.created" | "benefit.updated" | "benefit_grant.created" | "benefit_grant.cycled" | "benefit_grant.updated" | "benefit_grant.revoked" | "organization.updated";
        /**
         * WebhookFormat
         * @enum {string}
         */
        WebhookFormat: "raw" | "discord" | "slack";
        /**
         * WebhookOrderCreatedPayload
         * @description Sent when a new order is created.
         *
         *     A new order is created when:
         *
         *     * A customer purchases a one-time product. In this case, `billing_reason` is set to `purchase`.
         *     * A customer starts a subscription. In this case, `billing_reason` is set to `subscription_create`.
         *     * A subscription is renewed. In this case, `billing_reason` is set to `subscription_cycle`.
         *     * A subscription is upgraded or downgraded with an immediate proration invoice. In this case, `billing_reason` is set to `subscription_update`.
         *
         *     <Warning>The order might not be paid yet, so the `status` field might be `pending`.</Warning>
         *
         *     **Discord & Slack support:** Full
         */
        WebhookOrderCreatedPayload: {
            /**
             * Type
             * @constant
             */
            type: "order.created";
            data: components["schemas"]["Order"];
        };
        /**
         * WebhookOrderPaidPayload
         * @description Sent when an order is paid.
         *
         *     When you receive this event, the order is fully processed and payment has been received.
         *
         *     **Discord & Slack support:** Full
         */
        WebhookOrderPaidPayload: {
            /**
             * Type
             * @constant
             */
            type: "order.paid";
            data: components["schemas"]["Order"];
        };
        /**
         * WebhookOrderRefundedPayload
         * @description Sent when an order is fully or partially refunded.
         *
         *     **Discord & Slack support:** Full
         */
        WebhookOrderRefundedPayload: {
            /**
             * Type
             * @constant
             */
            type: "order.refunded";
            data: components["schemas"]["Order"];
        };
        /**
         * WebhookOrderUpdatedPayload
         * @description Sent when an order is updated.
         *
         *     An order is updated when:
         *
         *     * Its status changes, e.g. from `pending` to `paid`.
         *     * It's refunded, partially or fully.
         *
         *     **Discord & Slack support:** Full
         */
        WebhookOrderUpdatedPayload: {
            /**
             * Type
             * @constant
             */
            type: "order.updated";
            data: components["schemas"]["Order"];
        };
        /**
         * WebhookOrganizationUpdatedPayload
         * @description Sent when a organization is updated.
         *
         *     **Discord & Slack support:** Basic
         */
        WebhookOrganizationUpdatedPayload: {
            /**
             * Type
             * @constant
             */
            type: "organization.updated";
            data: components["schemas"]["Organization"];
        };
        /**
         * WebhookProductCreatedPayload
         * @description Sent when a new product is created.
         *
         *     **Discord & Slack support:** Basic
         */
        WebhookProductCreatedPayload: {
            /**
             * Type
             * @constant
             */
            type: "product.created";
            data: components["schemas"]["Product"];
        };
        /**
         * WebhookProductUpdatedPayload
         * @description Sent when a product is updated.
         *
         *     **Discord & Slack support:** Basic
         */
        WebhookProductUpdatedPayload: {
            /**
             * Type
             * @constant
             */
            type: "product.updated";
            data: components["schemas"]["Product"];
        };
        /**
         * WebhookRefundCreatedPayload
         * @description Sent when a refund is created regardless of status.
         *
         *     **Discord & Slack support:** Full
         */
        WebhookRefundCreatedPayload: {
            /**
             * Type
             * @constant
             */
            type: "refund.created";
            data: components["schemas"]["Refund"];
        };
        /**
         * WebhookRefundUpdatedPayload
         * @description Sent when a refund is updated.
         *
         *     **Discord & Slack support:** Full
         */
        WebhookRefundUpdatedPayload: {
            /**
             * Type
             * @constant
             */
            type: "refund.updated";
            data: components["schemas"]["Refund"];
        };
        /**
         * WebhookSubscriptionActivePayload
         * @description Sent when a subscription becomes active,
         *     whether because it's a new paid subscription or because payment was recovered.
         *
         *     **Discord & Slack support:** Full
         */
        WebhookSubscriptionActivePayload: {
            /**
             * Type
             * @constant
             */
            type: "subscription.active";
            data: components["schemas"]["Subscription"];
        };
        /**
         * WebhookSubscriptionCanceledPayload
         * @description Sent when a subscription is canceled.
         *     Customers might still have access until the end of the current period.
         *
         *     **Discord & Slack support:** Full
         */
        WebhookSubscriptionCanceledPayload: {
            /**
             * Type
             * @constant
             */
            type: "subscription.canceled";
            data: components["schemas"]["Subscription"];
        };
        /**
         * WebhookSubscriptionCreatedPayload
         * @description Sent when a new subscription is created.
         *
         *     When this event occurs, the subscription `status` might not be `active` yet, as we can still have to wait for the first payment to be processed.
         *
         *     **Discord & Slack support:** Full
         */
        WebhookSubscriptionCreatedPayload: {
            /**
             * Type
             * @constant
             */
            type: "subscription.created";
            data: components["schemas"]["Subscription"];
        };
        /**
         * WebhookSubscriptionRevokedPayload
         * @description Sent when a subscription is revoked, the user loses access immediately.
         *     Happens when the subscription is canceled, or payment is past due.
         *
         *     **Discord & Slack support:** Full
         */
        WebhookSubscriptionRevokedPayload: {
            /**
             * Type
             * @constant
             */
            type: "subscription.revoked";
            data: components["schemas"]["Subscription"];
        };
        /**
         * WebhookSubscriptionUncanceledPayload
         * @description Sent when a subscription is uncanceled.
         *
         *     **Discord & Slack support:** Full
         */
        WebhookSubscriptionUncanceledPayload: {
            /**
             * Type
             * @constant
             */
            type: "subscription.uncanceled";
            data: components["schemas"]["Subscription"];
        };
        /**
         * WebhookSubscriptionUpdatedPayload
         * @description Sent when a subscription is updated. This event fires for all changes to the subscription, including renewals.
         *
         *     If you want more specific events, you can listen to `subscription.active`, `subscription.canceled`, and `subscription.revoked`.
         *
         *     To listen specifically for renewals, you can listen to `order.created` events and check the `billing_reason` field.
         *
         *     **Discord & Slack support:** On cancellation and revocation. Renewals are skipped.
         */
        WebhookSubscriptionUpdatedPayload: {
            /**
             * Type
             * @constant
             */
            type: "subscription.updated";
            data: components["schemas"]["Subscription"];
        };
        /** Body_magic_link:magic_link.authenticate */
        authenticate: {
            /** Token */
            token: string;
        };
        /** MetadataQuery */
        MetadataQuery: {
            [key: string]: string | number | boolean | string[] | number[] | boolean[];
        } | null;
        /** AuthorizationCodeTokenRequest */
        AuthorizationCodeTokenRequest: {
            /**
             * Grant Type
             * @constant
             */
            grant_type: "authorization_code";
            /** Client Id */
            client_id: string;
            /** Client Secret */
            client_secret: string;
            /** Code */
            code: string;
            /**
             * Redirect Uri
             * Format: uri
             */
            redirect_uri: string;
        };
        /** RefreshTokenRequest */
        RefreshTokenRequest: {
            /**
             * Grant Type
             * @constant
             */
            grant_type: "refresh_token";
            /** Client Id */
            client_id: string;
            /** Client Secret */
            client_secret: string;
            /** Refresh Token */
            refresh_token: string;
        };
        /** RevokeTokenRequest */
        RevokeTokenRequest: {
            /** Token */
            token: string;
            /**
             * Token Type Hint
             * @default null
             */
            token_type_hint: ("access_token" | "refresh_token") | null;
            /** Client Id */
            client_id: string;
            /** Client Secret */
            client_secret: string;
        };
        /** IntrospectTokenRequest */
        IntrospectTokenRequest: {
            /** Token */
            token: string;
            /**
             * Token Type Hint
             * @default null
             */
            token_type_hint: ("access_token" | "refresh_token") | null;
            /** Client Id */
            client_id: string;
            /** Client Secret */
            client_secret: string;
        };
    };
    responses: never;
    parameters: never;
    requestBodies: never;
    headers: never;
    pathItems: never;
}
export type $defs = Record<string, never>;
export interface operations {
    "users:get_authenticated": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["UserRead"];
                };
            };
        };
    };
    "users:scopes": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["UserScopes"];
                };
            };
        };
    };
    "users:create_identity_verification": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["UserIdentityVerification"];
                };
            };
        };
    };
    "users:create_stripe_customer_portal": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["UserStripePortalSession"];
                };
            };
        };
    };
    "integrations_github:integrations.github.authorize": {
        parameters: {
            query?: {
                payment_intent_id?: string | null;
                return_to?: string | null;
                attribution?: string | null;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "integrations_github:integrations.github.callback": {
        parameters: {
            query?: {
                code?: string | null;
                code_verifier?: string | null;
                state?: string | null;
                error?: string | null;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "integrations_github_repository_benefit:integrations.github_repository_benefit.user_authorize": {
        parameters: {
            query?: {
                return_to?: string | null;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "integrations_github_repository_benefit:integrations.github_repository_benefit.user_callback": {
        parameters: {
            query?: {
                code?: string | null;
                code_verifier?: string | null;
                state?: string | null;
                error?: string | null;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "integrations_github_repository_benefit:integrations.github_repository_benefit.user_repositories": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["GitHubInvitesBenefitRepositories"];
                };
            };
        };
    };
    "integrations_github_repository_benefit:integrations.github_repository_benefit.installation_install": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
        };
    };
    "integrations_github_repository_benefit:integrations.github_repository_benefit.installation_callback": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
        };
    };
    "integrations_discord:integrations.discord.bot_authorize": {
        parameters: {
            query?: {
                return_to?: string | null;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "integrations_discord:integrations.discord.bot_callback": {
        parameters: {
            query: {
                state: string;
                code?: string | null;
                code_verifier?: string | null;
                error?: string | null;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "integrations_discord:discord_guild_lookup": {
        parameters: {
            query: {
                guild_token: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DiscordGuild"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "magic_link:magic_link.request": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["MagicLinkRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            202: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "magic_link:magic_link.authenticate": {
        parameters: {
            query?: {
                return_to?: string | null;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/x-www-form-urlencoded": components["schemas"]["authenticate"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "notifications:get": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["NotificationsList"];
                };
            };
        };
    };
    "notifications:mark_read": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["NotificationsMarkRead"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "notifications:list": {
        parameters: {
            query?: {
                /** @description Filter by Expo push token. */
                expo_push_token?: string | null;
                /** @description Filter by platform. */
                platform?: components["schemas"]["NotificationRecipientPlatform"] | null;
                /** @description Page number, defaults to 1. */
                page?: number;
                /** @description Size of a page, defaults to 10. Maximum is 100. */
                limit?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ListResource_NotificationRecipientSchema_"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "notifications:create": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["NotificationRecipientCreate"];
            };
        };
        responses: {
            /** @description Device subscribed to notifications. */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["NotificationRecipientSchema"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "notifications:delete": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The notification recipient ID. */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Notification recipient unsubscribed from notifications. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Notification recipient not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "personal_access_token:list_personal_access_tokens": {
        parameters: {
            query?: {
                /** @description Page number, defaults to 1. */
                page?: number;
                /** @description Size of a page, defaults to 10. Maximum is 100. */
                limit?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ListResource_PersonalAccessToken_"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "personal_access_token:delete_personal_access_token": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "accounts:search": {
        parameters: {
            query?: {
                /** @description Page number, defaults to 1. */
                page?: number;
                /** @description Size of a page, defaults to 10. Maximum is 100. */
                limit?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ListResource_Account_"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "accounts:get": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Account"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "accounts:onboarding_link": {
        parameters: {
            query: {
                return_path: string;
            };
            header?: never;
            path: {
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AccountLink"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "accounts:dashboard_link": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AccountLink"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "accounts:create": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["AccountCreate"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Account"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "organizations:list": {
        parameters: {
            query?: {
                /** @description Filter by slug. */
                slug?: string | null;
                /** @description Page number, defaults to 1. */
                page?: number;
                /** @description Size of a page, defaults to 10. Maximum is 100. */
                limit?: number;
                /** @description Sorting criterion. Several criteria can be used simultaneously and will be applied in order. Add a minus sign `-` before the criteria name to sort by descending order. */
                sorting?: components["schemas"]["OrganizationSortProperty"][] | null;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ListResource_Organization_"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "organizations:create": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["OrganizationCreate"];
            };
        };
        responses: {
            /** @description Organization created. */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Organization"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "organizations:get": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Organization"];
                };
            };
            /** @description Organization not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ResourceNotFound"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "organizations:update": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                id: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["OrganizationUpdate"];
            };
        };
        responses: {
            /** @description Organization updated. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Organization"];
                };
            };
            /** @description You don't have the permission to update this organization. */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["NotPermitted"];
                };
            };
            /** @description Organization not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ResourceNotFound"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "organizations:get_account": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Account"];
                };
            };
            /** @description Organization not found or account not set. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ResourceNotFound"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "organizations:set_account": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                id: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["OrganizationSetAccount"];
            };
        };
        responses: {
            /** @description Organization account set. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Organization"];
                };
            };
            /** @description You don't have the permission to update this organization. */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["NotPermitted"];
                };
            };
            /** @description Organization not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ResourceNotFound"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "organizations:members": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ListResource_OrganizationMember_"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "subscriptions:list": {
        parameters: {
            query?: {
                /** @description Filter by organization ID. */
                organization_id?: string | string[] | null;
                /** @description Filter by product ID. */
                product_id?: string | string[] | null;
                /** @description Filter by customer ID. */
                customer_id?: string | string[] | null;
                /** @description Filter by discount ID. */
                discount_id?: string | string[] | null;
                /** @description Filter by active or inactive subscription. */
                active?: boolean | null;
                /** @description Page number, defaults to 1. */
                page?: number;
                /** @description Size of a page, defaults to 10. Maximum is 100. */
                limit?: number;
                /** @description Sorting criterion. Several criteria can be used simultaneously and will be applied in order. Add a minus sign `-` before the criteria name to sort by descending order. */
                sorting?: components["schemas"]["SubscriptionSortProperty"][] | null;
                /** @description Filter by metadata key-value pairs. It uses the `deepObject` style, e.g. `?metadata[key]=value`. */
                metadata?: components["schemas"]["MetadataQuery"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ListResource_Subscription_"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "subscriptions:export": {
        parameters: {
            query?: {
                /** @description Filter by organization ID. */
                organization_id?: string | string[] | null;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "subscriptions:get": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The subscription ID. */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Subscription"];
                };
            };
            /** @description Subscription not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ResourceNotFound"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "subscriptions:revoke": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The subscription ID. */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Subscription revoked. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Subscription"];
                };
            };
            /** @description This subscription is already revoked. */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AlreadyCanceledSubscription"];
                };
            };
            /** @description Subscription not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ResourceNotFound"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "subscriptions:update": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The subscription ID. */
                id: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["SubscriptionUpdate"];
            };
        };
        responses: {
            /** @description Subscription updated. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Subscription"];
                };
            };
            /** @description Subscription is already canceled or will be at the end of the period. */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AlreadyCanceledSubscription"];
                };
            };
            /** @description Subscription not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ResourceNotFound"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "transactions:search_transactions": {
        parameters: {
            query?: {
                type?: components["schemas"]["TransactionType"] | null;
                account_id?: string | null;
                payment_customer_id?: string | null;
                payment_organization_id?: string | null;
                payment_user_id?: string | null;
                exclude_platform_fees?: boolean;
                /** @description Page number, defaults to 1. */
                page?: number;
                /** @description Size of a page, defaults to 10. Maximum is 100. */
                limit?: number;
                /** @description Sorting criterion. Several criteria can be used simultaneously and will be applied in order. Add a minus sign `-` before the criteria name to sort by descending order. */
                sorting?: components["schemas"]["TransactionSortProperty"][] | null;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ListResource_Transaction_"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "transactions:lookup_transaction": {
        parameters: {
            query: {
                transaction_id: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TransactionDetails"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "transactions:get_summary": {
        parameters: {
            query: {
                account_id: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TransactionsSummary"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "transactions:get_payout_estimate": {
        parameters: {
            query: {
                account_id: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PayoutEstimate"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "transactions:create_payout": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["PayoutCreate"];
            };
        };
        responses: {
            /** @description Successful Response */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Transaction"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "transactions:get_payout_csv": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "auth:logout": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
        };
    };
    "oauth2:clients:list": {
        parameters: {
            query?: {
                /** @description Page number, defaults to 1. */
                page?: number;
                /** @description Size of a page, defaults to 10. Maximum is 100. */
                limit?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ListResource_OAuth2Client_"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "oauth2:clients:oauth2:create_client": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["OAuth2ClientConfiguration"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "oauth2:clients:oauth2:get_client": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                client_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "oauth2:clients:oauth2:update_client": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                client_id: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["OAuth2ClientConfigurationUpdate"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "oauth2:clients:oauth2:delete_client": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                client_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "oauth2:authorize": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AuthorizeResponseUser"] | components["schemas"]["AuthorizeResponseOrganization"];
                };
            };
        };
    };
    "oauth2:consent": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/x-www-form-urlencoded": components["schemas"]["Body_oauth2_consent"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "oauth2:request_token": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/x-www-form-urlencoded": components["schemas"]["AuthorizationCodeTokenRequest"] | components["schemas"]["RefreshTokenRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TokenResponse"];
                };
            };
        };
    };
    "oauth2:revoke_token": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/x-www-form-urlencoded": components["schemas"]["RevokeTokenRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["RevokeTokenResponse"];
                };
            };
        };
    };
    "oauth2:introspect_token": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/x-www-form-urlencoded": components["schemas"]["IntrospectTokenRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["IntrospectTokenResponse"];
                };
            };
        };
    };
    "oauth2:userinfo": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["UserInfoUser"] | components["schemas"]["UserInfoOrganization"];
                };
            };
        };
    };
    "benefits:list": {
        parameters: {
            query?: {
                /** @description Filter by organization ID. */
                organization_id?: string | string[] | null;
                /** @description Filter by benefit type. */
                type?: components["schemas"]["BenefitType"] | components["schemas"]["BenefitType"][] | null;
                /** @description Filter by description. */
                query?: string | null;
                /** @description Page number, defaults to 1. */
                page?: number;
                /** @description Size of a page, defaults to 10. Maximum is 100. */
                limit?: number;
                /** @description Sorting criterion. Several criteria can be used simultaneously and will be applied in order. Add a minus sign `-` before the criteria name to sort by descending order. */
                sorting?: components["schemas"]["BenefitSortProperty"][] | null;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ListResource_Benefit_"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "benefits:create": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["BenefitCreate"];
            };
        };
        responses: {
            /** @description Benefit created. */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Benefit"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "benefits:get": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Benefit"];
                };
            };
            /** @description Benefit not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ResourceNotFound"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "benefits:delete": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Benefit deleted. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description This benefit is not deletable. */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["NotPermitted"];
                };
            };
            /** @description Benefit not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ResourceNotFound"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "benefits:update": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                id: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["BenefitCustomUpdate"] | components["schemas"]["BenefitDiscordUpdate"] | components["schemas"]["BenefitGitHubRepositoryUpdate"] | components["schemas"]["BenefitDownloadablesUpdate"] | components["schemas"]["BenefitLicenseKeysUpdate"] | components["schemas"]["BenefitMeterCreditUpdate"];
            };
        };
        responses: {
            /** @description Benefit updated. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Benefit"];
                };
            };
            /** @description Benefit not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ResourceNotFound"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "benefits:grants": {
        parameters: {
            query?: {
                /** @description Filter by granted status. If `true`, only granted benefits will be returned. If `false`, only revoked benefits will be returned.  */
                is_granted?: boolean | null;
                /** @description Filter by customer. */
                customer_id?: string | string[] | null;
                /** @description Page number, defaults to 1. */
                page?: number;
                /** @description Size of a page, defaults to 10. Maximum is 100. */
                limit?: number;
            };
            header?: never;
            path: {
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ListResource_BenefitGrant_"];
                };
            };
            /** @description Benefit not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ResourceNotFound"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "webhooks:list_webhook_endpoints": {
        parameters: {
            query?: {
                /** @description Filter by organization ID. */
                organization_id?: string | null;
                /** @description Page number, defaults to 1. */
                page?: number;
                /** @description Size of a page, defaults to 10. Maximum is 100. */
                limit?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ListResource_WebhookEndpoint_"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "webhooks:create_webhook_endpoint": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["WebhookEndpointCreate"];
            };
        };
        responses: {
            /** @description Webhook endpoint created. */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["WebhookEndpoint"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "webhooks:get_webhook_endpoint": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The webhook endpoint ID. */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["WebhookEndpoint"];
                };
            };
            /** @description Webhook endpoint not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ResourceNotFound"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "webhooks:delete_webhook_endpoint": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The webhook endpoint ID. */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Webhook endpoint deleted. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description You don't have the permission to delete this webhook endpoint. */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["NotPermitted"];
                };
            };
            /** @description Webhook endpoint not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ResourceNotFound"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "webhooks:update_webhook_endpoint": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The webhook endpoint ID. */
                id: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["WebhookEndpointUpdate"];
            };
        };
        responses: {
            /** @description Webhook endpoint updated. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["WebhookEndpoint"];
                };
            };
            /** @description You don't have the permission to update this webhook endpoint. */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["NotPermitted"];
                };
            };
            /** @description Webhook endpoint not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ResourceNotFound"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "webhooks:list_webhook_deliveries": {
        parameters: {
            query?: {
                /** @description Filter by webhook endpoint ID. */
                endpoint_id?: string | null;
                /** @description Page number, defaults to 1. */
                page?: number;
                /** @description Size of a page, defaults to 10. Maximum is 100. */
                limit?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ListResource_WebhookDelivery_"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "webhooks:redeliver_webhook_event": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The webhook event ID. */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Webhook event re-delivery scheduled. */
            202: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Webhook event not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ResourceNotFound"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "products:list": {
        parameters: {
            query?: {
                /** @description Filter by product ID. */
                id?: string | string[] | null;
                /** @description Filter by organization ID. */
                organization_id?: string | string[] | null;
                /** @description Filter by product name. */
                query?: string | null;
                /** @description Filter on archived products. */
                is_archived?: boolean | null;
                /** @description Filter on recurring products. If `true`, only subscriptions tiers are returned. If `false`, only one-time purchase products are returned.  */
                is_recurring?: boolean | null;
                /** @description Filter products granting specific benefit. */
                benefit_id?: string | string[] | null;
                /** @description Page number, defaults to 1. */
                page?: number;
                /** @description Size of a page, defaults to 10. Maximum is 100. */
                limit?: number;
                /** @description Sorting criterion. Several criteria can be used simultaneously and will be applied in order. Add a minus sign `-` before the criteria name to sort by descending order. */
                sorting?: components["schemas"]["ProductSortProperty"][] | null;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ListResource_Product_"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "products:create": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["ProductCreate"];
            };
        };
        responses: {
            /** @description Product created. */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Product"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "products:get": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Product"];
                };
            };
            /** @description Product not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ResourceNotFound"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "products:update": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                id: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["ProductUpdate"];
            };
        };
        responses: {
            /** @description Product updated. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Product"];
                };
            };
            /** @description You don't have the permission to update this product. */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["NotPermitted"];
                };
            };
            /** @description Product not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ResourceNotFound"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "products:update_benefits": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                id: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["ProductBenefitsUpdate"];
            };
        };
        responses: {
            /** @description Product benefits updated. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Product"];
                };
            };
            /** @description You don't have the permission to update this product. */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["NotPermitted"];
                };
            };
            /** @description Product not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ResourceNotFound"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "orders:list": {
        parameters: {
            query?: {
                /** @description Filter by organization ID. */
                organization_id?: string | string[] | null;
                /** @description Filter by product ID. */
                product_id?: string | string[] | null;
                /** @description Filter by product billing type. `recurring` will filter data corresponding to subscriptions creations or renewals. `one_time` will filter data corresponding to one-time purchases. */
                product_billing_type?: components["schemas"]["ProductBillingType"] | components["schemas"]["ProductBillingType"][] | null;
                /** @description Filter by discount ID. */
                discount_id?: string | string[] | null;
                /** @description Filter by customer ID. */
                customer_id?: string | string[] | null;
                /** @description Filter by checkout ID. */
                checkout_id?: string | string[] | null;
                /** @description Page number, defaults to 1. */
                page?: number;
                /** @description Size of a page, defaults to 10. Maximum is 100. */
                limit?: number;
                /** @description Sorting criterion. Several criteria can be used simultaneously and will be applied in order. Add a minus sign `-` before the criteria name to sort by descending order. */
                sorting?: components["schemas"]["OrderSortProperty"][] | null;
                /** @description Filter by metadata key-value pairs. It uses the `deepObject` style, e.g. `?metadata[key]=value`. */
                metadata?: components["schemas"]["MetadataQuery"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ListResource_Order_"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "orders:get": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The order ID. */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Order"];
                };
            };
            /** @description Order not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ResourceNotFound"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "orders:invoice": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The order ID. */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["OrderInvoice"];
                };
            };
            /** @description Order not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ResourceNotFound"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "refunds:list": {
        parameters: {
            query?: {
                /** @description Filter by refund ID. */
                id?: string | string[] | null;
                /** @description Filter by organization ID. */
                organization_id?: string | string[] | null;
                /** @description Filter by order ID. */
                order_id?: string | string[] | null;
                /** @description Filter by subscription ID. */
                subscription_id?: string | string[] | null;
                /** @description Filter by customer ID. */
                customer_id?: string | string[] | null;
                /** @description Filter by `succeeded`. */
                succeeded?: boolean | null;
                /** @description Page number, defaults to 1. */
                page?: number;
                /** @description Size of a page, defaults to 10. Maximum is 100. */
                limit?: number;
                /** @description Sorting criterion. Several criteria can be used simultaneously and will be applied in order. Add a minus sign `-` before the criteria name to sort by descending order. */
                sorting?: components["schemas"]["RefundSortProperty"][] | null;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ListResource_Refund_"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "refunds:create": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["RefundCreate"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Refund"];
                };
            };
            /** @description Refund created. */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Refund amount exceeds remaining order balance. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["RefundAmountTooHigh"];
                };
            };
            /** @description Order is already fully refunded. */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["RefundedAlready"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "checkouts:list": {
        parameters: {
            query?: {
                /** @description Filter by organization ID. */
                organization_id?: string | string[] | null;
                /** @description Filter by product ID. */
                product_id?: string | string[] | null;
                /** @description Filter by customer ID. */
                customer_id?: string | string[] | null;
                /** @description Filter by checkout session status. */
                status?: components["schemas"]["CheckoutStatus"] | components["schemas"]["CheckoutStatus"][] | null;
                /** @description Filter by customer email. */
                query?: string | null;
                /** @description Page number, defaults to 1. */
                page?: number;
                /** @description Size of a page, defaults to 10. Maximum is 100. */
                limit?: number;
                /** @description Sorting criterion. Several criteria can be used simultaneously and will be applied in order. Add a minus sign `-` before the criteria name to sort by descending order. */
                sorting?: components["schemas"]["CheckoutSortProperty"][] | null;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ListResource_Checkout_"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "checkouts:create": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["CheckoutCreate"];
            };
        };
        responses: {
            /** @description Checkout session created. */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Checkout"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "checkouts:get": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The checkout session ID. */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Checkout"];
                };
            };
            /** @description Checkout session not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ResourceNotFound"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "checkouts:update": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The checkout session ID. */
                id: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["CheckoutUpdate"];
            };
        };
        responses: {
            /** @description Checkout session updated. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Checkout"];
                };
            };
            /** @description The checkout is expired or the customer already has an active subscription. */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CheckoutForbiddenError"];
                };
            };
            /** @description Checkout session not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ResourceNotFound"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "checkouts:client_get": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The checkout session client secret. */
                client_secret: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CheckoutPublic"];
                };
            };
            /** @description Checkout session not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ResourceNotFound"];
                };
            };
            /** @description The checkout session is expired. */
            410: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ExpiredCheckoutError"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "checkouts:client_update": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The checkout session client secret. */
                client_secret: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["CheckoutUpdatePublic"];
            };
        };
        responses: {
            /** @description Checkout session updated. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CheckoutPublic"];
                };
            };
            /** @description The checkout is expired or the customer already has an active subscription. */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CheckoutForbiddenError"];
                };
            };
            /** @description Checkout session not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ResourceNotFound"];
                };
            };
            /** @description The checkout session is expired. */
            410: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ExpiredCheckoutError"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "checkouts:client_create": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["CheckoutCreatePublic"];
            };
        };
        responses: {
            /** @description Successful Response */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CheckoutPublic"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "checkouts:client_confirm": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The checkout session client secret. */
                client_secret: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["CheckoutConfirmStripe"];
            };
        };
        responses: {
            /** @description Checkout session confirmed. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CheckoutPublicConfirmed"];
                };
            };
            /** @description The payment failed. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PaymentError"];
                };
            };
            /** @description The checkout is expired or the customer already has an active subscription. */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CheckoutForbiddenError"];
                };
            };
            /** @description Checkout session not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ResourceNotFound"];
                };
            };
            /** @description The checkout session is expired. */
            410: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ExpiredCheckoutError"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "files:list": {
        parameters: {
            query?: {
                /** @description Filter by organization ID. */
                organization_id?: string | string[] | null;
                /** @description Filter by file ID. */
                ids?: string | string[] | null;
                /** @description Page number, defaults to 1. */
                page?: number;
                /** @description Size of a page, defaults to 10. Maximum is 100. */
                limit?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ListResource_FileRead_"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "files:create": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["FileCreate"];
            };
        };
        responses: {
            /** @description File created. */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["FileUpload"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "files:uploaded": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The file ID. */
                id: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["FileUploadCompleted"];
            };
        };
        responses: {
            /** @description File upload completed. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DownloadableFileRead"] | components["schemas"]["ProductMediaFileRead"] | components["schemas"]["OrganizationAvatarFileRead"];
                };
            };
            /** @description You don't have the permission to update this file. */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["NotPermitted"];
                };
            };
            /** @description File not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ResourceNotFound"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "files:delete": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description File deleted. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description You don't have the permission to delete this file. */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["NotPermitted"];
                };
            };
            /** @description File not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ResourceNotFound"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "files:update": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The file ID. */
                id: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["FilePatch"];
            };
        };
        responses: {
            /** @description File updated. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["DownloadableFileRead"] | components["schemas"]["ProductMediaFileRead"] | components["schemas"]["OrganizationAvatarFileRead"];
                };
            };
            /** @description You don't have the permission to update this file. */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["NotPermitted"];
                };
            };
            /** @description File not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ResourceNotFound"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "metrics:get": {
        parameters: {
            query: {
                /** @description Start date. */
                start_date: string;
                /** @description End date. */
                end_date: string;
                /** @description Interval between two timestamps. */
                interval: components["schemas"]["TimeInterval"];
                /** @description Filter by organization ID. */
                organization_id?: string | string[] | null;
                /** @description Filter by product ID. */
                product_id?: string | string[] | null;
                /** @description Filter by billing type. `recurring` will filter data corresponding to subscriptions creations or renewals. `one_time` will filter data corresponding to one-time purchases. */
                billing_type?: components["schemas"]["ProductBillingType"] | components["schemas"]["ProductBillingType"][] | null;
                /** @description Filter by customer ID. */
                customer_id?: string | string[] | null;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MetricsResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "metrics:limits": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MetricsLimits"];
                };
            };
        };
    };
    "integrations_google:integrations.google.authorize": {
        parameters: {
            query?: {
                return_to?: string | null;
                attribution?: string | null;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "integrations_google:integrations.google.callback": {
        parameters: {
            query?: {
                code?: string | null;
                code_verifier?: string | null;
                state?: string | null;
                error?: string | null;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "license_keys:list": {
        parameters: {
            query?: {
                /** @description Filter by organization ID. */
                organization_id?: string | string[] | null;
                /** @description Filter by benefit ID. */
                benefit_id?: string | string[] | null;
                /** @description Page number, defaults to 1. */
                page?: number;
                /** @description Size of a page, defaults to 10. Maximum is 100. */
                limit?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ListResource_LicenseKeyRead_"];
                };
            };
            /** @description Not authorized to manage license key. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Unauthorized"];
                };
            };
            /** @description License key not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ResourceNotFound"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "license_keys:get": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["LicenseKeyWithActivations"];
                };
            };
            /** @description Not authorized to manage license key. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Unauthorized"];
                };
            };
            /** @description License key not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ResourceNotFound"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "license_keys:update": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                id: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["LicenseKeyUpdate"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["LicenseKeyRead"];
                };
            };
            /** @description Not authorized to manage license key. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Unauthorized"];
                };
            };
            /** @description License key not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ResourceNotFound"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "license_keys:get_activation": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                id: string;
                activation_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["LicenseKeyActivationRead"];
                };
            };
            /** @description Not authorized to manage license key. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Unauthorized"];
                };
            };
            /** @description License key not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ResourceNotFound"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "checkout-links:list": {
        parameters: {
            query?: {
                /** @description Filter by organization ID. */
                organization_id?: string | string[] | null;
                /** @description Filter by product ID. */
                product_id?: string | string[] | null;
                /** @description Page number, defaults to 1. */
                page?: number;
                /** @description Size of a page, defaults to 10. Maximum is 100. */
                limit?: number;
                /** @description Sorting criterion. Several criteria can be used simultaneously and will be applied in order. Add a minus sign `-` before the criteria name to sort by descending order. */
                sorting?: components["schemas"]["CheckoutLinkSortProperty"][] | null;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ListResource_CheckoutLink_"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "checkout-links:create": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["CheckoutLinkCreateProductPrice"] | components["schemas"]["CheckoutLinkCreateProduct"] | components["schemas"]["CheckoutLinkCreateProducts"];
            };
        };
        responses: {
            /** @description Checkout link created. */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CheckoutLink"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "checkout-links:get": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The checkout link ID. */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CheckoutLink"];
                };
            };
            /** @description Checkout link not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ResourceNotFound"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "checkout-links:delete": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The checkout link ID. */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Checkout link deleted. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Checkout link not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ResourceNotFound"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "checkout-links:update": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The checkout link ID. */
                id: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["CheckoutLinkUpdate"];
            };
        };
        responses: {
            /** @description Checkout link updated. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CheckoutLink"];
                };
            };
            /** @description Checkout link not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ResourceNotFound"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "storefronts:get": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                slug: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Storefront"];
                };
            };
            /** @description Organization not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ResourceNotFound"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "custom-fields:list": {
        parameters: {
            query?: {
                /** @description Filter by organization ID. */
                organization_id?: string | string[] | null;
                /** @description Filter by custom field name or slug. */
                query?: string | null;
                /** @description Filter by custom field type. */
                type?: components["schemas"]["CustomFieldType"] | components["schemas"]["CustomFieldType"][] | null;
                /** @description Page number, defaults to 1. */
                page?: number;
                /** @description Size of a page, defaults to 10. Maximum is 100. */
                limit?: number;
                /** @description Sorting criterion. Several criteria can be used simultaneously and will be applied in order. Add a minus sign `-` before the criteria name to sort by descending order. */
                sorting?: components["schemas"]["CustomFieldSortProperty"][] | null;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ListResource_CustomField_"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "custom-fields:create": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["CustomFieldCreate"];
            };
        };
        responses: {
            /** @description Custom field created. */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CustomField"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "custom-fields:get": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The custom field ID. */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CustomField"];
                };
            };
            /** @description Custom field not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ResourceNotFound"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "custom-fields:delete": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The custom field ID. */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Custom field deleted. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Custom field not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ResourceNotFound"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "custom-fields:update": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The custom field ID. */
                id: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["CustomFieldUpdate"];
            };
        };
        responses: {
            /** @description Custom field updated. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CustomField"];
                };
            };
            /** @description Custom field not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ResourceNotFound"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "embeds:get_product": {
        parameters: {
            query?: {
                price_id?: string | null;
            };
            header?: never;
            path: {
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ProductEmbed"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "discounts:list": {
        parameters: {
            query?: {
                /** @description Filter by organization ID. */
                organization_id?: string | string[] | null;
                /** @description Filter by name. */
                query?: string | null;
                /** @description Page number, defaults to 1. */
                page?: number;
                /** @description Size of a page, defaults to 10. Maximum is 100. */
                limit?: number;
                /** @description Sorting criterion. Several criteria can be used simultaneously and will be applied in order. Add a minus sign `-` before the criteria name to sort by descending order. */
                sorting?: components["schemas"]["DiscountSortProperty"][] | null;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ListResource_Discount_"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "discounts:create": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["DiscountCreate"];
            };
        };
        responses: {
            /** @description Discount created. */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Discount"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "discounts:get": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The discount ID. */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Discount"];
                };
            };
            /** @description Discount not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ResourceNotFound"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "discounts:delete": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The discount ID. */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Discount deleted. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Discount not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ResourceNotFound"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "discounts:update": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The discount ID. */
                id: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["DiscountUpdate"];
            };
        };
        responses: {
            /** @description Discount updated. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Discount"];
                };
            };
            /** @description Discount not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ResourceNotFound"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "customers:list": {
        parameters: {
            query?: {
                /** @description Filter by organization ID. */
                organization_id?: string | string[] | null;
                /** @description Filter by exact email. */
                email?: string | null;
                /** @description Filter by name or email. */
                query?: string | null;
                /** @description Page number, defaults to 1. */
                page?: number;
                /** @description Size of a page, defaults to 10. Maximum is 100. */
                limit?: number;
                /** @description Sorting criterion. Several criteria can be used simultaneously and will be applied in order. Add a minus sign `-` before the criteria name to sort by descending order. */
                sorting?: components["schemas"]["CustomerSortProperty"][] | null;
                /** @description Filter by metadata key-value pairs. It uses the `deepObject` style, e.g. `?metadata[key]=value`. */
                metadata?: components["schemas"]["MetadataQuery"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ListResource_Customer_"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "customers:create": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["CustomerCreate"];
            };
        };
        responses: {
            /** @description Customer created. */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Customer"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "customers:get": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The customer ID. */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Customer"];
                };
            };
            /** @description Customer not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ResourceNotFound"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "customers:delete": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The customer ID. */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Customer deleted. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Customer not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ResourceNotFound"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "customers:update": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The customer ID. */
                id: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["CustomerUpdate"];
            };
        };
        responses: {
            /** @description Customer updated. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Customer"];
                };
            };
            /** @description Customer not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ResourceNotFound"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "customers:get_external": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The customer external ID. */
                external_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Customer"];
                };
            };
            /** @description Customer not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ResourceNotFound"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "customers:delete_external": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The customer external ID. */
                external_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Customer deleted. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Customer not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ResourceNotFound"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "customers:update_external": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The customer external ID. */
                external_id: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["CustomerUpdateExternalID"];
            };
        };
        responses: {
            /** @description Customer updated. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Customer"];
                };
            };
            /** @description Customer not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ResourceNotFound"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "customers:get_state": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The customer ID. */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CustomerState"];
                };
            };
            /** @description Customer not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ResourceNotFound"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "customers:get_state_external": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The customer external ID. */
                external_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CustomerState"];
                };
            };
            /** @description Customer not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ResourceNotFound"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "customer_portal:benefit-grants:list": {
        parameters: {
            query?: {
                /** @description Filter by benefit type. */
                type?: components["schemas"]["BenefitType"] | components["schemas"]["BenefitType"][] | null;
                /** @description Filter by benefit ID. */
                benefit_id?: string | string[] | null;
                /** @description Filter by organization ID. */
                organization_id?: string | string[] | null;
                /** @description Filter by checkout ID. */
                checkout_id?: string | string[] | null;
                /** @description Filter by order ID. */
                order_id?: string | string[] | null;
                /** @description Filter by subscription ID. */
                subscription_id?: string | string[] | null;
                /** @description Page number, defaults to 1. */
                page?: number;
                /** @description Size of a page, defaults to 10. Maximum is 100. */
                limit?: number;
                /** @description Sorting criterion. Several criteria can be used simultaneously and will be applied in order. Add a minus sign `-` before the criteria name to sort by descending order. */
                sorting?: components["schemas"]["CustomerBenefitGrantSortProperty"][] | null;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ListResource_CustomerBenefitGrant_"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "customer_portal:benefit-grants:get": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The benefit grant ID. */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CustomerBenefitGrant"];
                };
            };
            /** @description Benefit grant not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ResourceNotFound"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "customer_portal:benefit-grants:update": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The benefit grant ID. */
                id: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["CustomerBenefitGrantUpdate"];
            };
        };
        responses: {
            /** @description Benefit grant updated. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CustomerBenefitGrant"];
                };
            };
            /** @description The benefit grant is revoked and cannot be updated. */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["NotPermitted"];
                };
            };
            /** @description Benefit grant not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ResourceNotFound"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "customer_portal:customers:get": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CustomerPortalCustomer"];
                };
            };
        };
    };
    "customer_portal:customers:update": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["CustomerPortalCustomerUpdate"];
            };
        };
        responses: {
            /** @description Customer updated. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CustomerPortalCustomer"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "customer_portal:customers:get_payment_methods": {
        parameters: {
            query?: {
                /** @description Page number, defaults to 1. */
                page?: number;
                /** @description Size of a page, defaults to 10. Maximum is 100. */
                limit?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ListResource_Union_PaymentMethodCard__PaymentMethodGeneric__"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "customer_portal:customers:add_payment_method": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["CustomerPaymentMethodCreate"];
            };
        };
        responses: {
            /** @description Payment method created. */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PaymentMethodCard"] | components["schemas"]["PaymentMethodGeneric"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "customer_portal:customers:delete_payment_method": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Payment method deleted. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Payment method not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ResourceNotFound"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "customer_portal:customer_meters:list": {
        parameters: {
            query?: {
                /** @description Filter by meter ID. */
                meter_id?: string | string[] | null;
                /** @description Filter by meter name. */
                query?: string | null;
                /** @description Page number, defaults to 1. */
                page?: number;
                /** @description Size of a page, defaults to 10. Maximum is 100. */
                limit?: number;
                /** @description Sorting criterion. Several criteria can be used simultaneously and will be applied in order. Add a minus sign `-` before the criteria name to sort by descending order. */
                sorting?: components["schemas"]["CustomerCustomerMeterSortProperty"][] | null;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ListResource_CustomerCustomerMeter_"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "customer_portal:customer_meters:get": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The customer meter ID. */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CustomerCustomerMeter"];
                };
            };
            /** @description Customer meter not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ResourceNotFound"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "customer_portal:customer-session:customer_portal.customer_session.request": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["CustomerSessionCodeRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            202: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "customer_portal:customer-session:customer_portal.customer_session.authenticate": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["CustomerSessionCodeAuthenticateRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CustomerSessionCodeAuthenticateResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "customer_portal:downloadables:list": {
        parameters: {
            query?: {
                /** @description Filter by organization ID. */
                organization_id?: string | string[] | null;
                /** @description Filter by benefit ID. */
                benefit_id?: string | string[] | null;
                /** @description Page number, defaults to 1. */
                page?: number;
                /** @description Size of a page, defaults to 10. Maximum is 100. */
                limit?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ListResource_DownloadableRead_"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "customer_portal:downloadables:customer_portal.downloadables.get": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                token: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Redirected to download */
            302: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Invalid signature */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Downloadable not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Expired signature */
            410: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "customer_portal:license_keys:list": {
        parameters: {
            query?: {
                /** @description Filter by organization ID. */
                organization_id?: string | string[] | null;
                /** @description Filter by a specific benefit */
                benefit_id?: string | null;
                /** @description Page number, defaults to 1. */
                page?: number;
                /** @description Size of a page, defaults to 10. Maximum is 100. */
                limit?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ListResource_LicenseKeyRead_"];
                };
            };
            /** @description Not authorized to manage license key. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Unauthorized"];
                };
            };
            /** @description License key not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ResourceNotFound"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "customer_portal:license_keys:get": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["LicenseKeyWithActivations"];
                };
            };
            /** @description License key not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ResourceNotFound"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "customer_portal:license_keys:validate": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["LicenseKeyValidate"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ValidatedLicenseKey"];
                };
            };
            /** @description License key not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ResourceNotFound"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "customer_portal:license_keys:activate": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["LicenseKeyActivate"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["LicenseKeyActivationRead"];
                };
            };
            /** @description License key activation not required or permitted (limit reached). */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["NotPermitted"];
                };
            };
            /** @description License key not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ResourceNotFound"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "customer_portal:license_keys:deactivate": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["LicenseKeyDeactivate"];
            };
        };
        responses: {
            /** @description License key activation deactivated. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description License key not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ResourceNotFound"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "customer_portal:oauth-accounts:customer_portal.oauth_accounts.authorize": {
        parameters: {
            query: {
                platform: components["schemas"]["CustomerOAuthPlatform"];
                customer_id: string;
                return_to?: string | null;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AuthorizeResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "customer_portal:oauth-accounts:customer_portal.oauth_accounts.callback": {
        parameters: {
            query: {
                state: string;
                code?: string | null;
                error?: string | null;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "customer_portal:orders:list": {
        parameters: {
            query?: {
                /** @description Filter by organization ID. */
                organization_id?: string | string[] | null;
                /** @description Filter by product ID. */
                product_id?: string | string[] | null;
                /** @description Filter by product billing type. `recurring` will filter data corresponding to subscriptions creations or renewals. `one_time` will filter data corresponding to one-time purchases. */
                product_billing_type?: components["schemas"]["ProductBillingType"] | components["schemas"]["ProductBillingType"][] | null;
                /** @description Filter by subscription ID. */
                subscription_id?: string | string[] | null;
                /** @description Search by product or organization name. */
                query?: string | null;
                /** @description Page number, defaults to 1. */
                page?: number;
                /** @description Size of a page, defaults to 10. Maximum is 100. */
                limit?: number;
                /** @description Sorting criterion. Several criteria can be used simultaneously and will be applied in order. Add a minus sign `-` before the criteria name to sort by descending order. */
                sorting?: components["schemas"]["CustomerOrderSortProperty"][] | null;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ListResource_CustomerOrder_"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "customer_portal:orders:get": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The order ID. */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CustomerOrder"];
                };
            };
            /** @description Order not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ResourceNotFound"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "customer_portal:orders:invoice": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The order ID. */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CustomerOrderInvoice"];
                };
            };
            /** @description Order not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ResourceNotFound"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "customer_portal:organizations:get": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The organization slug. */
                slug: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CustomerOrganization"];
                };
            };
            /** @description Organization not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ResourceNotFound"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "customer_portal:subscriptions:list": {
        parameters: {
            query?: {
                /** @description Filter by organization ID. */
                organization_id?: string | string[] | null;
                /** @description Filter by product ID. */
                product_id?: string | string[] | null;
                /** @description Filter by active or cancelled subscription. */
                active?: boolean | null;
                /** @description Search by product or organization name. */
                query?: string | null;
                /** @description Page number, defaults to 1. */
                page?: number;
                /** @description Size of a page, defaults to 10. Maximum is 100. */
                limit?: number;
                /** @description Sorting criterion. Several criteria can be used simultaneously and will be applied in order. Add a minus sign `-` before the criteria name to sort by descending order. */
                sorting?: components["schemas"]["CustomerSubscriptionSortProperty"][] | null;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ListResource_CustomerSubscription_"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "customer_portal:subscriptions:get": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The subscription ID. */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CustomerSubscription"];
                };
            };
            /** @description Customer subscription was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ResourceNotFound"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "customer_portal:subscriptions:cancel": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The subscription ID. */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Customer subscription is canceled. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CustomerSubscription"];
                };
            };
            /** @description Customer subscription is already canceled or will be at the end of the period. */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AlreadyCanceledSubscription"];
                };
            };
            /** @description Customer subscription was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ResourceNotFound"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "customer_portal:subscriptions:update": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The subscription ID. */
                id: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["CustomerSubscriptionUpdate"];
            };
        };
        responses: {
            /** @description Customer subscription updated. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CustomerSubscription"];
                };
            };
            /** @description Customer subscription is already canceled or will be at the end of the period. */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AlreadyCanceledSubscription"];
                };
            };
            /** @description Customer subscription was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ResourceNotFound"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "email-update:request_email_update": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["EmailUpdateRequest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "email-update:verify_email_update": {
        parameters: {
            query?: {
                return_to?: string | null;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/x-www-form-urlencoded": components["schemas"]["Body_email-update_verify_email_update"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "customer-sessions:create": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["CustomerSessionCustomerIDCreate"] | components["schemas"]["CustomerSessionCustomerExternalIDCreate"];
            };
        };
        responses: {
            /** @description Customer session created. */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CustomerSession"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "events:list": {
        parameters: {
            query?: {
                /** @description Filter events following filter clauses. JSON string following the same schema a meter filter clause.  */
                filter?: string | null;
                /** @description Filter events after this timestamp. */
                start_timestamp?: string | null;
                /** @description Filter events before this timestamp. */
                end_timestamp?: string | null;
                /** @description Filter by organization ID. */
                organization_id?: string | string[] | null;
                /** @description Filter by customer ID. */
                customer_id?: string | string[] | null;
                /** @description Filter by external customer ID. */
                external_customer_id?: string | string[] | null;
                /** @description Filter by a meter filter clause. */
                meter_id?: string | null;
                /** @description Filter by event name. */
                name?: string | string[] | null;
                /** @description Filter by event source. */
                source?: components["schemas"]["EventSource"] | components["schemas"]["EventSource"][] | null;
                /** @description Page number, defaults to 1. */
                page?: number;
                /** @description Size of a page, defaults to 10. Maximum is 100. */
                limit?: number;
                /** @description Sorting criterion. Several criteria can be used simultaneously and will be applied in order. Add a minus sign `-` before the criteria name to sort by descending order. */
                sorting?: components["schemas"]["EventSortProperty"][] | null;
                /** @description Filter by metadata key-value pairs. It uses the `deepObject` style, e.g. `?metadata[key]=value`. */
                metadata?: components["schemas"]["MetadataQuery"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ListResource_Event_"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "events:list_names": {
        parameters: {
            query?: {
                /** @description Filter by organization ID. */
                organization_id?: string | string[] | null;
                /** @description Filter by customer ID. */
                customer_id?: string | string[] | null;
                /** @description Filter by external customer ID. */
                external_customer_id?: string | string[] | null;
                /** @description Filter by event source. */
                source?: components["schemas"]["EventSource"] | components["schemas"]["EventSource"][] | null;
                /** @description Query to filter event names. */
                query?: string | null;
                /** @description Page number, defaults to 1. */
                page?: number;
                /** @description Size of a page, defaults to 10. Maximum is 100. */
                limit?: number;
                /** @description Sorting criterion. Several criteria can be used simultaneously and will be applied in order. Add a minus sign `-` before the criteria name to sort by descending order. */
                sorting?: components["schemas"]["EventNamesSortProperty"][] | null;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ListResource_EventName_"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "events:get": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The event ID. */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Event"];
                };
            };
            /** @description Event not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ResourceNotFound"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "events:ingest": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["EventsIngest"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["EventsIngestResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "meters:list": {
        parameters: {
            query?: {
                /** @description Filter by organization ID. */
                organization_id?: string | string[] | null;
                /** @description Filter by name. */
                query?: string | null;
                /** @description Page number, defaults to 1. */
                page?: number;
                /** @description Size of a page, defaults to 10. Maximum is 100. */
                limit?: number;
                /** @description Sorting criterion. Several criteria can be used simultaneously and will be applied in order. Add a minus sign `-` before the criteria name to sort by descending order. */
                sorting?: components["schemas"]["MeterSortProperty"][] | null;
                /** @description Filter by metadata key-value pairs. It uses the `deepObject` style, e.g. `?metadata[key]=value`. */
                metadata?: components["schemas"]["MetadataQuery"];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ListResource_Meter_"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "meters:create": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["MeterCreate"];
            };
        };
        responses: {
            /** @description Meter created. */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Meter"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "meters:get": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The meter ID. */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Meter"];
                };
            };
            /** @description Meter not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ResourceNotFound"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "meters:update": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The meter ID. */
                id: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["MeterUpdate"];
            };
        };
        responses: {
            /** @description Meter updated. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Meter"];
                };
            };
            /** @description Meter not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ResourceNotFound"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "meters:quantities": {
        parameters: {
            query: {
                /** @description Start timestamp. */
                start_timestamp: string;
                /** @description End timestamp. */
                end_timestamp: string;
                /** @description Interval between two timestamps. */
                interval: components["schemas"]["TimeInterval"];
                /** @description Filter by customer ID. */
                customer_id?: string | string[] | null;
                /** @description Filter by external customer ID. */
                external_customer_id?: string | string[] | null;
            };
            header?: never;
            path: {
                /** @description The meter ID. */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MeterQuantities"];
                };
            };
            /** @description Meter not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ResourceNotFound"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "organization_access_token:list": {
        parameters: {
            query?: {
                /** @description Filter by organization ID. */
                organization_id?: string | string[] | null;
                /** @description Page number, defaults to 1. */
                page?: number;
                /** @description Size of a page, defaults to 10. Maximum is 100. */
                limit?: number;
                /** @description Sorting criterion. Several criteria can be used simultaneously and will be applied in order. Add a minus sign `-` before the criteria name to sort by descending order. */
                sorting?: components["schemas"]["OrganizationAccessTokenSortProperty"][] | null;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ListResource_OrganizationAccessToken_"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "organization_access_token:create": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["OrganizationAccessTokenCreate"];
            };
        };
        responses: {
            /** @description Successful Response */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["OrganizationAccessTokenCreateResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "organization_access_token:delete": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "organization_access_token:update": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                id: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["OrganizationAccessTokenUpdate"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["OrganizationAccessToken"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "customer_meters:list": {
        parameters: {
            query?: {
                /** @description Filter by organization ID. */
                organization_id?: string | string[] | null;
                /** @description Filter by customer ID. */
                customer_id?: string | string[] | null;
                /** @description Filter by external customer ID. */
                external_customer_id?: string | string[] | null;
                /** @description Filter by meter ID. */
                meter_id?: string | string[] | null;
                /** @description Page number, defaults to 1. */
                page?: number;
                /** @description Size of a page, defaults to 10. Maximum is 100. */
                limit?: number;
                /** @description Sorting criterion. Several criteria can be used simultaneously and will be applied in order. Add a minus sign `-` before the criteria name to sort by descending order. */
                sorting?: components["schemas"]["CustomerMeterSortProperty"][] | null;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ListResource_CustomerMeter_"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "customer_meters:get": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The customer meter ID. */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CustomerMeter"];
                };
            };
            /** @description Customer meter not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ResourceNotFound"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "payments:list": {
        parameters: {
            query?: {
                /** @description Filter by organization ID. */
                organization_id?: string | string[] | null;
                /** @description Filter by checkout ID. */
                checkout_id?: string | string[] | null;
                /** @description Filter by order ID. */
                order_id?: string | string[] | null;
                /** @description Filter by payment status. */
                status?: components["schemas"]["PaymentStatus"] | components["schemas"]["PaymentStatus"][] | null;
                /** @description Filter by payment method. */
                method?: string | string[] | null;
                /** @description Filter by customer email. */
                customer_email?: string | string[] | null;
                /** @description Page number, defaults to 1. */
                page?: number;
                /** @description Size of a page, defaults to 10. Maximum is 100. */
                limit?: number;
                /** @description Sorting criterion. Several criteria can be used simultaneously and will be applied in order. Add a minus sign `-` before the criteria name to sort by descending order. */
                sorting?: components["schemas"]["PaymentSortProperty"][] | null;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ListResource__"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    "payments:get": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The payment ID. */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Payment"];
                };
            };
            /** @description Payment not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ResourceNotFound"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    _endpointcheckout_created_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["WebhookCheckoutCreatedPayload"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    _endpointcheckout_updated_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["WebhookCheckoutUpdatedPayload"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    _endpointcustomer_created_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["WebhookCustomerCreatedPayload"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    _endpointcustomer_updated_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["WebhookCustomerUpdatedPayload"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    _endpointcustomer_deleted_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["WebhookCustomerDeletedPayload"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    _endpointcustomer_state_changed_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["WebhookCustomerStateChangedPayload"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    _endpointorder_created_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["WebhookOrderCreatedPayload"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    _endpointorder_updated_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["WebhookOrderUpdatedPayload"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    _endpointorder_paid_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["WebhookOrderPaidPayload"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    _endpointorder_refunded_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["WebhookOrderRefundedPayload"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    _endpointsubscription_created_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["WebhookSubscriptionCreatedPayload"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    _endpointsubscription_updated_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["WebhookSubscriptionUpdatedPayload"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    _endpointsubscription_active_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["WebhookSubscriptionActivePayload"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    _endpointsubscription_canceled_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["WebhookSubscriptionCanceledPayload"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    _endpointsubscription_uncanceled_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["WebhookSubscriptionUncanceledPayload"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    _endpointsubscription_revoked_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["WebhookSubscriptionRevokedPayload"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    _endpointrefund_created_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["WebhookRefundCreatedPayload"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    _endpointrefund_updated_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["WebhookRefundUpdatedPayload"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    _endpointproduct_created_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["WebhookProductCreatedPayload"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    _endpointproduct_updated_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["WebhookProductUpdatedPayload"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    _endpointorganization_updated_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["WebhookOrganizationUpdatedPayload"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    _endpointbenefit_created_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["WebhookBenefitCreatedPayload"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    _endpointbenefit_updated_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["WebhookBenefitUpdatedPayload"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    _endpointbenefit_grant_created_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["WebhookBenefitGrantCreatedPayload"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    _endpointbenefit_grant_updated_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["WebhookBenefitGrantUpdatedPayload"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    _endpointbenefit_grant_cycled_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["WebhookBenefitGrantCycledPayload"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
    _endpointbenefit_grant_revoked_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["WebhookBenefitGrantRevokedPayload"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
}
type ReadonlyArray<T> = [
    Exclude<T, undefined>
] extends [
    any[]
] ? Readonly<Exclude<T, undefined>> : Readonly<Exclude<T, undefined>[]>;
export const accountTypeValues: ReadonlyArray<components["schemas"]["AccountType"]> = ["stripe", "open_collective"];
export const authorizeResponseOrganizationSub_typeValues: ReadonlyArray<components["schemas"]["AuthorizeResponseOrganization"]["sub_type"]> = ["organization"];
export const authorizeResponseUserSub_typeValues: ReadonlyArray<components["schemas"]["AuthorizeResponseUser"]["sub_type"]> = ["user"];
export const availableScopeValues: ReadonlyArray<components["schemas"]["AvailableScope"]> = ["openid", "profile", "email", "user:read", "organizations:read", "organizations:write", "custom_fields:read", "custom_fields:write", "discounts:read", "discounts:write", "checkout_links:read", "checkout_links:write", "checkouts:read", "checkouts:write", "products:read", "products:write", "benefits:read", "benefits:write", "events:read", "events:write", "meters:read", "meters:write", "files:read", "files:write", "subscriptions:read", "subscriptions:write", "customers:read", "customers:write", "customer_meters:read", "customer_sessions:write", "orders:read", "refunds:read", "refunds:write", "payments:read", "metrics:read", "webhooks:read", "webhooks:write", "external_organizations:read", "license_keys:read", "license_keys:write", "repositories:read", "repositories:write", "issues:read", "issues:write", "customer_portal:read", "customer_portal:write", "notification_recipients:read", "notification_recipients:write"];
export const benefitCustomCreateTypeValues: ReadonlyArray<components["schemas"]["BenefitCustomCreate"]["type"]> = ["custom"];
export const benefitDiscordCreateTypeValues: ReadonlyArray<components["schemas"]["BenefitDiscordCreate"]["type"]> = ["discord"];
export const benefitDownloadablesCreateTypeValues: ReadonlyArray<components["schemas"]["BenefitDownloadablesCreate"]["type"]> = ["downloadables"];
export const benefitGitHubRepositoryCreateTypeValues: ReadonlyArray<components["schemas"]["BenefitGitHubRepositoryCreate"]["type"]> = ["github_repository"];
export const benefitGitHubRepositoryCreatePropertiesPermissionValues: ReadonlyArray<components["schemas"]["BenefitGitHubRepositoryCreateProperties"]["permission"]> = ["pull", "triage", "push", "maintain", "admin"];
export const benefitGitHubRepositoryPropertiesPermissionValues: ReadonlyArray<components["schemas"]["BenefitGitHubRepositoryProperties"]["permission"]> = ["pull", "triage", "push", "maintain", "admin"];
export const benefitGrantGitHubRepositoryPropertiesPermissionValues: ReadonlyArray<components["schemas"]["BenefitGrantGitHubRepositoryProperties"]["permission"]> = ["pull", "triage", "push", "maintain", "admin"];
export const benefitLicenseKeyExpirationPropertiesTimeframeValues: ReadonlyArray<components["schemas"]["BenefitLicenseKeyExpirationProperties"]["timeframe"]> = ["year", "month", "day"];
export const benefitLicenseKeysCreateTypeValues: ReadonlyArray<components["schemas"]["BenefitLicenseKeysCreate"]["type"]> = ["license_keys"];
export const benefitMeterCreditCreateTypeValues: ReadonlyArray<components["schemas"]["BenefitMeterCreditCreate"]["type"]> = ["meter_credit"];
export const benefitSortPropertyValues: ReadonlyArray<components["schemas"]["BenefitSortProperty"]> = ["created_at", "-created_at", "description", "-description"];
export const benefitTypeValues: ReadonlyArray<components["schemas"]["BenefitType"]> = ["custom", "discord", "github_repository", "downloadables", "license_keys", "meter_credit"];
export const body_oauth2_consentActionValues: ReadonlyArray<components["schemas"]["Body_oauth2_consent"]["action"]> = ["allow", "deny"];
export const checkoutLinkSortPropertyValues: ReadonlyArray<components["schemas"]["CheckoutLinkSortProperty"]> = ["created_at", "-created_at", "label", "-label", "success_url", "-success_url", "allow_discount_codes", "-allow_discount_codes"];
export const checkoutSortPropertyValues: ReadonlyArray<components["schemas"]["CheckoutSortProperty"]> = ["created_at", "-created_at", "expires_at", "-expires_at", "status", "-status"];
export const checkoutStatusValues: ReadonlyArray<components["schemas"]["CheckoutStatus"]> = ["open", "expired", "confirmed", "succeeded", "failed"];
export const countAggregationFuncValues: ReadonlyArray<components["schemas"]["CountAggregation"]["func"]> = ["count"];
export const customFieldCheckboxTypeValues: ReadonlyArray<components["schemas"]["CustomFieldCheckbox"]["type"]> = ["checkbox"];
export const customFieldCreateCheckboxTypeValues: ReadonlyArray<components["schemas"]["CustomFieldCreateCheckbox"]["type"]> = ["checkbox"];
export const customFieldCreateDateTypeValues: ReadonlyArray<components["schemas"]["CustomFieldCreateDate"]["type"]> = ["date"];
export const customFieldCreateNumberTypeValues: ReadonlyArray<components["schemas"]["CustomFieldCreateNumber"]["type"]> = ["number"];
export const customFieldCreateSelectTypeValues: ReadonlyArray<components["schemas"]["CustomFieldCreateSelect"]["type"]> = ["select"];
export const customFieldCreateTextTypeValues: ReadonlyArray<components["schemas"]["CustomFieldCreateText"]["type"]> = ["text"];
export const customFieldDateTypeValues: ReadonlyArray<components["schemas"]["CustomFieldDate"]["type"]> = ["date"];
export const customFieldNumberTypeValues: ReadonlyArray<components["schemas"]["CustomFieldNumber"]["type"]> = ["number"];
export const customFieldSelectTypeValues: ReadonlyArray<components["schemas"]["CustomFieldSelect"]["type"]> = ["select"];
export const customFieldSortPropertyValues: ReadonlyArray<components["schemas"]["CustomFieldSortProperty"]> = ["created_at", "-created_at", "slug", "-slug", "name", "-name", "type", "-type"];
export const customFieldTextTypeValues: ReadonlyArray<components["schemas"]["CustomFieldText"]["type"]> = ["text"];
export const customFieldTypeValues: ReadonlyArray<components["schemas"]["CustomFieldType"]> = ["text", "number", "date", "checkbox", "select"];
export const customFieldUpdateCheckboxTypeValues: ReadonlyArray<components["schemas"]["CustomFieldUpdateCheckbox"]["type"]> = ["checkbox"];
export const customFieldUpdateDateTypeValues: ReadonlyArray<components["schemas"]["CustomFieldUpdateDate"]["type"]> = ["date"];
export const customFieldUpdateNumberTypeValues: ReadonlyArray<components["schemas"]["CustomFieldUpdateNumber"]["type"]> = ["number"];
export const customFieldUpdateSelectTypeValues: ReadonlyArray<components["schemas"]["CustomFieldUpdateSelect"]["type"]> = ["select"];
export const customFieldUpdateTextTypeValues: ReadonlyArray<components["schemas"]["CustomFieldUpdateText"]["type"]> = ["text"];
export const customerBenefitGrantCustomUpdateBenefit_typeValues: ReadonlyArray<components["schemas"]["CustomerBenefitGrantCustomUpdate"]["benefit_type"]> = ["custom"];
export const customerBenefitGrantDiscordUpdateBenefit_typeValues: ReadonlyArray<components["schemas"]["CustomerBenefitGrantDiscordUpdate"]["benefit_type"]> = ["discord"];
export const customerBenefitGrantDownloadablesUpdateBenefit_typeValues: ReadonlyArray<components["schemas"]["CustomerBenefitGrantDownloadablesUpdate"]["benefit_type"]> = ["downloadables"];
export const customerBenefitGrantGitHubRepositoryUpdateBenefit_typeValues: ReadonlyArray<components["schemas"]["CustomerBenefitGrantGitHubRepositoryUpdate"]["benefit_type"]> = ["github_repository"];
export const customerBenefitGrantLicenseKeysUpdateBenefit_typeValues: ReadonlyArray<components["schemas"]["CustomerBenefitGrantLicenseKeysUpdate"]["benefit_type"]> = ["license_keys"];
export const customerBenefitGrantMeterCreditUpdateBenefit_typeValues: ReadonlyArray<components["schemas"]["CustomerBenefitGrantMeterCreditUpdate"]["benefit_type"]> = ["meter_credit"];
export const customerBenefitGrantSortPropertyValues: ReadonlyArray<components["schemas"]["CustomerBenefitGrantSortProperty"]> = ["granted_at", "-granted_at", "type", "-type", "organization", "-organization"];
export const customerCancellationReasonValues: ReadonlyArray<components["schemas"]["CustomerCancellationReason"]> = ["customer_service", "low_quality", "missing_features", "switched_service", "too_complex", "too_expensive", "unused", "other"];
export const customerCustomerMeterSortPropertyValues: ReadonlyArray<components["schemas"]["CustomerCustomerMeterSortProperty"]> = ["created_at", "-created_at", "modified_at", "-modified_at", "meter_id", "-meter_id", "meter_name", "-meter_name", "consumed_units", "-consumed_units", "credited_units", "-credited_units", "balance", "-balance"];
export const customerMeterSortPropertyValues: ReadonlyArray<components["schemas"]["CustomerMeterSortProperty"]> = ["created_at", "-created_at", "modified_at", "-modified_at", "customer_id", "-customer_id", "customer_name", "-customer_name", "meter_id", "-meter_id", "meter_name", "-meter_name", "consumed_units", "-consumed_units", "credited_units", "-credited_units", "balance", "-balance"];
export const customerOAuthPlatformValues: ReadonlyArray<components["schemas"]["CustomerOAuthPlatform"]> = ["github", "discord"];
export const customerOrderSortPropertyValues: ReadonlyArray<components["schemas"]["CustomerOrderSortProperty"]> = ["created_at", "-created_at", "amount", "-amount", "net_amount", "-net_amount", "product", "-product", "subscription", "-subscription"];
export const customerSortPropertyValues: ReadonlyArray<components["schemas"]["CustomerSortProperty"]> = ["created_at", "-created_at", "email", "-email", "name", "-name"];
export const customerSubscriptionSortPropertyValues: ReadonlyArray<components["schemas"]["CustomerSubscriptionSortProperty"]> = ["started_at", "-started_at", "amount", "-amount", "status", "-status", "organization", "-organization", "product", "-product"];
export const discountDurationValues: ReadonlyArray<components["schemas"]["DiscountDuration"]> = ["once", "forever", "repeating"];
export const discountSortPropertyValues: ReadonlyArray<components["schemas"]["DiscountSortProperty"]> = ["created_at", "-created_at", "name", "-name", "code", "-code", "redemptions_count", "-redemptions_count"];
export const discountTypeValues: ReadonlyArray<components["schemas"]["DiscountType"]> = ["fixed", "percentage"];
export const downloadableFileCreateServiceValues: ReadonlyArray<components["schemas"]["DownloadableFileCreate"]["service"]> = ["downloadable"];
export const downloadableFileReadServiceValues: ReadonlyArray<components["schemas"]["DownloadableFileRead"]["service"]> = ["downloadable"];
export const eventNamesSortPropertyValues: ReadonlyArray<components["schemas"]["EventNamesSortProperty"]> = ["name", "-name", "occurrences", "-occurrences", "first_seen", "-first_seen", "last_seen", "-last_seen"];
export const eventSortPropertyValues: ReadonlyArray<components["schemas"]["EventSortProperty"]> = ["timestamp", "-timestamp"];
export const eventSourceValues: ReadonlyArray<components["schemas"]["EventSource"]> = ["system", "user"];
export const fileServiceTypesValues: ReadonlyArray<components["schemas"]["FileServiceTypes"]> = ["downloadable", "product_media", "organization_avatar"];
export const filterConjunctionValues: ReadonlyArray<components["schemas"]["FilterConjunction"]> = ["and", "or"];
export const filterOperatorValues: ReadonlyArray<components["schemas"]["FilterOperator"]> = ["eq", "ne", "gt", "gte", "lt", "lte", "like", "not_like"];
export const identityVerificationStatusValues: ReadonlyArray<components["schemas"]["IdentityVerificationStatus"]> = ["unverified", "pending", "verified", "failed"];
export const introspectTokenResponseToken_typeValues: ReadonlyArray<components["schemas"]["IntrospectTokenResponse"]["token_type"]> = ["access_token", "refresh_token"];
export const legacyRecurringProductPriceCustomAmount_typeValues: ReadonlyArray<components["schemas"]["LegacyRecurringProductPriceCustom"]["amount_type"]> = ["custom"];
export const legacyRecurringProductPriceFixedAmount_typeValues: ReadonlyArray<components["schemas"]["LegacyRecurringProductPriceFixed"]["amount_type"]> = ["fixed"];
export const legacyRecurringProductPriceFreeAmount_typeValues: ReadonlyArray<components["schemas"]["LegacyRecurringProductPriceFree"]["amount_type"]> = ["free"];
export const licenseKeyStatusValues: ReadonlyArray<components["schemas"]["LicenseKeyStatus"]> = ["granted", "revoked", "disabled"];
export const maintainerAccountReviewedNotificationTypeValues: ReadonlyArray<components["schemas"]["MaintainerAccountReviewedNotification"]["type"]> = ["MaintainerAccountReviewedNotification"];
export const maintainerAccountUnderReviewNotificationTypeValues: ReadonlyArray<components["schemas"]["MaintainerAccountUnderReviewNotification"]["type"]> = ["MaintainerAccountUnderReviewNotification"];
export const maintainerCreateAccountNotificationTypeValues: ReadonlyArray<components["schemas"]["MaintainerCreateAccountNotification"]["type"]> = ["MaintainerCreateAccountNotification"];
export const maintainerNewPaidSubscriptionNotificationTypeValues: ReadonlyArray<components["schemas"]["MaintainerNewPaidSubscriptionNotification"]["type"]> = ["MaintainerNewPaidSubscriptionNotification"];
export const maintainerNewProductSaleNotificationTypeValues: ReadonlyArray<components["schemas"]["MaintainerNewProductSaleNotification"]["type"]> = ["MaintainerNewProductSaleNotification"];
export const meterSortPropertyValues: ReadonlyArray<components["schemas"]["MeterSortProperty"]> = ["created_at", "-created_at", "name", "-name"];
export const metricTypeValues: ReadonlyArray<components["schemas"]["MetricType"]> = ["scalar", "currency", "percentage"];
export const notificationRecipientPlatformValues: ReadonlyArray<components["schemas"]["NotificationRecipientPlatform"]> = ["ios", "android"];
export const oAuth2ClientToken_endpoint_auth_methodValues: ReadonlyArray<components["schemas"]["OAuth2Client"]["token_endpoint_auth_method"]> = ["client_secret_basic", "client_secret_post", "none"];
export const oAuth2ClientGrant_typesValues: ReadonlyArray<components["schemas"]["OAuth2Client"]["grant_types"]> = ["authorization_code", "refresh_token"];
export const oAuth2ClientConfigurationToken_endpoint_auth_methodValues: ReadonlyArray<components["schemas"]["OAuth2ClientConfiguration"]["token_endpoint_auth_method"]> = ["client_secret_basic", "client_secret_post", "none"];
export const oAuth2ClientConfigurationGrant_typesValues: ReadonlyArray<components["schemas"]["OAuth2ClientConfiguration"]["grant_types"]> = ["authorization_code", "refresh_token"];
export const oAuth2ClientConfigurationUpdateToken_endpoint_auth_methodValues: ReadonlyArray<components["schemas"]["OAuth2ClientConfigurationUpdate"]["token_endpoint_auth_method"]> = ["client_secret_basic", "client_secret_post", "none"];
export const oAuth2ClientConfigurationUpdateGrant_typesValues: ReadonlyArray<components["schemas"]["OAuth2ClientConfigurationUpdate"]["grant_types"]> = ["authorization_code", "refresh_token"];
export const oAuthPlatformValues: ReadonlyArray<components["schemas"]["OAuthPlatform"]> = ["github", "github_repository_benefit", "google"];
export const orderBillingReasonValues: ReadonlyArray<components["schemas"]["OrderBillingReason"]> = ["purchase", "subscription_create", "subscription_cycle", "subscription_update"];
export const orderSortPropertyValues: ReadonlyArray<components["schemas"]["OrderSortProperty"]> = ["created_at", "-created_at", "amount", "-amount", "net_amount", "-net_amount", "customer", "-customer", "product", "-product", "discount", "-discount", "subscription", "-subscription"];
export const orderStatusValues: ReadonlyArray<components["schemas"]["OrderStatus"]> = ["pending", "paid", "refunded", "partially_refunded"];
export const organizationAccessTokenSortPropertyValues: ReadonlyArray<components["schemas"]["OrganizationAccessTokenSortProperty"]> = ["created_at", "-created_at", "comment", "-comment", "last_used_at", "-last_used_at", "organization_id", "-organization_id"];
export const organizationAvatarFileCreateServiceValues: ReadonlyArray<components["schemas"]["OrganizationAvatarFileCreate"]["service"]> = ["organization_avatar"];
export const organizationAvatarFileReadServiceValues: ReadonlyArray<components["schemas"]["OrganizationAvatarFileRead"]["service"]> = ["organization_avatar"];
export const organizationDetailsSwitching_fromValues: ReadonlyArray<components["schemas"]["OrganizationDetails"]["switching_from"]> = ["paddle", "lemon_squeezy", "gumroad", "stripe", "other"];
export const organizationSocialPlatformsValues: ReadonlyArray<components["schemas"]["OrganizationSocialPlatforms"]> = ["x", "github", "facebook", "instagram", "youtube", "tiktok", "linkedin", "other"];
export const organizationSortPropertyValues: ReadonlyArray<components["schemas"]["OrganizationSortProperty"]> = ["created_at", "-created_at", "slug", "-slug", "name", "-name"];
export const paymentProcessorValues: ReadonlyArray<components["schemas"]["PaymentProcessor"]> = ["stripe"];
export const paymentSortPropertyValues: ReadonlyArray<components["schemas"]["PaymentSortProperty"]> = ["created_at", "-created_at", "status", "-status", "amount", "-amount", "method", "-method"];
export const paymentStatusValues: ReadonlyArray<components["schemas"]["PaymentStatus"]> = ["pending", "succeeded", "failed"];
export const platformFeeTypeValues: ReadonlyArray<components["schemas"]["PlatformFeeType"]> = ["payment", "international_payment", "subscription", "invoice", "cross_border_transfer", "payout", "account", "dispute", "platform"];
export const pledgeStateValues: ReadonlyArray<components["schemas"]["PledgeState"]> = ["initiated", "created", "pending", "refunded", "disputed", "charge_disputed", "cancelled"];
export const processorValues: ReadonlyArray<components["schemas"]["Processor"]> = ["stripe", "open_collective"];
export const productBillingTypeValues: ReadonlyArray<components["schemas"]["ProductBillingType"]> = ["one_time", "recurring"];
export const productMediaFileCreateServiceValues: ReadonlyArray<components["schemas"]["ProductMediaFileCreate"]["service"]> = ["product_media"];
export const productMediaFileReadServiceValues: ReadonlyArray<components["schemas"]["ProductMediaFileRead"]["service"]> = ["product_media"];
export const productPriceCustomAmount_typeValues: ReadonlyArray<components["schemas"]["ProductPriceCustom"]["amount_type"]> = ["custom"];
export const productPriceFixedAmount_typeValues: ReadonlyArray<components["schemas"]["ProductPriceFixed"]["amount_type"]> = ["fixed"];
export const productPriceFreeAmount_typeValues: ReadonlyArray<components["schemas"]["ProductPriceFree"]["amount_type"]> = ["free"];
export const productPriceMeteredUnitAmount_typeValues: ReadonlyArray<components["schemas"]["ProductPriceMeteredUnit"]["amount_type"]> = ["metered_unit"];
export const productPriceTypeValues: ReadonlyArray<components["schemas"]["ProductPriceType"]> = ["one_time", "recurring"];
export const productSortPropertyValues: ReadonlyArray<components["schemas"]["ProductSortProperty"]> = ["created_at", "-created_at", "name", "-name", "price_amount_type", "-price_amount_type", "price_amount", "-price_amount"];
export const propertyAggregationFuncValues: ReadonlyArray<components["schemas"]["PropertyAggregation"]["func"]> = ["avg", "max", "min", "sum"];
export const refundReasonValues: ReadonlyArray<components["schemas"]["RefundReason"]> = ["duplicate", "fraudulent", "customer_request", "service_disruption", "satisfaction_guarantee", "other"];
export const refundSortPropertyValues: ReadonlyArray<components["schemas"]["RefundSortProperty"]> = ["created_at", "-created_at", "amount", "-amount"];
export const refundStatusValues: ReadonlyArray<components["schemas"]["RefundStatus"]> = ["pending", "succeeded", "failed", "canceled"];
export const scopeValues: ReadonlyArray<components["schemas"]["Scope"]> = ["openid", "profile", "email", "user:read", "admin", "web_default", "organizations:read", "organizations:write", "custom_fields:read", "custom_fields:write", "discounts:read", "discounts:write", "checkout_links:read", "checkout_links:write", "checkouts:read", "checkouts:write", "products:read", "products:write", "benefits:read", "benefits:write", "events:read", "events:write", "meters:read", "meters:write", "files:read", "files:write", "subscriptions:read", "subscriptions:write", "customers:read", "customers:write", "customer_meters:read", "customer_sessions:write", "orders:read", "refunds:read", "refunds:write", "payments:read", "metrics:read", "webhooks:read", "webhooks:write", "external_organizations:read", "license_keys:read", "license_keys:write", "repositories:read", "repositories:write", "issues:read", "issues:write", "customer_portal:read", "customer_portal:write", "notification_recipients:read", "notification_recipients:write"];
export const statusValues: ReadonlyArray<components["schemas"]["Status"]> = ["created", "onboarding_started", "under_review", "denied", "active"];
export const subTypeValues: ReadonlyArray<components["schemas"]["SubType"]> = ["user", "organization"];
export const subscriptionProrationBehaviorValues: ReadonlyArray<components["schemas"]["SubscriptionProrationBehavior"]> = ["invoice", "prorate"];
export const subscriptionRecurringIntervalValues: ReadonlyArray<components["schemas"]["SubscriptionRecurringInterval"]> = ["month", "year"];
export const subscriptionSortPropertyValues: ReadonlyArray<components["schemas"]["SubscriptionSortProperty"]> = ["customer", "-customer", "status", "-status", "started_at", "-started_at", "current_period_end", "-current_period_end", "amount", "-amount", "product", "-product", "discount", "-discount"];
export const subscriptionStatusValues: ReadonlyArray<components["schemas"]["SubscriptionStatus"]> = ["incomplete", "incomplete_expired", "trialing", "active", "past_due", "canceled", "unpaid"];
export const taxIDFormatValues: ReadonlyArray<components["schemas"]["TaxIDFormat"]> = ["ad_nrt", "ae_trn", "ar_cuit", "au_abn", "au_arn", "bg_uic", "bh_vat", "bo_tin", "br_cnpj", "br_cpf", "ca_bn", "ca_gst_hst", "ca_pst_bc", "ca_pst_mb", "ca_pst_sk", "ca_qst", "ch_uid", "ch_vat", "cl_tin", "cn_tin", "co_nit", "cr_tin", "de_stn", "do_rcn", "ec_ruc", "eg_tin", "es_cif", "eu_oss_vat", "eu_vat", "gb_vat", "ge_vat", "hk_br", "hr_oib", "hu_tin", "id_npwp", "il_vat", "in_gst", "is_vat", "jp_cn", "jp_rn", "jp_trn", "ke_pin", "kr_brn", "kz_bin", "li_uid", "mx_rfc", "my_frp", "my_itn", "my_sst", "ng_tin", "no_vat", "no_voec", "nz_gst", "om_vat", "pe_ruc", "ph_tin", "ro_tin", "rs_pib", "ru_inn", "ru_kpp", "sa_vat", "sg_gst", "sg_uen", "si_tin", "sv_nit", "th_vat", "tr_tin", "tw_vat", "ua_vat", "us_ein", "uy_ruc", "ve_rif", "vn_tin", "za_vat"];
export const timeIntervalValues: ReadonlyArray<components["schemas"]["TimeInterval"]> = ["year", "month", "week", "day", "hour"];
export const transactionSortPropertyValues: ReadonlyArray<components["schemas"]["TransactionSortProperty"]> = ["created_at", "-created_at", "amount", "-amount"];
export const transactionTypeValues: ReadonlyArray<components["schemas"]["TransactionType"]> = ["payment", "processor_fee", "refund", "refund_reversal", "dispute", "dispute_reversal", "balance", "payout"];
export const userSignupAttributionIntentValues: ReadonlyArray<components["schemas"]["UserSignupAttribution"]["intent"]> = ["creator", "pledge", "purchase", "subscription", "newsletter_subscription"];
export const webhookEventTypeValues: ReadonlyArray<components["schemas"]["WebhookEventType"]> = ["checkout.created", "checkout.updated", "customer.created", "customer.updated", "customer.deleted", "customer.state_changed", "order.created", "order.updated", "order.paid", "order.refunded", "subscription.created", "subscription.updated", "subscription.active", "subscription.canceled", "subscription.uncanceled", "subscription.revoked", "refund.created", "refund.updated", "product.created", "product.updated", "benefit.created", "benefit.updated", "benefit_grant.created", "benefit_grant.cycled", "benefit_grant.updated", "benefit_grant.revoked", "organization.updated"];
export const webhookFormatValues: ReadonlyArray<components["schemas"]["WebhookFormat"]> = ["raw", "discord", "slack"];
export const revokeTokenRequestToken_type_hintValues: ReadonlyArray<components["schemas"]["RevokeTokenRequest"]["token_type_hint"]> = ["access_token", "refresh_token"];
export const introspectTokenRequestToken_type_hintValues: ReadonlyArray<components["schemas"]["IntrospectTokenRequest"]["token_type_hint"]> = ["access_token", "refresh_token"];
