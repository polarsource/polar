/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v4-mini";
import { remap as remap$ } from "../../lib/primitives.js";
import {
  AggregationFunction,
  AggregationFunction$outboundSchema,
} from "../components/aggregationfunction.js";
import {
  MetadataQuery,
  MetadataQuery$Outbound,
  MetadataQuery$outboundSchema,
} from "../components/subscriptionslist.js";
import {
  TimeInterval,
  TimeInterval$outboundSchema,
} from "../components/timeinterval.js";

/**
 * Filter by customer ID.
 */
export type MetersQuantitiesQueryParamCustomerIDFilter = string | Array<string>;

/**
 * Filter by external customer ID.
 */
export type MetersQuantitiesQueryParamExternalCustomerIDFilter =
  | string
  | Array<string>;

export type MetersQuantitiesRequest = {
  /**
   * The meter ID.
   */
  id: string;
  /**
   * Start timestamp.
   */
  startTimestamp: Date;
  /**
   * End timestamp.
   */
  endTimestamp: Date;
  /**
   * Interval between two timestamps.
   */
  interval: TimeInterval;
  /**
   * Filter by customer ID.
   */
  customerId?: string | Array<string> | null | undefined;
  /**
   * Filter by external customer ID.
   */
  externalCustomerId?: string | Array<string> | null | undefined;
  /**
   * If set, will first compute the quantities per customer before aggregating them using the given function. If not set, the quantities will be aggregated across all events.
   */
  customerAggregationFunction?: AggregationFunction | null | undefined;
  /**
   * Filter by metadata key-value pairs. It uses the `deepObject` style, e.g. `?metadata[key]=value`.
   */
  metadata?: { [k: string]: MetadataQuery } | null | undefined;
};

/** @internal */
export type MetersQuantitiesQueryParamCustomerIDFilter$Outbound =
  | string
  | Array<string>;

/** @internal */
export const MetersQuantitiesQueryParamCustomerIDFilter$outboundSchema:
  z.ZodMiniType<
    MetersQuantitiesQueryParamCustomerIDFilter$Outbound,
    MetersQuantitiesQueryParamCustomerIDFilter
  > = z.union([z.string(), z.array(z.string())]);

export function metersQuantitiesQueryParamCustomerIDFilterToJSON(
  metersQuantitiesQueryParamCustomerIDFilter:
    MetersQuantitiesQueryParamCustomerIDFilter,
): string {
  return JSON.stringify(
    MetersQuantitiesQueryParamCustomerIDFilter$outboundSchema.parse(
      metersQuantitiesQueryParamCustomerIDFilter,
    ),
  );
}

/** @internal */
export type MetersQuantitiesQueryParamExternalCustomerIDFilter$Outbound =
  | string
  | Array<string>;

/** @internal */
export const MetersQuantitiesQueryParamExternalCustomerIDFilter$outboundSchema:
  z.ZodMiniType<
    MetersQuantitiesQueryParamExternalCustomerIDFilter$Outbound,
    MetersQuantitiesQueryParamExternalCustomerIDFilter
  > = z.union([z.string(), z.array(z.string())]);

export function metersQuantitiesQueryParamExternalCustomerIDFilterToJSON(
  metersQuantitiesQueryParamExternalCustomerIDFilter:
    MetersQuantitiesQueryParamExternalCustomerIDFilter,
): string {
  return JSON.stringify(
    MetersQuantitiesQueryParamExternalCustomerIDFilter$outboundSchema.parse(
      metersQuantitiesQueryParamExternalCustomerIDFilter,
    ),
  );
}

/** @internal */
export type MetersQuantitiesRequest$Outbound = {
  id: string;
  start_timestamp: string;
  end_timestamp: string;
  interval: string;
  customer_id?: string | Array<string> | null | undefined;
  external_customer_id?: string | Array<string> | null | undefined;
  customer_aggregation_function?: string | null | undefined;
  metadata?: { [k: string]: MetadataQuery$Outbound } | null | undefined;
};

/** @internal */
export const MetersQuantitiesRequest$outboundSchema: z.ZodMiniType<
  MetersQuantitiesRequest$Outbound,
  MetersQuantitiesRequest
> = z.pipe(
  z.object({
    id: z.string(),
    startTimestamp: z.pipe(z.date(), z.transform(v => v.toISOString())),
    endTimestamp: z.pipe(z.date(), z.transform(v => v.toISOString())),
    interval: TimeInterval$outboundSchema,
    customerId: z.optional(
      z.nullable(z.union([z.string(), z.array(z.string())])),
    ),
    externalCustomerId: z.optional(
      z.nullable(z.union([z.string(), z.array(z.string())])),
    ),
    customerAggregationFunction: z.optional(
      z.nullable(AggregationFunction$outboundSchema),
    ),
    metadata: z.optional(
      z.nullable(z.record(z.string(), MetadataQuery$outboundSchema)),
    ),
  }),
  z.transform((v) => {
    return remap$(v, {
      startTimestamp: "start_timestamp",
      endTimestamp: "end_timestamp",
      customerId: "customer_id",
      externalCustomerId: "external_customer_id",
      customerAggregationFunction: "customer_aggregation_function",
    });
  }),
);

export function metersQuantitiesRequestToJSON(
  metersQuantitiesRequest: MetersQuantitiesRequest,
): string {
  return JSON.stringify(
    MetersQuantitiesRequest$outboundSchema.parse(metersQuantitiesRequest),
  );
}
