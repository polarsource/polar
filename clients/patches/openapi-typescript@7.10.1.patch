diff --git a/dist/index.d.cts b/dist/index.d.cts
index 7574dccb07513b11366a8f5f92730f5987354e02..539bdd80864ab319e08da4bb46bf344b373220f1 100644
--- a/dist/index.d.cts
+++ b/dist/index.d.cts
@@ -407,7 +407,7 @@ interface AnnotatedSchemaObject {
 }
 declare function addJSDocComment(schemaObject: AnnotatedSchemaObject, node: ts.PropertySignature): void;
 type OapiRefResolved = Referenced<ParameterObject>;
-declare function oapiRef(path: string, resolved?: OapiRefResolved): ts.TypeNode;
+declare function oapiRef(path: string, resolved?: OapiRefResolved, deep?: boolean): ts.TypeNode;
 interface AstToStringOptions {
     fileName?: string;
     sourceText?: string;
@@ -495,8 +495,8 @@ declare function transformResponseObject(responseObject: ResponseObject, options
 
 declare function transformResponsesObject(responsesObject: ResponsesObject, options: TransformNodeOptions): ts.TypeNode;
 
-declare function transformSchemaObject(schemaObject: SchemaObject | ReferenceObject, options: TransformNodeOptions): ts.TypeNode;
-declare function transformSchemaObjectWithComposition(schemaObject: SchemaObject | ReferenceObject, options: TransformNodeOptions): ts.TypeNode;
+declare function transformSchemaObject(schemaObject: SchemaObject | ReferenceObject, options: TransformNodeOptions, fromAdditionalProperties?: boolean): ts.TypeNode;
+declare function transformSchemaObjectWithComposition(schemaObject: SchemaObject | ReferenceObject, options: TransformNodeOptions, fromAdditionalProperties?: boolean): ts.TypeNode;
 
 declare const COMMENT_HEADER = "/**\n * This file was auto-generated by openapi-typescript.\n * Do not make direct changes to the file.\n */\n\n";
 declare function openapiTS(source: string | URL | OpenAPI3 | Buffer | Readable, options?: OpenAPITSOptions): Promise<ts.Node[]>;
diff --git a/dist/index.d.mts b/dist/index.d.mts
index e0eaea7b5812ad4efcaa838a945edc0c5fd6af77..e53f927efa14cd9adf1d3ae9db716e2b787e0233 100644
--- a/dist/index.d.mts
+++ b/dist/index.d.mts
@@ -407,7 +407,7 @@ interface AnnotatedSchemaObject {
 }
 declare function addJSDocComment(schemaObject: AnnotatedSchemaObject, node: ts.PropertySignature): void;
 type OapiRefResolved = Referenced<ParameterObject>;
-declare function oapiRef(path: string, resolved?: OapiRefResolved): ts.TypeNode;
+declare function oapiRef(path: string, resolved?: OapiRefResolved, deep?: boolean): ts.TypeNode;
 interface AstToStringOptions {
     fileName?: string;
     sourceText?: string;
@@ -495,8 +495,8 @@ declare function transformResponseObject(responseObject: ResponseObject, options
 
 declare function transformResponsesObject(responsesObject: ResponsesObject, options: TransformNodeOptions): ts.TypeNode;
 
-declare function transformSchemaObject(schemaObject: SchemaObject | ReferenceObject, options: TransformNodeOptions): ts.TypeNode;
-declare function transformSchemaObjectWithComposition(schemaObject: SchemaObject | ReferenceObject, options: TransformNodeOptions): ts.TypeNode;
+declare function transformSchemaObject(schemaObject: SchemaObject | ReferenceObject, options: TransformNodeOptions, fromAdditionalProperties?: boolean): ts.TypeNode;
+declare function transformSchemaObjectWithComposition(schemaObject: SchemaObject | ReferenceObject, options: TransformNodeOptions, fromAdditionalProperties?: boolean): ts.TypeNode;
 
 declare const COMMENT_HEADER = "/**\n * This file was auto-generated by openapi-typescript.\n * Do not make direct changes to the file.\n */\n\n";
 declare function openapiTS(source: string | URL | OpenAPI3 | Buffer | Readable, options?: OpenAPITSOptions): Promise<ts.Node[]>;
diff --git a/dist/index.d.ts b/dist/index.d.ts
index 7574dccb07513b11366a8f5f92730f5987354e02..539bdd80864ab319e08da4bb46bf344b373220f1 100644
--- a/dist/index.d.ts
+++ b/dist/index.d.ts
@@ -407,7 +407,7 @@ interface AnnotatedSchemaObject {
 }
 declare function addJSDocComment(schemaObject: AnnotatedSchemaObject, node: ts.PropertySignature): void;
 type OapiRefResolved = Referenced<ParameterObject>;
-declare function oapiRef(path: string, resolved?: OapiRefResolved): ts.TypeNode;
+declare function oapiRef(path: string, resolved?: OapiRefResolved, deep?: boolean): ts.TypeNode;
 interface AstToStringOptions {
     fileName?: string;
     sourceText?: string;
@@ -495,8 +495,8 @@ declare function transformResponseObject(responseObject: ResponseObject, options
 
 declare function transformResponsesObject(responsesObject: ResponsesObject, options: TransformNodeOptions): ts.TypeNode;
 
-declare function transformSchemaObject(schemaObject: SchemaObject | ReferenceObject, options: TransformNodeOptions): ts.TypeNode;
-declare function transformSchemaObjectWithComposition(schemaObject: SchemaObject | ReferenceObject, options: TransformNodeOptions): ts.TypeNode;
+declare function transformSchemaObject(schemaObject: SchemaObject | ReferenceObject, options: TransformNodeOptions, fromAdditionalProperties?: boolean): ts.TypeNode;
+declare function transformSchemaObjectWithComposition(schemaObject: SchemaObject | ReferenceObject, options: TransformNodeOptions, fromAdditionalProperties?: boolean): ts.TypeNode;
 
 declare const COMMENT_HEADER = "/**\n * This file was auto-generated by openapi-typescript.\n * Do not make direct changes to the file.\n */\n\n";
 declare function openapiTS(source: string | URL | OpenAPI3 | Buffer | Readable, options?: OpenAPITSOptions): Promise<ts.Node[]>;
diff --git a/dist/lib/ts.cjs b/dist/lib/ts.cjs
index f82d2112011268c636186732d8f6418fae037e78..7c7e8349cdf13fa046e013878f707ad76ae55a23 100644
--- a/dist/lib/ts.cjs
+++ b/dist/lib/ts.cjs
@@ -108,7 +108,7 @@ function addIndexedAccess(node, ...segments) {
     );
   }, node);
 }
-function oapiRef(path, resolved) {
+function oapiRef(path, resolved, deep = false) {
   const { pointer } = refUtils_js.parseRef(path);
   if (pointer.length === 0) {
     throw new Error(`Error parsing $ref: ${path}. Is this a valid $ref?`);
@@ -118,7 +118,9 @@ function oapiRef(path, resolved) {
   const leadingSegments = pointer.slice(1, 3);
   const restSegments = pointer.slice(3);
   const leadingType = addIndexedAccess(
-    ts__default.factory.createTypeReferenceNode(ts__default.factory.createIdentifier(String(initialSegment))),
+    ts__default.factory.createTypeReferenceNode(
+      ts__default.factory.createIdentifier(deep ? `FlattenedDeepRequired<${String(initialSegment)}>` : String(initialSegment))
+    ),
     ...leadingSegments
   );
   return restSegments.reduce((acc, segment, index, original) => {
@@ -205,6 +207,14 @@ function tsEnum(name, members, metadata, options) {
 function tsArrayLiteralExpression(name, elementType, values, options) {
   let variableName = sanitizeMemberName(name);
   variableName = `${variableName[0].toLowerCase()}${variableName.substring(1)}`;
+  if (options?.injectFooter && !options.injectFooter.some(
+    (node) => ts__default.isTypeAliasDeclaration(node) && node?.name?.escapedText === "FlattenedDeepRequired"
+  )) {
+    const helper = stringToAST(
+      "type FlattenedDeepRequired<T> = { [K in keyof T]-?: FlattenedDeepRequired<T[K] extends unknown[] | undefined | null ? Extract<T[K], unknown[]>[number] : T[K]>; };"
+    )[0];
+    options.injectFooter.push(helper);
+  }
   const arrayType = options?.readonly ? tsReadonlyArray(elementType, options.injectFooter) : ts__default.factory.createArrayTypeNode(elementType);
   return ts__default.factory.createVariableStatement(
     options ? tsModifiers({ export: options.export ?? false }) : void 0,
diff --git a/dist/lib/ts.cjs.map b/dist/lib/ts.cjs.map
index abbfe7849fcbc2f8452f27bf4af9afb3260690ab..3612561dbbc6b83ae4a8c058dc4f3f636a17c949 100644
--- a/dist/lib/ts.cjs.map
+++ b/dist/lib/ts.cjs.map
@@ -1 +1 @@
-{"version":3,"file":"ts.cjs","sources":["../../src/lib/ts.ts"],"sourcesContent":["import type { OasRef, Referenced } from \"@redocly/openapi-core\";\nimport { parseRef } from \"@redocly/openapi-core/lib/ref-utils.js\";\nimport ts, { type LiteralTypeNode, type TypeLiteralNode } from \"typescript\";\nimport type { ParameterObject } from \"../types.js\";\n\nexport const JS_PROPERTY_INDEX_RE = /^[A-Za-z_$][A-Za-z_$0-9]*$/;\nexport const JS_ENUM_INVALID_CHARS_RE = /[^A-Za-z_$0-9]+(.)?/g;\nexport const JS_PROPERTY_INDEX_INVALID_CHARS_RE = /[^A-Za-z_$0-9]+/g;\nexport const SPECIAL_CHARACTER_MAP: Record<string, string> = {\n  \"+\": \"Plus\",\n  // Add more mappings as needed\n};\n\nexport const BOOLEAN = ts.factory.createKeywordTypeNode(ts.SyntaxKind.BooleanKeyword);\nexport const FALSE = ts.factory.createLiteralTypeNode(ts.factory.createFalse());\nexport const NEVER = ts.factory.createKeywordTypeNode(ts.SyntaxKind.NeverKeyword);\nexport const NULL = ts.factory.createLiteralTypeNode(ts.factory.createNull());\nexport const NUMBER = ts.factory.createKeywordTypeNode(ts.SyntaxKind.NumberKeyword);\nexport const QUESTION_TOKEN = ts.factory.createToken(ts.SyntaxKind.QuestionToken);\nexport const STRING = ts.factory.createKeywordTypeNode(ts.SyntaxKind.StringKeyword);\nexport const TRUE = ts.factory.createLiteralTypeNode(ts.factory.createTrue());\nexport const UNDEFINED = ts.factory.createKeywordTypeNode(ts.SyntaxKind.UndefinedKeyword);\nexport const UNKNOWN = ts.factory.createKeywordTypeNode(ts.SyntaxKind.UnknownKeyword);\n\nconst LB_RE = /\\r?\\n/g;\nconst COMMENT_RE = /\\*\\//g;\n\nexport interface AnnotatedSchemaObject {\n  const?: unknown; // jsdoc without value\n  default?: unknown; // jsdoc with value\n  deprecated?: boolean; // jsdoc without value\n  description?: string; // jsdoc with value\n  enum?: unknown[]; // jsdoc without value\n  example?: string; // jsdoc with value\n  examples?: unknown;\n  format?: string; // not jsdoc\n  nullable?: boolean; // Node information\n  summary?: string; // not jsdoc\n  title?: string; // not jsdoc\n  type?: string | string[]; // Type of node\n}\n\n/**\n * Preparing comments from fields\n * @see {comment} for output examples\n * @returns void if not comments or jsdoc format comment string\n */\nexport function addJSDocComment(schemaObject: AnnotatedSchemaObject, node: ts.PropertySignature): void {\n  if (!schemaObject || typeof schemaObject !== \"object\" || Array.isArray(schemaObject)) {\n    return;\n  }\n  const output: string[] = [];\n\n  // Not JSDoc tags: [title, format]\n  if (schemaObject.title) {\n    output.push(schemaObject.title.trim().replace(LB_RE, \"\\n *     \"));\n  }\n  if (schemaObject.summary) {\n    output.push(schemaObject.summary.trim().replace(LB_RE, \"\\n *     \"));\n  }\n  if (schemaObject.format) {\n    output.push(`Format: ${schemaObject.format}`);\n  }\n\n  // JSDoc tags without value\n  // 'Deprecated' without value\n  if (schemaObject.deprecated) {\n    output.push(\"@deprecated\");\n  }\n\n  // JSDoc tags with value\n  const supportedJsDocTags = [\"description\", \"default\", \"example\"] as const;\n  for (const field of supportedJsDocTags) {\n    const allowEmptyString = field === \"default\" || field === \"example\";\n    if (schemaObject[field] === undefined) {\n      continue;\n    }\n    if (schemaObject[field] === \"\" && !allowEmptyString) {\n      continue;\n    }\n    const serialized =\n      typeof schemaObject[field] === \"object\" ? JSON.stringify(schemaObject[field], null, 2) : schemaObject[field];\n    output.push(`@${field} ${String(serialized).trim().replace(LB_RE, \"\\n *     \")}`);\n  }\n\n  if (Array.isArray(schemaObject.examples)) {\n    for (const example of schemaObject.examples) {\n      const serialized = typeof example === \"object\" ? JSON.stringify(example, null, 2) : example;\n      output.push(`@example ${String(serialized).trim().replace(LB_RE, \"\\n *     \")}`);\n    }\n  }\n\n  // JSDoc 'Constant' without value\n  if (\"const\" in schemaObject) {\n    output.push(\"@constant\");\n  }\n\n  // JSDoc 'Enum' with type\n  if (schemaObject.enum) {\n    let type = \"unknown\";\n    if (Array.isArray(schemaObject.type)) {\n      type = schemaObject.type.join(\"|\");\n    } else if (typeof schemaObject.type === \"string\") {\n      type = schemaObject.type;\n    }\n    output.push(`@enum {${type}${schemaObject.nullable ? \"|null\" : \"\"}}`);\n  }\n\n  // attach comment if it has content\n\n  if (output.length) {\n    // Check if any output item contains multi-line content (has internal line breaks)\n    const hasMultiLineContent = output.some((item) => item.includes(\"\\n\"));\n\n    let text =\n      output.length === 1 && !hasMultiLineContent ? `* ${output.join(\"\\n\")} ` : `*\\n * ${output.join(\"\\n * \")}\\n `;\n    text = text.replace(COMMENT_RE, \"*\\\\/\"); // prevent inner comments from leaking\n\n    ts.addSyntheticLeadingComment(\n      /* node               */ node,\n      /* kind               */ ts.SyntaxKind.MultiLineCommentTrivia, // note: MultiLine just refers to a \"/* */\" comment\n      /* text               */ text,\n      /* hasTrailingNewLine */ true,\n    );\n  }\n}\n\nfunction isOasRef<T>(obj: Referenced<T>): obj is OasRef {\n  return Boolean((obj as OasRef).$ref);\n}\ntype OapiRefResolved = Referenced<ParameterObject>;\n\nfunction isParameterObject(obj: OapiRefResolved | undefined): obj is ParameterObject {\n  return Boolean(obj && !isOasRef(obj) && obj.in);\n}\n\nfunction addIndexedAccess(node: ts.TypeReferenceNode | ts.IndexedAccessTypeNode, ...segments: readonly string[]) {\n  return segments.reduce((acc, segment) => {\n    return ts.factory.createIndexedAccessTypeNode(\n      acc,\n      ts.factory.createLiteralTypeNode(\n        typeof segment === \"number\"\n          ? ts.factory.createNumericLiteral(segment)\n          : ts.factory.createStringLiteral(segment),\n      ),\n    );\n  }, node);\n}\n\n/**\n * Convert OpenAPI ref into TS indexed access node (ex: `components[\"schemas\"][\"Foo\"]`)\n * `path` is a JSON Pointer to a location within an OpenAPI document.\n * Transform it into a TypeScript type reference into the generated types.\n *\n * In most cases the structures of the openapi-typescript generated types and the\n * JSON Pointer paths into the OpenAPI document are the same. However, in some cases\n * special transformations are necessary to account for the ways they differ.\n *   * Object schemas\n *       $refs into the `properties` of object schemas are valid, but openapi-typescript\n *       flattens these objects, so we omit  so the index into the schema skips [\"properties\"]\n *   * Parameters\n *       $refs into the `parameters` of paths are valid, but openapi-ts represents\n *       them according to their type; path, query, header, etc… so in these cases we\n *       must check the parameter definition to determine the how to index into\n *       the openapi-typescript type.\n **/\nexport function oapiRef(path: string, resolved?: OapiRefResolved): ts.TypeNode {\n  const { pointer } = parseRef(path);\n  if (pointer.length === 0) {\n    throw new Error(`Error parsing $ref: ${path}. Is this a valid $ref?`);\n  }\n\n  const parametersObject = isParameterObject(resolved);\n\n  // Initial segments are handled in a fixed , then remaining segments are treated\n  // according to heuristics based on the initial segments\n  const initialSegment = pointer[0];\n  const leadingSegments = pointer.slice(1, 3);\n  const restSegments = pointer.slice(3);\n\n  const leadingType = addIndexedAccess(\n    ts.factory.createTypeReferenceNode(ts.factory.createIdentifier(String(initialSegment))),\n    ...leadingSegments,\n  );\n\n  return restSegments.reduce<ts.TypeReferenceNode | ts.IndexedAccessTypeNode>((acc, segment, index, original) => {\n    // Skip `properties` items when in the middle of the pointer\n    // See: https://github.com/openapi-ts/openapi-typescript/issues/1742\n    if (segment === \"properties\") {\n      return acc;\n    }\n\n    if (parametersObject && index === original.length - 1) {\n      return addIndexedAccess(acc, resolved.in, resolved.name);\n    }\n\n    return addIndexedAccess(acc, segment);\n  }, leadingType);\n}\n\nexport interface AstToStringOptions {\n  fileName?: string;\n  sourceText?: string;\n  formatOptions?: ts.PrinterOptions;\n}\n\n/** Convert TypeScript AST to string */\nexport function astToString(\n  ast: ts.Node | ts.Node[] | ts.TypeElement | ts.TypeElement[],\n  options?: AstToStringOptions,\n): string {\n  const sourceFile = ts.createSourceFile(\n    options?.fileName ?? \"openapi-ts.ts\",\n    options?.sourceText ?? \"\",\n    ts.ScriptTarget.ESNext,\n    false,\n    ts.ScriptKind.TS,\n  );\n\n  // @ts-expect-error it’s OK to overwrite statements once\n  sourceFile.statements = ts.factory.createNodeArray(Array.isArray(ast) ? ast : [ast]);\n\n  const printer = ts.createPrinter({\n    newLine: ts.NewLineKind.LineFeed,\n    removeComments: false,\n    ...options?.formatOptions,\n  });\n  return printer.printFile(sourceFile);\n}\n\n/** Convert an arbitrary string to TS (assuming it’s valid) */\nexport function stringToAST(source: string): unknown[] {\n  return ts.createSourceFile(\n    /* fileName        */ \"stringInput\",\n    /* sourceText      */ source,\n    /* languageVersion */ ts.ScriptTarget.ESNext,\n    /* setParentNodes  */ undefined,\n    /* scriptKind      */ undefined,\n  ).statements as any;\n}\n\n/**\n * Deduplicate simple primitive types from an array of nodes\n * Note: won’t deduplicate complex types like objects\n */\nexport function tsDedupe(types: ts.TypeNode[]): ts.TypeNode[] {\n  const encounteredTypes = new Set<number>();\n  const filteredTypes: ts.TypeNode[] = [];\n  for (const t of types) {\n    // only mark for deduplication if this is not a const (\"text\" means it is a const)\n    if (!(\"text\" in ((t as LiteralTypeNode).literal ?? t))) {\n      const { kind } = (t as LiteralTypeNode).literal ?? t;\n      if (encounteredTypes.has(kind)) {\n        continue;\n      }\n      if (tsIsPrimitive(t)) {\n        encounteredTypes.add(kind);\n      }\n    }\n    filteredTypes.push(t);\n  }\n  return filteredTypes;\n}\n\nexport const enumCache = new Map<string, ts.EnumDeclaration>();\n\n/** Create a TS enum (with sanitized name and members) */\nexport function tsEnum(\n  name: string,\n  members: (string | number)[],\n  metadata?: { name?: string; description?: string | null }[],\n  options?: { export?: boolean; shouldCache?: boolean },\n) {\n  let enumName = sanitizeMemberName(name);\n  enumName = `${enumName[0].toUpperCase()}${enumName.substring(1)}`;\n  let key = \"\";\n  if (options?.shouldCache) {\n    key = `${members\n      .slice(0)\n      .sort()\n      .map((v, i) => {\n        return `${metadata?.[i]?.name ?? String(v)}:${metadata?.[i]?.description || \"\"}`;\n      })\n      .join(\",\")}`;\n    if (enumCache.has(key)) {\n      return enumCache.get(key) as ts.EnumDeclaration;\n    }\n  }\n  const enumDeclaration = ts.factory.createEnumDeclaration(\n    /* modifiers */ options ? tsModifiers({ export: options.export ?? false }) : undefined,\n    /* name      */ enumName,\n    /* members   */ members.map((value, i) => tsEnumMember(value, metadata?.[i])),\n  );\n  options?.shouldCache && enumCache.set(key, enumDeclaration);\n  return enumDeclaration;\n}\n\n/** Create an exported TS array literal expression  */\nexport function tsArrayLiteralExpression(\n  name: string,\n  elementType: ts.TypeNode,\n  values: (string | number)[],\n  options?: { export?: boolean; readonly?: boolean; injectFooter?: ts.Node[] },\n) {\n  let variableName = sanitizeMemberName(name);\n  variableName = `${variableName[0].toLowerCase()}${variableName.substring(1)}`;\n\n  const arrayType = options?.readonly\n    ? tsReadonlyArray(elementType, options.injectFooter)\n    : ts.factory.createArrayTypeNode(elementType);\n\n  return ts.factory.createVariableStatement(\n    options ? tsModifiers({ export: options.export ?? false }) : undefined,\n    ts.factory.createVariableDeclarationList(\n      [\n        ts.factory.createVariableDeclaration(\n          variableName,\n          undefined,\n          arrayType,\n          ts.factory.createArrayLiteralExpression(\n            values.map((value) => {\n              if (typeof value === \"number\") {\n                if (value < 0) {\n                  return ts.factory.createPrefixUnaryExpression(\n                    ts.SyntaxKind.MinusToken,\n                    ts.factory.createNumericLiteral(Math.abs(value)),\n                  );\n                } else {\n                  return ts.factory.createNumericLiteral(value);\n                }\n              } else {\n                return ts.factory.createStringLiteral(value);\n              }\n            }),\n          ),\n        ),\n      ],\n      ts.NodeFlags.Const,\n    ),\n  );\n}\n\nfunction sanitizeMemberName(name: string) {\n  let sanitizedName = name.replace(JS_ENUM_INVALID_CHARS_RE, (c) => {\n    const last = c[c.length - 1];\n    return JS_PROPERTY_INDEX_INVALID_CHARS_RE.test(last) ? \"\" : last.toUpperCase();\n  });\n  if (Number(name[0]) >= 0) {\n    sanitizedName = `Value${name}`;\n  }\n  return sanitizedName;\n}\n\n/** Sanitize TS enum member expression */\nexport function tsEnumMember(value: string | number, metadata: { name?: string; description?: string | null } = {}) {\n  let name = metadata.name ?? String(value);\n  if (!JS_PROPERTY_INDEX_RE.test(name)) {\n    if (Number(name[0]) >= 0) {\n      name = `Value${name}`.replace(\".\", \"_\"); // don't forged decimals;\n    } else if (name[0] === \"-\") {\n      name = `ValueMinus${name.slice(1)}`;\n    }\n\n    const invalidCharMatch = name.match(JS_PROPERTY_INDEX_INVALID_CHARS_RE);\n    if (invalidCharMatch) {\n      if (invalidCharMatch[0] === name) {\n        name = `\"${name}\"`;\n      } else {\n        name = name.replace(JS_PROPERTY_INDEX_INVALID_CHARS_RE, (s) => {\n          return s in SPECIAL_CHARACTER_MAP ? SPECIAL_CHARACTER_MAP[s] : \"_\";\n        });\n      }\n    }\n  }\n\n  let member: ts.EnumMember;\n  if (typeof value === \"number\") {\n    const literal =\n      value < 0\n        ? ts.factory.createPrefixUnaryExpression(\n            ts.SyntaxKind.MinusToken,\n            ts.factory.createNumericLiteral(Math.abs(value)),\n          )\n        : ts.factory.createNumericLiteral(value);\n\n    member = ts.factory.createEnumMember(name, literal);\n  } else {\n    member = ts.factory.createEnumMember(name, ts.factory.createStringLiteral(value));\n  }\n\n  const trimmedDescription = metadata.description?.trim();\n  if (trimmedDescription === undefined || trimmedDescription === null || trimmedDescription === \"\") {\n    return member;\n  }\n\n  return ts.addSyntheticLeadingComment(member, ts.SyntaxKind.SingleLineCommentTrivia, ` ${trimmedDescription}`, true);\n}\n\n/** Create an intersection type */\nexport function tsIntersection(types: ts.TypeNode[]): ts.TypeNode {\n  if (types.length === 0) {\n    return NEVER;\n  }\n  if (types.length === 1) {\n    return types[0];\n  }\n  return ts.factory.createIntersectionTypeNode(tsDedupe(types));\n}\n\n/** Is this a primitive type (string, number, boolean, null, undefined)? */\nexport function tsIsPrimitive(type: ts.TypeNode): boolean {\n  if (!type) {\n    return true;\n  }\n  return (\n    ts.SyntaxKind[type.kind] === \"BooleanKeyword\" ||\n    ts.SyntaxKind[type.kind] === \"NeverKeyword\" ||\n    ts.SyntaxKind[type.kind] === \"NullKeyword\" ||\n    ts.SyntaxKind[type.kind] === \"NumberKeyword\" ||\n    ts.SyntaxKind[type.kind] === \"StringKeyword\" ||\n    ts.SyntaxKind[type.kind] === \"UndefinedKeyword\" ||\n    (\"literal\" in type && tsIsPrimitive(type.literal as TypeLiteralNode))\n  );\n}\n\n/** Create a literal type */\nexport function tsLiteral(value: unknown): ts.TypeNode {\n  if (typeof value === \"string\") {\n    // workaround for UTF-8: https://github.com/microsoft/TypeScript/issues/36174\n    return ts.factory.createIdentifier(JSON.stringify(value)) as unknown as ts.TypeNode;\n  }\n  if (typeof value === \"number\") {\n    const literal =\n      value < 0\n        ? ts.factory.createPrefixUnaryExpression(\n            ts.SyntaxKind.MinusToken,\n            ts.factory.createNumericLiteral(Math.abs(value)),\n          )\n        : ts.factory.createNumericLiteral(value);\n    return ts.factory.createLiteralTypeNode(literal);\n  }\n  if (typeof value === \"boolean\") {\n    return value === true ? TRUE : FALSE;\n  }\n  if (value === null) {\n    return NULL;\n  }\n  if (Array.isArray(value)) {\n    if (value.length === 0) {\n      return ts.factory.createArrayTypeNode(NEVER);\n    }\n    return ts.factory.createTupleTypeNode(value.map((v: unknown) => tsLiteral(v)));\n  }\n  if (typeof value === \"object\") {\n    const keys: ts.TypeElement[] = [];\n    for (const [k, v] of Object.entries(value)) {\n      keys.push(\n        ts.factory.createPropertySignature(\n          /* modifiers     */ undefined,\n          /* name          */ tsPropertyIndex(k),\n          /* questionToken */ undefined,\n          /* type          */ tsLiteral(v),\n        ),\n      );\n    }\n    return keys.length ? ts.factory.createTypeLiteralNode(keys) : tsRecord(STRING, NEVER);\n  }\n  return UNKNOWN;\n}\n\n/** Modifiers (readonly) */\nexport function tsModifiers(modifiers: { readonly?: boolean; export?: boolean }): ts.Modifier[] {\n  const typeMods: ts.Modifier[] = [];\n  if (modifiers.export) {\n    typeMods.push(ts.factory.createModifier(ts.SyntaxKind.ExportKeyword));\n  }\n  if (modifiers.readonly) {\n    typeMods.push(ts.factory.createModifier(ts.SyntaxKind.ReadonlyKeyword));\n  }\n  return typeMods;\n}\n\n/** Create a T | null union */\nexport function tsNullable(types: ts.TypeNode[]): ts.TypeNode {\n  return ts.factory.createUnionTypeNode([...types, NULL]);\n}\n\n/** Create a TS Omit<X, Y> type */\nexport function tsOmit(type: ts.TypeNode, keys: string[]): ts.TypeNode {\n  return ts.factory.createTypeReferenceNode(ts.factory.createIdentifier(\"Omit\"), [\n    type,\n    ts.factory.createUnionTypeNode(keys.map((k) => tsLiteral(k))),\n  ]);\n}\n\n/** Create a TS Record<X, Y> type */\nexport function tsRecord(key: ts.TypeNode, value: ts.TypeNode) {\n  return ts.factory.createTypeReferenceNode(ts.factory.createIdentifier(\"Record\"), [key, value]);\n}\n\n/** Create a valid property index */\nexport function tsPropertyIndex(index: string | number) {\n  if (\n    (typeof index === \"number\" && !(index < 0)) ||\n    (typeof index === \"string\" && String(Number(index)) === index && index[0] !== \"-\")\n  ) {\n    return ts.factory.createNumericLiteral(index);\n  }\n  return typeof index === \"string\" && JS_PROPERTY_INDEX_RE.test(index)\n    ? ts.factory.createIdentifier(index)\n    : ts.factory.createStringLiteral(String(index));\n}\n\n/** Create a union type */\nexport function tsUnion(types: ts.TypeNode[]): ts.TypeNode {\n  if (types.length === 0) {\n    return NEVER;\n  }\n  if (types.length === 1) {\n    return types[0];\n  }\n  return ts.factory.createUnionTypeNode(tsDedupe(types));\n}\n\n/** Create a WithRequired<X, Y> type */\nexport function tsWithRequired(\n  type: ts.TypeNode,\n  keys: string[],\n  injectFooter: ts.Node[], // needed to inject type helper if used\n): ts.TypeNode {\n  if (keys.length === 0) {\n    return type;\n  }\n\n  // inject helper, if needed\n  if (!injectFooter.some((node) => ts.isTypeAliasDeclaration(node) && node?.name?.escapedText === \"WithRequired\")) {\n    const helper = stringToAST(\"type WithRequired<T, K extends keyof T> = T & { [P in K]-?: T[P] };\")[0] as any;\n    injectFooter.push(helper);\n  }\n\n  return ts.factory.createTypeReferenceNode(ts.factory.createIdentifier(\"WithRequired\"), [\n    type,\n    tsUnion(keys.map((k) => tsLiteral(k))),\n  ]);\n}\n\n/**\n * Enhanced ReadonlyArray.\n * eg: type Foo = ReadonlyArray<T>; type Bar = ReadonlyArray<T[]>\n * Foo and Bar are both of type `readonly T[]`\n */\nexport function tsReadonlyArray(type: ts.TypeNode, injectFooter?: ts.Node[]): ts.TypeNode {\n  if (\n    injectFooter &&\n    !injectFooter.some((node) => ts.isTypeAliasDeclaration(node) && node?.name?.escapedText === \"ReadonlyArray\")\n  ) {\n    const helper = stringToAST(\n      \"type ReadonlyArray<T> = [Exclude<T, undefined>] extends [unknown[]] ? Readonly<Exclude<T, undefined>> : Readonly<Exclude<T, undefined>[]>;\",\n    )[0] as any;\n    injectFooter.push(helper);\n  }\n  return ts.factory.createTypeReferenceNode(ts.factory.createIdentifier(\"ReadonlyArray\"), [type]);\n}\n"],"names":["ts","parseRef"],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"ts.cjs","sources":["../../src/lib/ts.ts"],"sourcesContent":["import type { OasRef, Referenced } from \"@redocly/openapi-core\";\nimport { parseRef } from \"@redocly/openapi-core/lib/ref-utils.js\";\nimport ts, { type LiteralTypeNode, type TypeLiteralNode } from \"typescript\";\nimport type { ParameterObject } from \"../types.js\";\n\nexport const JS_PROPERTY_INDEX_RE = /^[A-Za-z_$][A-Za-z_$0-9]*$/;\nexport const JS_ENUM_INVALID_CHARS_RE = /[^A-Za-z_$0-9]+(.)?/g;\nexport const JS_PROPERTY_INDEX_INVALID_CHARS_RE = /[^A-Za-z_$0-9]+/g;\nexport const SPECIAL_CHARACTER_MAP: Record<string, string> = {\n  \"+\": \"Plus\",\n  // Add more mappings as needed\n};\n\nexport const BOOLEAN = ts.factory.createKeywordTypeNode(ts.SyntaxKind.BooleanKeyword);\nexport const FALSE = ts.factory.createLiteralTypeNode(ts.factory.createFalse());\nexport const NEVER = ts.factory.createKeywordTypeNode(ts.SyntaxKind.NeverKeyword);\nexport const NULL = ts.factory.createLiteralTypeNode(ts.factory.createNull());\nexport const NUMBER = ts.factory.createKeywordTypeNode(ts.SyntaxKind.NumberKeyword);\nexport const QUESTION_TOKEN = ts.factory.createToken(ts.SyntaxKind.QuestionToken);\nexport const STRING = ts.factory.createKeywordTypeNode(ts.SyntaxKind.StringKeyword);\nexport const TRUE = ts.factory.createLiteralTypeNode(ts.factory.createTrue());\nexport const UNDEFINED = ts.factory.createKeywordTypeNode(ts.SyntaxKind.UndefinedKeyword);\nexport const UNKNOWN = ts.factory.createKeywordTypeNode(ts.SyntaxKind.UnknownKeyword);\n\nconst LB_RE = /\\r?\\n/g;\nconst COMMENT_RE = /\\*\\//g;\n\nexport interface AnnotatedSchemaObject {\n  const?: unknown; // jsdoc without value\n  default?: unknown; // jsdoc with value\n  deprecated?: boolean; // jsdoc without value\n  description?: string; // jsdoc with value\n  enum?: unknown[]; // jsdoc without value\n  example?: string; // jsdoc with value\n  examples?: unknown;\n  format?: string; // not jsdoc\n  nullable?: boolean; // Node information\n  summary?: string; // not jsdoc\n  title?: string; // not jsdoc\n  type?: string | string[]; // Type of node\n}\n\n/**\n * Preparing comments from fields\n * @see {comment} for output examples\n * @returns void if not comments or jsdoc format comment string\n */\nexport function addJSDocComment(schemaObject: AnnotatedSchemaObject, node: ts.PropertySignature): void {\n  if (!schemaObject || typeof schemaObject !== \"object\" || Array.isArray(schemaObject)) {\n    return;\n  }\n  const output: string[] = [];\n\n  // Not JSDoc tags: [title, format]\n  if (schemaObject.title) {\n    output.push(schemaObject.title.trim().replace(LB_RE, \"\\n *     \"));\n  }\n  if (schemaObject.summary) {\n    output.push(schemaObject.summary.trim().replace(LB_RE, \"\\n *     \"));\n  }\n  if (schemaObject.format) {\n    output.push(`Format: ${schemaObject.format}`);\n  }\n\n  // JSDoc tags without value\n  // 'Deprecated' without value\n  if (schemaObject.deprecated) {\n    output.push(\"@deprecated\");\n  }\n\n  // JSDoc tags with value\n  const supportedJsDocTags = [\"description\", \"default\", \"example\"] as const;\n  for (const field of supportedJsDocTags) {\n    const allowEmptyString = field === \"default\" || field === \"example\";\n    if (schemaObject[field] === undefined) {\n      continue;\n    }\n    if (schemaObject[field] === \"\" && !allowEmptyString) {\n      continue;\n    }\n    const serialized =\n      typeof schemaObject[field] === \"object\" ? JSON.stringify(schemaObject[field], null, 2) : schemaObject[field];\n    output.push(`@${field} ${String(serialized).trim().replace(LB_RE, \"\\n *     \")}`);\n  }\n\n  if (Array.isArray(schemaObject.examples)) {\n    for (const example of schemaObject.examples) {\n      const serialized = typeof example === \"object\" ? JSON.stringify(example, null, 2) : example;\n      output.push(`@example ${String(serialized).trim().replace(LB_RE, \"\\n *     \")}`);\n    }\n  }\n\n  // JSDoc 'Constant' without value\n  if (\"const\" in schemaObject) {\n    output.push(\"@constant\");\n  }\n\n  // JSDoc 'Enum' with type\n  if (schemaObject.enum) {\n    let type = \"unknown\";\n    if (Array.isArray(schemaObject.type)) {\n      type = schemaObject.type.join(\"|\");\n    } else if (typeof schemaObject.type === \"string\") {\n      type = schemaObject.type;\n    }\n    output.push(`@enum {${type}${schemaObject.nullable ? \"|null\" : \"\"}}`);\n  }\n\n  // attach comment if it has content\n\n  if (output.length) {\n    // Check if any output item contains multi-line content (has internal line breaks)\n    const hasMultiLineContent = output.some((item) => item.includes(\"\\n\"));\n\n    let text =\n      output.length === 1 && !hasMultiLineContent ? `* ${output.join(\"\\n\")} ` : `*\\n * ${output.join(\"\\n * \")}\\n `;\n    text = text.replace(COMMENT_RE, \"*\\\\/\"); // prevent inner comments from leaking\n\n    ts.addSyntheticLeadingComment(\n      /* node               */ node,\n      /* kind               */ ts.SyntaxKind.MultiLineCommentTrivia, // note: MultiLine just refers to a \"/* */\" comment\n      /* text               */ text,\n      /* hasTrailingNewLine */ true,\n    );\n  }\n}\n\nfunction isOasRef<T>(obj: Referenced<T>): obj is OasRef {\n  return Boolean((obj as OasRef).$ref);\n}\ntype OapiRefResolved = Referenced<ParameterObject>;\n\nfunction isParameterObject(obj: OapiRefResolved | undefined): obj is ParameterObject {\n  return Boolean(obj && !isOasRef(obj) && obj.in);\n}\n\nfunction addIndexedAccess(node: ts.TypeReferenceNode | ts.IndexedAccessTypeNode, ...segments: readonly string[]) {\n  return segments.reduce((acc, segment) => {\n    return ts.factory.createIndexedAccessTypeNode(\n      acc,\n      ts.factory.createLiteralTypeNode(\n        typeof segment === \"number\"\n          ? ts.factory.createNumericLiteral(segment)\n          : ts.factory.createStringLiteral(segment),\n      ),\n    );\n  }, node);\n}\n\n/**\n * Convert OpenAPI ref into TS indexed access node (ex: `components[\"schemas\"][\"Foo\"]`)\n * `path` is a JSON Pointer to a location within an OpenAPI document.\n * Transform it into a TypeScript type reference into the generated types.\n *\n * In most cases the structures of the openapi-typescript generated types and the\n * JSON Pointer paths into the OpenAPI document are the same. However, in some cases\n * special transformations are necessary to account for the ways they differ.\n *   * Object schemas\n *       $refs into the `properties` of object schemas are valid, but openapi-typescript\n *       flattens these objects, so we omit  so the index into the schema skips [\"properties\"]\n *   * Parameters\n *       $refs into the `parameters` of paths are valid, but openapi-ts represents\n *       them according to their type; path, query, header, etc… so in these cases we\n *       must check the parameter definition to determine the how to index into\n *       the openapi-typescript type.\n **/\nexport function oapiRef(path: string, resolved?: OapiRefResolved, deep = false): ts.TypeNode {\n  const { pointer } = parseRef(path);\n  if (pointer.length === 0) {\n    throw new Error(`Error parsing $ref: ${path}. Is this a valid $ref?`);\n  }\n\n  const parametersObject = isParameterObject(resolved);\n\n  // Initial segments are handled in a fixed , then remaining segments are treated\n  // according to heuristics based on the initial segments\n  const initialSegment = pointer[0];\n  const leadingSegments = pointer.slice(1, 3);\n  const restSegments = pointer.slice(3);\n\n  const leadingType = addIndexedAccess(\n    ts.factory.createTypeReferenceNode(\n      ts.factory.createIdentifier(deep ? `FlattenedDeepRequired<${String(initialSegment)}>` : String(initialSegment)),\n    ),\n    ...leadingSegments,\n  );\n\n  return restSegments.reduce<ts.TypeReferenceNode | ts.IndexedAccessTypeNode>((acc, segment, index, original) => {\n    // Skip `properties` items when in the middle of the pointer\n    // See: https://github.com/openapi-ts/openapi-typescript/issues/1742\n    if (segment === \"properties\") {\n      return acc;\n    }\n\n    if (parametersObject && index === original.length - 1) {\n      return addIndexedAccess(acc, resolved.in, resolved.name);\n    }\n\n    return addIndexedAccess(acc, segment);\n  }, leadingType);\n}\n\nexport interface AstToStringOptions {\n  fileName?: string;\n  sourceText?: string;\n  formatOptions?: ts.PrinterOptions;\n}\n\n/** Convert TypeScript AST to string */\nexport function astToString(\n  ast: ts.Node | ts.Node[] | ts.TypeElement | ts.TypeElement[],\n  options?: AstToStringOptions,\n): string {\n  const sourceFile = ts.createSourceFile(\n    options?.fileName ?? \"openapi-ts.ts\",\n    options?.sourceText ?? \"\",\n    ts.ScriptTarget.ESNext,\n    false,\n    ts.ScriptKind.TS,\n  );\n\n  // @ts-expect-error it’s OK to overwrite statements once\n  sourceFile.statements = ts.factory.createNodeArray(Array.isArray(ast) ? ast : [ast]);\n\n  const printer = ts.createPrinter({\n    newLine: ts.NewLineKind.LineFeed,\n    removeComments: false,\n    ...options?.formatOptions,\n  });\n  return printer.printFile(sourceFile);\n}\n\n/** Convert an arbitrary string to TS (assuming it’s valid) */\nexport function stringToAST(source: string): unknown[] {\n  return ts.createSourceFile(\n    /* fileName        */ \"stringInput\",\n    /* sourceText      */ source,\n    /* languageVersion */ ts.ScriptTarget.ESNext,\n    /* setParentNodes  */ undefined,\n    /* scriptKind      */ undefined,\n  ).statements as any;\n}\n\n/**\n * Deduplicate simple primitive types from an array of nodes\n * Note: won’t deduplicate complex types like objects\n */\nexport function tsDedupe(types: ts.TypeNode[]): ts.TypeNode[] {\n  const encounteredTypes = new Set<number>();\n  const filteredTypes: ts.TypeNode[] = [];\n  for (const t of types) {\n    // only mark for deduplication if this is not a const (\"text\" means it is a const)\n    if (!(\"text\" in ((t as LiteralTypeNode).literal ?? t))) {\n      const { kind } = (t as LiteralTypeNode).literal ?? t;\n      if (encounteredTypes.has(kind)) {\n        continue;\n      }\n      if (tsIsPrimitive(t)) {\n        encounteredTypes.add(kind);\n      }\n    }\n    filteredTypes.push(t);\n  }\n  return filteredTypes;\n}\n\nexport const enumCache = new Map<string, ts.EnumDeclaration>();\n\n/** Create a TS enum (with sanitized name and members) */\nexport function tsEnum(\n  name: string,\n  members: (string | number)[],\n  metadata?: { name?: string; description?: string | null }[],\n  options?: { export?: boolean; shouldCache?: boolean },\n) {\n  let enumName = sanitizeMemberName(name);\n  enumName = `${enumName[0].toUpperCase()}${enumName.substring(1)}`;\n  let key = \"\";\n  if (options?.shouldCache) {\n    key = `${members\n      .slice(0)\n      .sort()\n      .map((v, i) => {\n        return `${metadata?.[i]?.name ?? String(v)}:${metadata?.[i]?.description || \"\"}`;\n      })\n      .join(\",\")}`;\n    if (enumCache.has(key)) {\n      return enumCache.get(key) as ts.EnumDeclaration;\n    }\n  }\n  const enumDeclaration = ts.factory.createEnumDeclaration(\n    /* modifiers */ options ? tsModifiers({ export: options.export ?? false }) : undefined,\n    /* name      */ enumName,\n    /* members   */ members.map((value, i) => tsEnumMember(value, metadata?.[i])),\n  );\n  options?.shouldCache && enumCache.set(key, enumDeclaration);\n  return enumDeclaration;\n}\n\n/** Create an exported TS array literal expression  */\nexport function tsArrayLiteralExpression(\n  name: string,\n  elementType: ts.TypeNode,\n  values: (string | number)[],\n  options?: { export?: boolean; readonly?: boolean; injectFooter?: ts.Node[] },\n) {\n  let variableName = sanitizeMemberName(name);\n  variableName = `${variableName[0].toLowerCase()}${variableName.substring(1)}`;\n\n  if (\n    options?.injectFooter &&\n    !options.injectFooter.some(\n      (node) => ts.isTypeAliasDeclaration(node) && node?.name?.escapedText === \"FlattenedDeepRequired\",\n    )\n  ) {\n    const helper = stringToAST(\n      \"type FlattenedDeepRequired<T> = { [K in keyof T]-?: FlattenedDeepRequired<T[K] extends unknown[] | undefined | null ? Extract<T[K], unknown[]>[number] : T[K]>; };\",\n    )[0] as any;\n    options.injectFooter.push(helper);\n  }\n\n  const arrayType = options?.readonly\n    ? tsReadonlyArray(elementType, options.injectFooter)\n    : ts.factory.createArrayTypeNode(elementType);\n\n  return ts.factory.createVariableStatement(\n    options ? tsModifiers({ export: options.export ?? false }) : undefined,\n    ts.factory.createVariableDeclarationList(\n      [\n        ts.factory.createVariableDeclaration(\n          variableName,\n          undefined,\n          arrayType,\n          ts.factory.createArrayLiteralExpression(\n            values.map((value) => {\n              if (typeof value === \"number\") {\n                if (value < 0) {\n                  return ts.factory.createPrefixUnaryExpression(\n                    ts.SyntaxKind.MinusToken,\n                    ts.factory.createNumericLiteral(Math.abs(value)),\n                  );\n                } else {\n                  return ts.factory.createNumericLiteral(value);\n                }\n              } else {\n                return ts.factory.createStringLiteral(value);\n              }\n            }),\n          ),\n        ),\n      ],\n      ts.NodeFlags.Const,\n    ),\n  );\n}\n\nfunction sanitizeMemberName(name: string) {\n  let sanitizedName = name.replace(JS_ENUM_INVALID_CHARS_RE, (c) => {\n    const last = c[c.length - 1];\n    return JS_PROPERTY_INDEX_INVALID_CHARS_RE.test(last) ? \"\" : last.toUpperCase();\n  });\n  if (Number(name[0]) >= 0) {\n    sanitizedName = `Value${name}`;\n  }\n  return sanitizedName;\n}\n\n/** Sanitize TS enum member expression */\nexport function tsEnumMember(value: string | number, metadata: { name?: string; description?: string | null } = {}) {\n  let name = metadata.name ?? String(value);\n  if (!JS_PROPERTY_INDEX_RE.test(name)) {\n    if (Number(name[0]) >= 0) {\n      name = `Value${name}`.replace(\".\", \"_\"); // don't forged decimals;\n    } else if (name[0] === \"-\") {\n      name = `ValueMinus${name.slice(1)}`;\n    }\n\n    const invalidCharMatch = name.match(JS_PROPERTY_INDEX_INVALID_CHARS_RE);\n    if (invalidCharMatch) {\n      if (invalidCharMatch[0] === name) {\n        name = `\"${name}\"`;\n      } else {\n        name = name.replace(JS_PROPERTY_INDEX_INVALID_CHARS_RE, (s) => {\n          return s in SPECIAL_CHARACTER_MAP ? SPECIAL_CHARACTER_MAP[s] : \"_\";\n        });\n      }\n    }\n  }\n\n  let member: ts.EnumMember;\n  if (typeof value === \"number\") {\n    const literal =\n      value < 0\n        ? ts.factory.createPrefixUnaryExpression(\n            ts.SyntaxKind.MinusToken,\n            ts.factory.createNumericLiteral(Math.abs(value)),\n          )\n        : ts.factory.createNumericLiteral(value);\n\n    member = ts.factory.createEnumMember(name, literal);\n  } else {\n    member = ts.factory.createEnumMember(name, ts.factory.createStringLiteral(value));\n  }\n\n  const trimmedDescription = metadata.description?.trim();\n  if (trimmedDescription === undefined || trimmedDescription === null || trimmedDescription === \"\") {\n    return member;\n  }\n\n  return ts.addSyntheticLeadingComment(member, ts.SyntaxKind.SingleLineCommentTrivia, ` ${trimmedDescription}`, true);\n}\n\n/** Create an intersection type */\nexport function tsIntersection(types: ts.TypeNode[]): ts.TypeNode {\n  if (types.length === 0) {\n    return NEVER;\n  }\n  if (types.length === 1) {\n    return types[0];\n  }\n  return ts.factory.createIntersectionTypeNode(tsDedupe(types));\n}\n\n/** Is this a primitive type (string, number, boolean, null, undefined)? */\nexport function tsIsPrimitive(type: ts.TypeNode): boolean {\n  if (!type) {\n    return true;\n  }\n  return (\n    ts.SyntaxKind[type.kind] === \"BooleanKeyword\" ||\n    ts.SyntaxKind[type.kind] === \"NeverKeyword\" ||\n    ts.SyntaxKind[type.kind] === \"NullKeyword\" ||\n    ts.SyntaxKind[type.kind] === \"NumberKeyword\" ||\n    ts.SyntaxKind[type.kind] === \"StringKeyword\" ||\n    ts.SyntaxKind[type.kind] === \"UndefinedKeyword\" ||\n    (\"literal\" in type && tsIsPrimitive(type.literal as TypeLiteralNode))\n  );\n}\n\n/** Create a literal type */\nexport function tsLiteral(value: unknown): ts.TypeNode {\n  if (typeof value === \"string\") {\n    // workaround for UTF-8: https://github.com/microsoft/TypeScript/issues/36174\n    return ts.factory.createIdentifier(JSON.stringify(value)) as unknown as ts.TypeNode;\n  }\n  if (typeof value === \"number\") {\n    const literal =\n      value < 0\n        ? ts.factory.createPrefixUnaryExpression(\n            ts.SyntaxKind.MinusToken,\n            ts.factory.createNumericLiteral(Math.abs(value)),\n          )\n        : ts.factory.createNumericLiteral(value);\n    return ts.factory.createLiteralTypeNode(literal);\n  }\n  if (typeof value === \"boolean\") {\n    return value === true ? TRUE : FALSE;\n  }\n  if (value === null) {\n    return NULL;\n  }\n  if (Array.isArray(value)) {\n    if (value.length === 0) {\n      return ts.factory.createArrayTypeNode(NEVER);\n    }\n    return ts.factory.createTupleTypeNode(value.map((v: unknown) => tsLiteral(v)));\n  }\n  if (typeof value === \"object\") {\n    const keys: ts.TypeElement[] = [];\n    for (const [k, v] of Object.entries(value)) {\n      keys.push(\n        ts.factory.createPropertySignature(\n          /* modifiers     */ undefined,\n          /* name          */ tsPropertyIndex(k),\n          /* questionToken */ undefined,\n          /* type          */ tsLiteral(v),\n        ),\n      );\n    }\n    return keys.length ? ts.factory.createTypeLiteralNode(keys) : tsRecord(STRING, NEVER);\n  }\n  return UNKNOWN;\n}\n\n/** Modifiers (readonly) */\nexport function tsModifiers(modifiers: { readonly?: boolean; export?: boolean }): ts.Modifier[] {\n  const typeMods: ts.Modifier[] = [];\n  if (modifiers.export) {\n    typeMods.push(ts.factory.createModifier(ts.SyntaxKind.ExportKeyword));\n  }\n  if (modifiers.readonly) {\n    typeMods.push(ts.factory.createModifier(ts.SyntaxKind.ReadonlyKeyword));\n  }\n  return typeMods;\n}\n\n/** Create a T | null union */\nexport function tsNullable(types: ts.TypeNode[]): ts.TypeNode {\n  return ts.factory.createUnionTypeNode([...types, NULL]);\n}\n\n/** Create a TS Omit<X, Y> type */\nexport function tsOmit(type: ts.TypeNode, keys: string[]): ts.TypeNode {\n  return ts.factory.createTypeReferenceNode(ts.factory.createIdentifier(\"Omit\"), [\n    type,\n    ts.factory.createUnionTypeNode(keys.map((k) => tsLiteral(k))),\n  ]);\n}\n\n/** Create a TS Record<X, Y> type */\nexport function tsRecord(key: ts.TypeNode, value: ts.TypeNode) {\n  return ts.factory.createTypeReferenceNode(ts.factory.createIdentifier(\"Record\"), [key, value]);\n}\n\n/** Create a valid property index */\nexport function tsPropertyIndex(index: string | number) {\n  if (\n    (typeof index === \"number\" && !(index < 0)) ||\n    (typeof index === \"string\" && String(Number(index)) === index && index[0] !== \"-\")\n  ) {\n    return ts.factory.createNumericLiteral(index);\n  }\n  return typeof index === \"string\" && JS_PROPERTY_INDEX_RE.test(index)\n    ? ts.factory.createIdentifier(index)\n    : ts.factory.createStringLiteral(String(index));\n}\n\n/** Create a union type */\nexport function tsUnion(types: ts.TypeNode[]): ts.TypeNode {\n  if (types.length === 0) {\n    return NEVER;\n  }\n  if (types.length === 1) {\n    return types[0];\n  }\n  return ts.factory.createUnionTypeNode(tsDedupe(types));\n}\n\n/** Create a WithRequired<X, Y> type */\nexport function tsWithRequired(\n  type: ts.TypeNode,\n  keys: string[],\n  injectFooter: ts.Node[], // needed to inject type helper if used\n): ts.TypeNode {\n  if (keys.length === 0) {\n    return type;\n  }\n\n  // inject helper, if needed\n  if (!injectFooter.some((node) => ts.isTypeAliasDeclaration(node) && node?.name?.escapedText === \"WithRequired\")) {\n    const helper = stringToAST(\"type WithRequired<T, K extends keyof T> = T & { [P in K]-?: T[P] };\")[0] as any;\n    injectFooter.push(helper);\n  }\n\n  return ts.factory.createTypeReferenceNode(ts.factory.createIdentifier(\"WithRequired\"), [\n    type,\n    tsUnion(keys.map((k) => tsLiteral(k))),\n  ]);\n}\n\n/**\n * Enhanced ReadonlyArray.\n * eg: type Foo = ReadonlyArray<T>; type Bar = ReadonlyArray<T[]>\n * Foo and Bar are both of type `readonly T[]`\n */\nexport function tsReadonlyArray(type: ts.TypeNode, injectFooter?: ts.Node[]): ts.TypeNode {\n  if (\n    injectFooter &&\n    !injectFooter.some((node) => ts.isTypeAliasDeclaration(node) && node?.name?.escapedText === \"ReadonlyArray\")\n  ) {\n    const helper = stringToAST(\n      \"type ReadonlyArray<T> = [Exclude<T, undefined>] extends [unknown[]] ? Readonly<Exclude<T, undefined>> : Readonly<Exclude<T, undefined>[]>;\",\n    )[0] as any;\n    injectFooter.push(helper);\n  }\n  return ts.factory.createTypeReferenceNode(ts.factory.createIdentifier(\"ReadonlyArray\"), [type]);\n}\n"],"names":["ts","parseRef"],"mappings":"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"}
\ No newline at end of file
diff --git a/dist/lib/ts.mjs b/dist/lib/ts.mjs
index 6cd1ce99a98b4be4b333167afcfc03bed4f78786..93724bc4e4b66d1ea8a3e6de8e7a8f1ff444d187 100644
--- a/dist/lib/ts.mjs
+++ b/dist/lib/ts.mjs
@@ -102,7 +102,7 @@ function addIndexedAccess(node, ...segments) {
     );
   }, node);
 }
-function oapiRef(path, resolved) {
+function oapiRef(path, resolved, deep = false) {
   const { pointer } = parseRef(path);
   if (pointer.length === 0) {
     throw new Error(`Error parsing $ref: ${path}. Is this a valid $ref?`);
@@ -112,7 +112,9 @@ function oapiRef(path, resolved) {
   const leadingSegments = pointer.slice(1, 3);
   const restSegments = pointer.slice(3);
   const leadingType = addIndexedAccess(
-    ts.factory.createTypeReferenceNode(ts.factory.createIdentifier(String(initialSegment))),
+    ts.factory.createTypeReferenceNode(
+      ts.factory.createIdentifier(deep ? `FlattenedDeepRequired<${String(initialSegment)}>` : String(initialSegment))
+    ),
     ...leadingSegments
   );
   return restSegments.reduce((acc, segment, index, original) => {
@@ -199,6 +201,14 @@ function tsEnum(name, members, metadata, options) {
 function tsArrayLiteralExpression(name, elementType, values, options) {
   let variableName = sanitizeMemberName(name);
   variableName = `${variableName[0].toLowerCase()}${variableName.substring(1)}`;
+  if (options?.injectFooter && !options.injectFooter.some(
+    (node) => ts.isTypeAliasDeclaration(node) && node?.name?.escapedText === "FlattenedDeepRequired"
+  )) {
+    const helper = stringToAST(
+      "type FlattenedDeepRequired<T> = { [K in keyof T]-?: FlattenedDeepRequired<T[K] extends unknown[] | undefined | null ? Extract<T[K], unknown[]>[number] : T[K]>; };"
+    )[0];
+    options.injectFooter.push(helper);
+  }
   const arrayType = options?.readonly ? tsReadonlyArray(elementType, options.injectFooter) : ts.factory.createArrayTypeNode(elementType);
   return ts.factory.createVariableStatement(
     options ? tsModifiers({ export: options.export ?? false }) : void 0,
diff --git a/dist/lib/ts.mjs.map b/dist/lib/ts.mjs.map
index 543cd035324e2aaa37793666b31caca98fd91139..8dc3cb7b6c870b593362e335c1ae6ca386b98f0b 100644
--- a/dist/lib/ts.mjs.map
+++ b/dist/lib/ts.mjs.map
@@ -1 +1 @@
-{"version":3,"file":"ts.mjs","sources":["../../src/lib/ts.ts"],"sourcesContent":["import type { OasRef, Referenced } from \"@redocly/openapi-core\";\nimport { parseRef } from \"@redocly/openapi-core/lib/ref-utils.js\";\nimport ts, { type LiteralTypeNode, type TypeLiteralNode } from \"typescript\";\nimport type { ParameterObject } from \"../types.js\";\n\nexport const JS_PROPERTY_INDEX_RE = /^[A-Za-z_$][A-Za-z_$0-9]*$/;\nexport const JS_ENUM_INVALID_CHARS_RE = /[^A-Za-z_$0-9]+(.)?/g;\nexport const JS_PROPERTY_INDEX_INVALID_CHARS_RE = /[^A-Za-z_$0-9]+/g;\nexport const SPECIAL_CHARACTER_MAP: Record<string, string> = {\n  \"+\": \"Plus\",\n  // Add more mappings as needed\n};\n\nexport const BOOLEAN = ts.factory.createKeywordTypeNode(ts.SyntaxKind.BooleanKeyword);\nexport const FALSE = ts.factory.createLiteralTypeNode(ts.factory.createFalse());\nexport const NEVER = ts.factory.createKeywordTypeNode(ts.SyntaxKind.NeverKeyword);\nexport const NULL = ts.factory.createLiteralTypeNode(ts.factory.createNull());\nexport const NUMBER = ts.factory.createKeywordTypeNode(ts.SyntaxKind.NumberKeyword);\nexport const QUESTION_TOKEN = ts.factory.createToken(ts.SyntaxKind.QuestionToken);\nexport const STRING = ts.factory.createKeywordTypeNode(ts.SyntaxKind.StringKeyword);\nexport const TRUE = ts.factory.createLiteralTypeNode(ts.factory.createTrue());\nexport const UNDEFINED = ts.factory.createKeywordTypeNode(ts.SyntaxKind.UndefinedKeyword);\nexport const UNKNOWN = ts.factory.createKeywordTypeNode(ts.SyntaxKind.UnknownKeyword);\n\nconst LB_RE = /\\r?\\n/g;\nconst COMMENT_RE = /\\*\\//g;\n\nexport interface AnnotatedSchemaObject {\n  const?: unknown; // jsdoc without value\n  default?: unknown; // jsdoc with value\n  deprecated?: boolean; // jsdoc without value\n  description?: string; // jsdoc with value\n  enum?: unknown[]; // jsdoc without value\n  example?: string; // jsdoc with value\n  examples?: unknown;\n  format?: string; // not jsdoc\n  nullable?: boolean; // Node information\n  summary?: string; // not jsdoc\n  title?: string; // not jsdoc\n  type?: string | string[]; // Type of node\n}\n\n/**\n * Preparing comments from fields\n * @see {comment} for output examples\n * @returns void if not comments or jsdoc format comment string\n */\nexport function addJSDocComment(schemaObject: AnnotatedSchemaObject, node: ts.PropertySignature): void {\n  if (!schemaObject || typeof schemaObject !== \"object\" || Array.isArray(schemaObject)) {\n    return;\n  }\n  const output: string[] = [];\n\n  // Not JSDoc tags: [title, format]\n  if (schemaObject.title) {\n    output.push(schemaObject.title.trim().replace(LB_RE, \"\\n *     \"));\n  }\n  if (schemaObject.summary) {\n    output.push(schemaObject.summary.trim().replace(LB_RE, \"\\n *     \"));\n  }\n  if (schemaObject.format) {\n    output.push(`Format: ${schemaObject.format}`);\n  }\n\n  // JSDoc tags without value\n  // 'Deprecated' without value\n  if (schemaObject.deprecated) {\n    output.push(\"@deprecated\");\n  }\n\n  // JSDoc tags with value\n  const supportedJsDocTags = [\"description\", \"default\", \"example\"] as const;\n  for (const field of supportedJsDocTags) {\n    const allowEmptyString = field === \"default\" || field === \"example\";\n    if (schemaObject[field] === undefined) {\n      continue;\n    }\n    if (schemaObject[field] === \"\" && !allowEmptyString) {\n      continue;\n    }\n    const serialized =\n      typeof schemaObject[field] === \"object\" ? JSON.stringify(schemaObject[field], null, 2) : schemaObject[field];\n    output.push(`@${field} ${String(serialized).trim().replace(LB_RE, \"\\n *     \")}`);\n  }\n\n  if (Array.isArray(schemaObject.examples)) {\n    for (const example of schemaObject.examples) {\n      const serialized = typeof example === \"object\" ? JSON.stringify(example, null, 2) : example;\n      output.push(`@example ${String(serialized).trim().replace(LB_RE, \"\\n *     \")}`);\n    }\n  }\n\n  // JSDoc 'Constant' without value\n  if (\"const\" in schemaObject) {\n    output.push(\"@constant\");\n  }\n\n  // JSDoc 'Enum' with type\n  if (schemaObject.enum) {\n    let type = \"unknown\";\n    if (Array.isArray(schemaObject.type)) {\n      type = schemaObject.type.join(\"|\");\n    } else if (typeof schemaObject.type === \"string\") {\n      type = schemaObject.type;\n    }\n    output.push(`@enum {${type}${schemaObject.nullable ? \"|null\" : \"\"}}`);\n  }\n\n  // attach comment if it has content\n\n  if (output.length) {\n    // Check if any output item contains multi-line content (has internal line breaks)\n    const hasMultiLineContent = output.some((item) => item.includes(\"\\n\"));\n\n    let text =\n      output.length === 1 && !hasMultiLineContent ? `* ${output.join(\"\\n\")} ` : `*\\n * ${output.join(\"\\n * \")}\\n `;\n    text = text.replace(COMMENT_RE, \"*\\\\/\"); // prevent inner comments from leaking\n\n    ts.addSyntheticLeadingComment(\n      /* node               */ node,\n      /* kind               */ ts.SyntaxKind.MultiLineCommentTrivia, // note: MultiLine just refers to a \"/* */\" comment\n      /* text               */ text,\n      /* hasTrailingNewLine */ true,\n    );\n  }\n}\n\nfunction isOasRef<T>(obj: Referenced<T>): obj is OasRef {\n  return Boolean((obj as OasRef).$ref);\n}\ntype OapiRefResolved = Referenced<ParameterObject>;\n\nfunction isParameterObject(obj: OapiRefResolved | undefined): obj is ParameterObject {\n  return Boolean(obj && !isOasRef(obj) && obj.in);\n}\n\nfunction addIndexedAccess(node: ts.TypeReferenceNode | ts.IndexedAccessTypeNode, ...segments: readonly string[]) {\n  return segments.reduce((acc, segment) => {\n    return ts.factory.createIndexedAccessTypeNode(\n      acc,\n      ts.factory.createLiteralTypeNode(\n        typeof segment === \"number\"\n          ? ts.factory.createNumericLiteral(segment)\n          : ts.factory.createStringLiteral(segment),\n      ),\n    );\n  }, node);\n}\n\n/**\n * Convert OpenAPI ref into TS indexed access node (ex: `components[\"schemas\"][\"Foo\"]`)\n * `path` is a JSON Pointer to a location within an OpenAPI document.\n * Transform it into a TypeScript type reference into the generated types.\n *\n * In most cases the structures of the openapi-typescript generated types and the\n * JSON Pointer paths into the OpenAPI document are the same. However, in some cases\n * special transformations are necessary to account for the ways they differ.\n *   * Object schemas\n *       $refs into the `properties` of object schemas are valid, but openapi-typescript\n *       flattens these objects, so we omit  so the index into the schema skips [\"properties\"]\n *   * Parameters\n *       $refs into the `parameters` of paths are valid, but openapi-ts represents\n *       them according to their type; path, query, header, etc… so in these cases we\n *       must check the parameter definition to determine the how to index into\n *       the openapi-typescript type.\n **/\nexport function oapiRef(path: string, resolved?: OapiRefResolved): ts.TypeNode {\n  const { pointer } = parseRef(path);\n  if (pointer.length === 0) {\n    throw new Error(`Error parsing $ref: ${path}. Is this a valid $ref?`);\n  }\n\n  const parametersObject = isParameterObject(resolved);\n\n  // Initial segments are handled in a fixed , then remaining segments are treated\n  // according to heuristics based on the initial segments\n  const initialSegment = pointer[0];\n  const leadingSegments = pointer.slice(1, 3);\n  const restSegments = pointer.slice(3);\n\n  const leadingType = addIndexedAccess(\n    ts.factory.createTypeReferenceNode(ts.factory.createIdentifier(String(initialSegment))),\n    ...leadingSegments,\n  );\n\n  return restSegments.reduce<ts.TypeReferenceNode | ts.IndexedAccessTypeNode>((acc, segment, index, original) => {\n    // Skip `properties` items when in the middle of the pointer\n    // See: https://github.com/openapi-ts/openapi-typescript/issues/1742\n    if (segment === \"properties\") {\n      return acc;\n    }\n\n    if (parametersObject && index === original.length - 1) {\n      return addIndexedAccess(acc, resolved.in, resolved.name);\n    }\n\n    return addIndexedAccess(acc, segment);\n  }, leadingType);\n}\n\nexport interface AstToStringOptions {\n  fileName?: string;\n  sourceText?: string;\n  formatOptions?: ts.PrinterOptions;\n}\n\n/** Convert TypeScript AST to string */\nexport function astToString(\n  ast: ts.Node | ts.Node[] | ts.TypeElement | ts.TypeElement[],\n  options?: AstToStringOptions,\n): string {\n  const sourceFile = ts.createSourceFile(\n    options?.fileName ?? \"openapi-ts.ts\",\n    options?.sourceText ?? \"\",\n    ts.ScriptTarget.ESNext,\n    false,\n    ts.ScriptKind.TS,\n  );\n\n  // @ts-expect-error it’s OK to overwrite statements once\n  sourceFile.statements = ts.factory.createNodeArray(Array.isArray(ast) ? ast : [ast]);\n\n  const printer = ts.createPrinter({\n    newLine: ts.NewLineKind.LineFeed,\n    removeComments: false,\n    ...options?.formatOptions,\n  });\n  return printer.printFile(sourceFile);\n}\n\n/** Convert an arbitrary string to TS (assuming it’s valid) */\nexport function stringToAST(source: string): unknown[] {\n  return ts.createSourceFile(\n    /* fileName        */ \"stringInput\",\n    /* sourceText      */ source,\n    /* languageVersion */ ts.ScriptTarget.ESNext,\n    /* setParentNodes  */ undefined,\n    /* scriptKind      */ undefined,\n  ).statements as any;\n}\n\n/**\n * Deduplicate simple primitive types from an array of nodes\n * Note: won’t deduplicate complex types like objects\n */\nexport function tsDedupe(types: ts.TypeNode[]): ts.TypeNode[] {\n  const encounteredTypes = new Set<number>();\n  const filteredTypes: ts.TypeNode[] = [];\n  for (const t of types) {\n    // only mark for deduplication if this is not a const (\"text\" means it is a const)\n    if (!(\"text\" in ((t as LiteralTypeNode).literal ?? t))) {\n      const { kind } = (t as LiteralTypeNode).literal ?? t;\n      if (encounteredTypes.has(kind)) {\n        continue;\n      }\n      if (tsIsPrimitive(t)) {\n        encounteredTypes.add(kind);\n      }\n    }\n    filteredTypes.push(t);\n  }\n  return filteredTypes;\n}\n\nexport const enumCache = new Map<string, ts.EnumDeclaration>();\n\n/** Create a TS enum (with sanitized name and members) */\nexport function tsEnum(\n  name: string,\n  members: (string | number)[],\n  metadata?: { name?: string; description?: string | null }[],\n  options?: { export?: boolean; shouldCache?: boolean },\n) {\n  let enumName = sanitizeMemberName(name);\n  enumName = `${enumName[0].toUpperCase()}${enumName.substring(1)}`;\n  let key = \"\";\n  if (options?.shouldCache) {\n    key = `${members\n      .slice(0)\n      .sort()\n      .map((v, i) => {\n        return `${metadata?.[i]?.name ?? String(v)}:${metadata?.[i]?.description || \"\"}`;\n      })\n      .join(\",\")}`;\n    if (enumCache.has(key)) {\n      return enumCache.get(key) as ts.EnumDeclaration;\n    }\n  }\n  const enumDeclaration = ts.factory.createEnumDeclaration(\n    /* modifiers */ options ? tsModifiers({ export: options.export ?? false }) : undefined,\n    /* name      */ enumName,\n    /* members   */ members.map((value, i) => tsEnumMember(value, metadata?.[i])),\n  );\n  options?.shouldCache && enumCache.set(key, enumDeclaration);\n  return enumDeclaration;\n}\n\n/** Create an exported TS array literal expression  */\nexport function tsArrayLiteralExpression(\n  name: string,\n  elementType: ts.TypeNode,\n  values: (string | number)[],\n  options?: { export?: boolean; readonly?: boolean; injectFooter?: ts.Node[] },\n) {\n  let variableName = sanitizeMemberName(name);\n  variableName = `${variableName[0].toLowerCase()}${variableName.substring(1)}`;\n\n  const arrayType = options?.readonly\n    ? tsReadonlyArray(elementType, options.injectFooter)\n    : ts.factory.createArrayTypeNode(elementType);\n\n  return ts.factory.createVariableStatement(\n    options ? tsModifiers({ export: options.export ?? false }) : undefined,\n    ts.factory.createVariableDeclarationList(\n      [\n        ts.factory.createVariableDeclaration(\n          variableName,\n          undefined,\n          arrayType,\n          ts.factory.createArrayLiteralExpression(\n            values.map((value) => {\n              if (typeof value === \"number\") {\n                if (value < 0) {\n                  return ts.factory.createPrefixUnaryExpression(\n                    ts.SyntaxKind.MinusToken,\n                    ts.factory.createNumericLiteral(Math.abs(value)),\n                  );\n                } else {\n                  return ts.factory.createNumericLiteral(value);\n                }\n              } else {\n                return ts.factory.createStringLiteral(value);\n              }\n            }),\n          ),\n        ),\n      ],\n      ts.NodeFlags.Const,\n    ),\n  );\n}\n\nfunction sanitizeMemberName(name: string) {\n  let sanitizedName = name.replace(JS_ENUM_INVALID_CHARS_RE, (c) => {\n    const last = c[c.length - 1];\n    return JS_PROPERTY_INDEX_INVALID_CHARS_RE.test(last) ? \"\" : last.toUpperCase();\n  });\n  if (Number(name[0]) >= 0) {\n    sanitizedName = `Value${name}`;\n  }\n  return sanitizedName;\n}\n\n/** Sanitize TS enum member expression */\nexport function tsEnumMember(value: string | number, metadata: { name?: string; description?: string | null } = {}) {\n  let name = metadata.name ?? String(value);\n  if (!JS_PROPERTY_INDEX_RE.test(name)) {\n    if (Number(name[0]) >= 0) {\n      name = `Value${name}`.replace(\".\", \"_\"); // don't forged decimals;\n    } else if (name[0] === \"-\") {\n      name = `ValueMinus${name.slice(1)}`;\n    }\n\n    const invalidCharMatch = name.match(JS_PROPERTY_INDEX_INVALID_CHARS_RE);\n    if (invalidCharMatch) {\n      if (invalidCharMatch[0] === name) {\n        name = `\"${name}\"`;\n      } else {\n        name = name.replace(JS_PROPERTY_INDEX_INVALID_CHARS_RE, (s) => {\n          return s in SPECIAL_CHARACTER_MAP ? SPECIAL_CHARACTER_MAP[s] : \"_\";\n        });\n      }\n    }\n  }\n\n  let member: ts.EnumMember;\n  if (typeof value === \"number\") {\n    const literal =\n      value < 0\n        ? ts.factory.createPrefixUnaryExpression(\n            ts.SyntaxKind.MinusToken,\n            ts.factory.createNumericLiteral(Math.abs(value)),\n          )\n        : ts.factory.createNumericLiteral(value);\n\n    member = ts.factory.createEnumMember(name, literal);\n  } else {\n    member = ts.factory.createEnumMember(name, ts.factory.createStringLiteral(value));\n  }\n\n  const trimmedDescription = metadata.description?.trim();\n  if (trimmedDescription === undefined || trimmedDescription === null || trimmedDescription === \"\") {\n    return member;\n  }\n\n  return ts.addSyntheticLeadingComment(member, ts.SyntaxKind.SingleLineCommentTrivia, ` ${trimmedDescription}`, true);\n}\n\n/** Create an intersection type */\nexport function tsIntersection(types: ts.TypeNode[]): ts.TypeNode {\n  if (types.length === 0) {\n    return NEVER;\n  }\n  if (types.length === 1) {\n    return types[0];\n  }\n  return ts.factory.createIntersectionTypeNode(tsDedupe(types));\n}\n\n/** Is this a primitive type (string, number, boolean, null, undefined)? */\nexport function tsIsPrimitive(type: ts.TypeNode): boolean {\n  if (!type) {\n    return true;\n  }\n  return (\n    ts.SyntaxKind[type.kind] === \"BooleanKeyword\" ||\n    ts.SyntaxKind[type.kind] === \"NeverKeyword\" ||\n    ts.SyntaxKind[type.kind] === \"NullKeyword\" ||\n    ts.SyntaxKind[type.kind] === \"NumberKeyword\" ||\n    ts.SyntaxKind[type.kind] === \"StringKeyword\" ||\n    ts.SyntaxKind[type.kind] === \"UndefinedKeyword\" ||\n    (\"literal\" in type && tsIsPrimitive(type.literal as TypeLiteralNode))\n  );\n}\n\n/** Create a literal type */\nexport function tsLiteral(value: unknown): ts.TypeNode {\n  if (typeof value === \"string\") {\n    // workaround for UTF-8: https://github.com/microsoft/TypeScript/issues/36174\n    return ts.factory.createIdentifier(JSON.stringify(value)) as unknown as ts.TypeNode;\n  }\n  if (typeof value === \"number\") {\n    const literal =\n      value < 0\n        ? ts.factory.createPrefixUnaryExpression(\n            ts.SyntaxKind.MinusToken,\n            ts.factory.createNumericLiteral(Math.abs(value)),\n          )\n        : ts.factory.createNumericLiteral(value);\n    return ts.factory.createLiteralTypeNode(literal);\n  }\n  if (typeof value === \"boolean\") {\n    return value === true ? TRUE : FALSE;\n  }\n  if (value === null) {\n    return NULL;\n  }\n  if (Array.isArray(value)) {\n    if (value.length === 0) {\n      return ts.factory.createArrayTypeNode(NEVER);\n    }\n    return ts.factory.createTupleTypeNode(value.map((v: unknown) => tsLiteral(v)));\n  }\n  if (typeof value === \"object\") {\n    const keys: ts.TypeElement[] = [];\n    for (const [k, v] of Object.entries(value)) {\n      keys.push(\n        ts.factory.createPropertySignature(\n          /* modifiers     */ undefined,\n          /* name          */ tsPropertyIndex(k),\n          /* questionToken */ undefined,\n          /* type          */ tsLiteral(v),\n        ),\n      );\n    }\n    return keys.length ? ts.factory.createTypeLiteralNode(keys) : tsRecord(STRING, NEVER);\n  }\n  return UNKNOWN;\n}\n\n/** Modifiers (readonly) */\nexport function tsModifiers(modifiers: { readonly?: boolean; export?: boolean }): ts.Modifier[] {\n  const typeMods: ts.Modifier[] = [];\n  if (modifiers.export) {\n    typeMods.push(ts.factory.createModifier(ts.SyntaxKind.ExportKeyword));\n  }\n  if (modifiers.readonly) {\n    typeMods.push(ts.factory.createModifier(ts.SyntaxKind.ReadonlyKeyword));\n  }\n  return typeMods;\n}\n\n/** Create a T | null union */\nexport function tsNullable(types: ts.TypeNode[]): ts.TypeNode {\n  return ts.factory.createUnionTypeNode([...types, NULL]);\n}\n\n/** Create a TS Omit<X, Y> type */\nexport function tsOmit(type: ts.TypeNode, keys: string[]): ts.TypeNode {\n  return ts.factory.createTypeReferenceNode(ts.factory.createIdentifier(\"Omit\"), [\n    type,\n    ts.factory.createUnionTypeNode(keys.map((k) => tsLiteral(k))),\n  ]);\n}\n\n/** Create a TS Record<X, Y> type */\nexport function tsRecord(key: ts.TypeNode, value: ts.TypeNode) {\n  return ts.factory.createTypeReferenceNode(ts.factory.createIdentifier(\"Record\"), [key, value]);\n}\n\n/** Create a valid property index */\nexport function tsPropertyIndex(index: string | number) {\n  if (\n    (typeof index === \"number\" && !(index < 0)) ||\n    (typeof index === \"string\" && String(Number(index)) === index && index[0] !== \"-\")\n  ) {\n    return ts.factory.createNumericLiteral(index);\n  }\n  return typeof index === \"string\" && JS_PROPERTY_INDEX_RE.test(index)\n    ? ts.factory.createIdentifier(index)\n    : ts.factory.createStringLiteral(String(index));\n}\n\n/** Create a union type */\nexport function tsUnion(types: ts.TypeNode[]): ts.TypeNode {\n  if (types.length === 0) {\n    return NEVER;\n  }\n  if (types.length === 1) {\n    return types[0];\n  }\n  return ts.factory.createUnionTypeNode(tsDedupe(types));\n}\n\n/** Create a WithRequired<X, Y> type */\nexport function tsWithRequired(\n  type: ts.TypeNode,\n  keys: string[],\n  injectFooter: ts.Node[], // needed to inject type helper if used\n): ts.TypeNode {\n  if (keys.length === 0) {\n    return type;\n  }\n\n  // inject helper, if needed\n  if (!injectFooter.some((node) => ts.isTypeAliasDeclaration(node) && node?.name?.escapedText === \"WithRequired\")) {\n    const helper = stringToAST(\"type WithRequired<T, K extends keyof T> = T & { [P in K]-?: T[P] };\")[0] as any;\n    injectFooter.push(helper);\n  }\n\n  return ts.factory.createTypeReferenceNode(ts.factory.createIdentifier(\"WithRequired\"), [\n    type,\n    tsUnion(keys.map((k) => tsLiteral(k))),\n  ]);\n}\n\n/**\n * Enhanced ReadonlyArray.\n * eg: type Foo = ReadonlyArray<T>; type Bar = ReadonlyArray<T[]>\n * Foo and Bar are both of type `readonly T[]`\n */\nexport function tsReadonlyArray(type: ts.TypeNode, injectFooter?: ts.Node[]): ts.TypeNode {\n  if (\n    injectFooter &&\n    !injectFooter.some((node) => ts.isTypeAliasDeclaration(node) && node?.name?.escapedText === \"ReadonlyArray\")\n  ) {\n    const helper = stringToAST(\n      \"type ReadonlyArray<T> = [Exclude<T, undefined>] extends [unknown[]] ? Readonly<Exclude<T, undefined>> : Readonly<Exclude<T, undefined>[]>;\",\n    )[0] as any;\n    injectFooter.push(helper);\n  }\n  return ts.factory.createTypeReferenceNode(ts.factory.createIdentifier(\"ReadonlyArray\"), [type]);\n}\n"],"names":[],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"ts.mjs","sources":["../../src/lib/ts.ts"],"sourcesContent":["import type { OasRef, Referenced } from \"@redocly/openapi-core\";\nimport { parseRef } from \"@redocly/openapi-core/lib/ref-utils.js\";\nimport ts, { type LiteralTypeNode, type TypeLiteralNode } from \"typescript\";\nimport type { ParameterObject } from \"../types.js\";\n\nexport const JS_PROPERTY_INDEX_RE = /^[A-Za-z_$][A-Za-z_$0-9]*$/;\nexport const JS_ENUM_INVALID_CHARS_RE = /[^A-Za-z_$0-9]+(.)?/g;\nexport const JS_PROPERTY_INDEX_INVALID_CHARS_RE = /[^A-Za-z_$0-9]+/g;\nexport const SPECIAL_CHARACTER_MAP: Record<string, string> = {\n  \"+\": \"Plus\",\n  // Add more mappings as needed\n};\n\nexport const BOOLEAN = ts.factory.createKeywordTypeNode(ts.SyntaxKind.BooleanKeyword);\nexport const FALSE = ts.factory.createLiteralTypeNode(ts.factory.createFalse());\nexport const NEVER = ts.factory.createKeywordTypeNode(ts.SyntaxKind.NeverKeyword);\nexport const NULL = ts.factory.createLiteralTypeNode(ts.factory.createNull());\nexport const NUMBER = ts.factory.createKeywordTypeNode(ts.SyntaxKind.NumberKeyword);\nexport const QUESTION_TOKEN = ts.factory.createToken(ts.SyntaxKind.QuestionToken);\nexport const STRING = ts.factory.createKeywordTypeNode(ts.SyntaxKind.StringKeyword);\nexport const TRUE = ts.factory.createLiteralTypeNode(ts.factory.createTrue());\nexport const UNDEFINED = ts.factory.createKeywordTypeNode(ts.SyntaxKind.UndefinedKeyword);\nexport const UNKNOWN = ts.factory.createKeywordTypeNode(ts.SyntaxKind.UnknownKeyword);\n\nconst LB_RE = /\\r?\\n/g;\nconst COMMENT_RE = /\\*\\//g;\n\nexport interface AnnotatedSchemaObject {\n  const?: unknown; // jsdoc without value\n  default?: unknown; // jsdoc with value\n  deprecated?: boolean; // jsdoc without value\n  description?: string; // jsdoc with value\n  enum?: unknown[]; // jsdoc without value\n  example?: string; // jsdoc with value\n  examples?: unknown;\n  format?: string; // not jsdoc\n  nullable?: boolean; // Node information\n  summary?: string; // not jsdoc\n  title?: string; // not jsdoc\n  type?: string | string[]; // Type of node\n}\n\n/**\n * Preparing comments from fields\n * @see {comment} for output examples\n * @returns void if not comments or jsdoc format comment string\n */\nexport function addJSDocComment(schemaObject: AnnotatedSchemaObject, node: ts.PropertySignature): void {\n  if (!schemaObject || typeof schemaObject !== \"object\" || Array.isArray(schemaObject)) {\n    return;\n  }\n  const output: string[] = [];\n\n  // Not JSDoc tags: [title, format]\n  if (schemaObject.title) {\n    output.push(schemaObject.title.trim().replace(LB_RE, \"\\n *     \"));\n  }\n  if (schemaObject.summary) {\n    output.push(schemaObject.summary.trim().replace(LB_RE, \"\\n *     \"));\n  }\n  if (schemaObject.format) {\n    output.push(`Format: ${schemaObject.format}`);\n  }\n\n  // JSDoc tags without value\n  // 'Deprecated' without value\n  if (schemaObject.deprecated) {\n    output.push(\"@deprecated\");\n  }\n\n  // JSDoc tags with value\n  const supportedJsDocTags = [\"description\", \"default\", \"example\"] as const;\n  for (const field of supportedJsDocTags) {\n    const allowEmptyString = field === \"default\" || field === \"example\";\n    if (schemaObject[field] === undefined) {\n      continue;\n    }\n    if (schemaObject[field] === \"\" && !allowEmptyString) {\n      continue;\n    }\n    const serialized =\n      typeof schemaObject[field] === \"object\" ? JSON.stringify(schemaObject[field], null, 2) : schemaObject[field];\n    output.push(`@${field} ${String(serialized).trim().replace(LB_RE, \"\\n *     \")}`);\n  }\n\n  if (Array.isArray(schemaObject.examples)) {\n    for (const example of schemaObject.examples) {\n      const serialized = typeof example === \"object\" ? JSON.stringify(example, null, 2) : example;\n      output.push(`@example ${String(serialized).trim().replace(LB_RE, \"\\n *     \")}`);\n    }\n  }\n\n  // JSDoc 'Constant' without value\n  if (\"const\" in schemaObject) {\n    output.push(\"@constant\");\n  }\n\n  // JSDoc 'Enum' with type\n  if (schemaObject.enum) {\n    let type = \"unknown\";\n    if (Array.isArray(schemaObject.type)) {\n      type = schemaObject.type.join(\"|\");\n    } else if (typeof schemaObject.type === \"string\") {\n      type = schemaObject.type;\n    }\n    output.push(`@enum {${type}${schemaObject.nullable ? \"|null\" : \"\"}}`);\n  }\n\n  // attach comment if it has content\n\n  if (output.length) {\n    // Check if any output item contains multi-line content (has internal line breaks)\n    const hasMultiLineContent = output.some((item) => item.includes(\"\\n\"));\n\n    let text =\n      output.length === 1 && !hasMultiLineContent ? `* ${output.join(\"\\n\")} ` : `*\\n * ${output.join(\"\\n * \")}\\n `;\n    text = text.replace(COMMENT_RE, \"*\\\\/\"); // prevent inner comments from leaking\n\n    ts.addSyntheticLeadingComment(\n      /* node               */ node,\n      /* kind               */ ts.SyntaxKind.MultiLineCommentTrivia, // note: MultiLine just refers to a \"/* */\" comment\n      /* text               */ text,\n      /* hasTrailingNewLine */ true,\n    );\n  }\n}\n\nfunction isOasRef<T>(obj: Referenced<T>): obj is OasRef {\n  return Boolean((obj as OasRef).$ref);\n}\ntype OapiRefResolved = Referenced<ParameterObject>;\n\nfunction isParameterObject(obj: OapiRefResolved | undefined): obj is ParameterObject {\n  return Boolean(obj && !isOasRef(obj) && obj.in);\n}\n\nfunction addIndexedAccess(node: ts.TypeReferenceNode | ts.IndexedAccessTypeNode, ...segments: readonly string[]) {\n  return segments.reduce((acc, segment) => {\n    return ts.factory.createIndexedAccessTypeNode(\n      acc,\n      ts.factory.createLiteralTypeNode(\n        typeof segment === \"number\"\n          ? ts.factory.createNumericLiteral(segment)\n          : ts.factory.createStringLiteral(segment),\n      ),\n    );\n  }, node);\n}\n\n/**\n * Convert OpenAPI ref into TS indexed access node (ex: `components[\"schemas\"][\"Foo\"]`)\n * `path` is a JSON Pointer to a location within an OpenAPI document.\n * Transform it into a TypeScript type reference into the generated types.\n *\n * In most cases the structures of the openapi-typescript generated types and the\n * JSON Pointer paths into the OpenAPI document are the same. However, in some cases\n * special transformations are necessary to account for the ways they differ.\n *   * Object schemas\n *       $refs into the `properties` of object schemas are valid, but openapi-typescript\n *       flattens these objects, so we omit  so the index into the schema skips [\"properties\"]\n *   * Parameters\n *       $refs into the `parameters` of paths are valid, but openapi-ts represents\n *       them according to their type; path, query, header, etc… so in these cases we\n *       must check the parameter definition to determine the how to index into\n *       the openapi-typescript type.\n **/\nexport function oapiRef(path: string, resolved?: OapiRefResolved, deep = false): ts.TypeNode {\n  const { pointer } = parseRef(path);\n  if (pointer.length === 0) {\n    throw new Error(`Error parsing $ref: ${path}. Is this a valid $ref?`);\n  }\n\n  const parametersObject = isParameterObject(resolved);\n\n  // Initial segments are handled in a fixed , then remaining segments are treated\n  // according to heuristics based on the initial segments\n  const initialSegment = pointer[0];\n  const leadingSegments = pointer.slice(1, 3);\n  const restSegments = pointer.slice(3);\n\n  const leadingType = addIndexedAccess(\n    ts.factory.createTypeReferenceNode(\n      ts.factory.createIdentifier(deep ? `FlattenedDeepRequired<${String(initialSegment)}>` : String(initialSegment)),\n    ),\n    ...leadingSegments,\n  );\n\n  return restSegments.reduce<ts.TypeReferenceNode | ts.IndexedAccessTypeNode>((acc, segment, index, original) => {\n    // Skip `properties` items when in the middle of the pointer\n    // See: https://github.com/openapi-ts/openapi-typescript/issues/1742\n    if (segment === \"properties\") {\n      return acc;\n    }\n\n    if (parametersObject && index === original.length - 1) {\n      return addIndexedAccess(acc, resolved.in, resolved.name);\n    }\n\n    return addIndexedAccess(acc, segment);\n  }, leadingType);\n}\n\nexport interface AstToStringOptions {\n  fileName?: string;\n  sourceText?: string;\n  formatOptions?: ts.PrinterOptions;\n}\n\n/** Convert TypeScript AST to string */\nexport function astToString(\n  ast: ts.Node | ts.Node[] | ts.TypeElement | ts.TypeElement[],\n  options?: AstToStringOptions,\n): string {\n  const sourceFile = ts.createSourceFile(\n    options?.fileName ?? \"openapi-ts.ts\",\n    options?.sourceText ?? \"\",\n    ts.ScriptTarget.ESNext,\n    false,\n    ts.ScriptKind.TS,\n  );\n\n  // @ts-expect-error it’s OK to overwrite statements once\n  sourceFile.statements = ts.factory.createNodeArray(Array.isArray(ast) ? ast : [ast]);\n\n  const printer = ts.createPrinter({\n    newLine: ts.NewLineKind.LineFeed,\n    removeComments: false,\n    ...options?.formatOptions,\n  });\n  return printer.printFile(sourceFile);\n}\n\n/** Convert an arbitrary string to TS (assuming it’s valid) */\nexport function stringToAST(source: string): unknown[] {\n  return ts.createSourceFile(\n    /* fileName        */ \"stringInput\",\n    /* sourceText      */ source,\n    /* languageVersion */ ts.ScriptTarget.ESNext,\n    /* setParentNodes  */ undefined,\n    /* scriptKind      */ undefined,\n  ).statements as any;\n}\n\n/**\n * Deduplicate simple primitive types from an array of nodes\n * Note: won’t deduplicate complex types like objects\n */\nexport function tsDedupe(types: ts.TypeNode[]): ts.TypeNode[] {\n  const encounteredTypes = new Set<number>();\n  const filteredTypes: ts.TypeNode[] = [];\n  for (const t of types) {\n    // only mark for deduplication if this is not a const (\"text\" means it is a const)\n    if (!(\"text\" in ((t as LiteralTypeNode).literal ?? t))) {\n      const { kind } = (t as LiteralTypeNode).literal ?? t;\n      if (encounteredTypes.has(kind)) {\n        continue;\n      }\n      if (tsIsPrimitive(t)) {\n        encounteredTypes.add(kind);\n      }\n    }\n    filteredTypes.push(t);\n  }\n  return filteredTypes;\n}\n\nexport const enumCache = new Map<string, ts.EnumDeclaration>();\n\n/** Create a TS enum (with sanitized name and members) */\nexport function tsEnum(\n  name: string,\n  members: (string | number)[],\n  metadata?: { name?: string; description?: string | null }[],\n  options?: { export?: boolean; shouldCache?: boolean },\n) {\n  let enumName = sanitizeMemberName(name);\n  enumName = `${enumName[0].toUpperCase()}${enumName.substring(1)}`;\n  let key = \"\";\n  if (options?.shouldCache) {\n    key = `${members\n      .slice(0)\n      .sort()\n      .map((v, i) => {\n        return `${metadata?.[i]?.name ?? String(v)}:${metadata?.[i]?.description || \"\"}`;\n      })\n      .join(\",\")}`;\n    if (enumCache.has(key)) {\n      return enumCache.get(key) as ts.EnumDeclaration;\n    }\n  }\n  const enumDeclaration = ts.factory.createEnumDeclaration(\n    /* modifiers */ options ? tsModifiers({ export: options.export ?? false }) : undefined,\n    /* name      */ enumName,\n    /* members   */ members.map((value, i) => tsEnumMember(value, metadata?.[i])),\n  );\n  options?.shouldCache && enumCache.set(key, enumDeclaration);\n  return enumDeclaration;\n}\n\n/** Create an exported TS array literal expression  */\nexport function tsArrayLiteralExpression(\n  name: string,\n  elementType: ts.TypeNode,\n  values: (string | number)[],\n  options?: { export?: boolean; readonly?: boolean; injectFooter?: ts.Node[] },\n) {\n  let variableName = sanitizeMemberName(name);\n  variableName = `${variableName[0].toLowerCase()}${variableName.substring(1)}`;\n\n  if (\n    options?.injectFooter &&\n    !options.injectFooter.some(\n      (node) => ts.isTypeAliasDeclaration(node) && node?.name?.escapedText === \"FlattenedDeepRequired\",\n    )\n  ) {\n    const helper = stringToAST(\n      \"type FlattenedDeepRequired<T> = { [K in keyof T]-?: FlattenedDeepRequired<T[K] extends unknown[] | undefined | null ? Extract<T[K], unknown[]>[number] : T[K]>; };\",\n    )[0] as any;\n    options.injectFooter.push(helper);\n  }\n\n  const arrayType = options?.readonly\n    ? tsReadonlyArray(elementType, options.injectFooter)\n    : ts.factory.createArrayTypeNode(elementType);\n\n  return ts.factory.createVariableStatement(\n    options ? tsModifiers({ export: options.export ?? false }) : undefined,\n    ts.factory.createVariableDeclarationList(\n      [\n        ts.factory.createVariableDeclaration(\n          variableName,\n          undefined,\n          arrayType,\n          ts.factory.createArrayLiteralExpression(\n            values.map((value) => {\n              if (typeof value === \"number\") {\n                if (value < 0) {\n                  return ts.factory.createPrefixUnaryExpression(\n                    ts.SyntaxKind.MinusToken,\n                    ts.factory.createNumericLiteral(Math.abs(value)),\n                  );\n                } else {\n                  return ts.factory.createNumericLiteral(value);\n                }\n              } else {\n                return ts.factory.createStringLiteral(value);\n              }\n            }),\n          ),\n        ),\n      ],\n      ts.NodeFlags.Const,\n    ),\n  );\n}\n\nfunction sanitizeMemberName(name: string) {\n  let sanitizedName = name.replace(JS_ENUM_INVALID_CHARS_RE, (c) => {\n    const last = c[c.length - 1];\n    return JS_PROPERTY_INDEX_INVALID_CHARS_RE.test(last) ? \"\" : last.toUpperCase();\n  });\n  if (Number(name[0]) >= 0) {\n    sanitizedName = `Value${name}`;\n  }\n  return sanitizedName;\n}\n\n/** Sanitize TS enum member expression */\nexport function tsEnumMember(value: string | number, metadata: { name?: string; description?: string | null } = {}) {\n  let name = metadata.name ?? String(value);\n  if (!JS_PROPERTY_INDEX_RE.test(name)) {\n    if (Number(name[0]) >= 0) {\n      name = `Value${name}`.replace(\".\", \"_\"); // don't forged decimals;\n    } else if (name[0] === \"-\") {\n      name = `ValueMinus${name.slice(1)}`;\n    }\n\n    const invalidCharMatch = name.match(JS_PROPERTY_INDEX_INVALID_CHARS_RE);\n    if (invalidCharMatch) {\n      if (invalidCharMatch[0] === name) {\n        name = `\"${name}\"`;\n      } else {\n        name = name.replace(JS_PROPERTY_INDEX_INVALID_CHARS_RE, (s) => {\n          return s in SPECIAL_CHARACTER_MAP ? SPECIAL_CHARACTER_MAP[s] : \"_\";\n        });\n      }\n    }\n  }\n\n  let member: ts.EnumMember;\n  if (typeof value === \"number\") {\n    const literal =\n      value < 0\n        ? ts.factory.createPrefixUnaryExpression(\n            ts.SyntaxKind.MinusToken,\n            ts.factory.createNumericLiteral(Math.abs(value)),\n          )\n        : ts.factory.createNumericLiteral(value);\n\n    member = ts.factory.createEnumMember(name, literal);\n  } else {\n    member = ts.factory.createEnumMember(name, ts.factory.createStringLiteral(value));\n  }\n\n  const trimmedDescription = metadata.description?.trim();\n  if (trimmedDescription === undefined || trimmedDescription === null || trimmedDescription === \"\") {\n    return member;\n  }\n\n  return ts.addSyntheticLeadingComment(member, ts.SyntaxKind.SingleLineCommentTrivia, ` ${trimmedDescription}`, true);\n}\n\n/** Create an intersection type */\nexport function tsIntersection(types: ts.TypeNode[]): ts.TypeNode {\n  if (types.length === 0) {\n    return NEVER;\n  }\n  if (types.length === 1) {\n    return types[0];\n  }\n  return ts.factory.createIntersectionTypeNode(tsDedupe(types));\n}\n\n/** Is this a primitive type (string, number, boolean, null, undefined)? */\nexport function tsIsPrimitive(type: ts.TypeNode): boolean {\n  if (!type) {\n    return true;\n  }\n  return (\n    ts.SyntaxKind[type.kind] === \"BooleanKeyword\" ||\n    ts.SyntaxKind[type.kind] === \"NeverKeyword\" ||\n    ts.SyntaxKind[type.kind] === \"NullKeyword\" ||\n    ts.SyntaxKind[type.kind] === \"NumberKeyword\" ||\n    ts.SyntaxKind[type.kind] === \"StringKeyword\" ||\n    ts.SyntaxKind[type.kind] === \"UndefinedKeyword\" ||\n    (\"literal\" in type && tsIsPrimitive(type.literal as TypeLiteralNode))\n  );\n}\n\n/** Create a literal type */\nexport function tsLiteral(value: unknown): ts.TypeNode {\n  if (typeof value === \"string\") {\n    // workaround for UTF-8: https://github.com/microsoft/TypeScript/issues/36174\n    return ts.factory.createIdentifier(JSON.stringify(value)) as unknown as ts.TypeNode;\n  }\n  if (typeof value === \"number\") {\n    const literal =\n      value < 0\n        ? ts.factory.createPrefixUnaryExpression(\n            ts.SyntaxKind.MinusToken,\n            ts.factory.createNumericLiteral(Math.abs(value)),\n          )\n        : ts.factory.createNumericLiteral(value);\n    return ts.factory.createLiteralTypeNode(literal);\n  }\n  if (typeof value === \"boolean\") {\n    return value === true ? TRUE : FALSE;\n  }\n  if (value === null) {\n    return NULL;\n  }\n  if (Array.isArray(value)) {\n    if (value.length === 0) {\n      return ts.factory.createArrayTypeNode(NEVER);\n    }\n    return ts.factory.createTupleTypeNode(value.map((v: unknown) => tsLiteral(v)));\n  }\n  if (typeof value === \"object\") {\n    const keys: ts.TypeElement[] = [];\n    for (const [k, v] of Object.entries(value)) {\n      keys.push(\n        ts.factory.createPropertySignature(\n          /* modifiers     */ undefined,\n          /* name          */ tsPropertyIndex(k),\n          /* questionToken */ undefined,\n          /* type          */ tsLiteral(v),\n        ),\n      );\n    }\n    return keys.length ? ts.factory.createTypeLiteralNode(keys) : tsRecord(STRING, NEVER);\n  }\n  return UNKNOWN;\n}\n\n/** Modifiers (readonly) */\nexport function tsModifiers(modifiers: { readonly?: boolean; export?: boolean }): ts.Modifier[] {\n  const typeMods: ts.Modifier[] = [];\n  if (modifiers.export) {\n    typeMods.push(ts.factory.createModifier(ts.SyntaxKind.ExportKeyword));\n  }\n  if (modifiers.readonly) {\n    typeMods.push(ts.factory.createModifier(ts.SyntaxKind.ReadonlyKeyword));\n  }\n  return typeMods;\n}\n\n/** Create a T | null union */\nexport function tsNullable(types: ts.TypeNode[]): ts.TypeNode {\n  return ts.factory.createUnionTypeNode([...types, NULL]);\n}\n\n/** Create a TS Omit<X, Y> type */\nexport function tsOmit(type: ts.TypeNode, keys: string[]): ts.TypeNode {\n  return ts.factory.createTypeReferenceNode(ts.factory.createIdentifier(\"Omit\"), [\n    type,\n    ts.factory.createUnionTypeNode(keys.map((k) => tsLiteral(k))),\n  ]);\n}\n\n/** Create a TS Record<X, Y> type */\nexport function tsRecord(key: ts.TypeNode, value: ts.TypeNode) {\n  return ts.factory.createTypeReferenceNode(ts.factory.createIdentifier(\"Record\"), [key, value]);\n}\n\n/** Create a valid property index */\nexport function tsPropertyIndex(index: string | number) {\n  if (\n    (typeof index === \"number\" && !(index < 0)) ||\n    (typeof index === \"string\" && String(Number(index)) === index && index[0] !== \"-\")\n  ) {\n    return ts.factory.createNumericLiteral(index);\n  }\n  return typeof index === \"string\" && JS_PROPERTY_INDEX_RE.test(index)\n    ? ts.factory.createIdentifier(index)\n    : ts.factory.createStringLiteral(String(index));\n}\n\n/** Create a union type */\nexport function tsUnion(types: ts.TypeNode[]): ts.TypeNode {\n  if (types.length === 0) {\n    return NEVER;\n  }\n  if (types.length === 1) {\n    return types[0];\n  }\n  return ts.factory.createUnionTypeNode(tsDedupe(types));\n}\n\n/** Create a WithRequired<X, Y> type */\nexport function tsWithRequired(\n  type: ts.TypeNode,\n  keys: string[],\n  injectFooter: ts.Node[], // needed to inject type helper if used\n): ts.TypeNode {\n  if (keys.length === 0) {\n    return type;\n  }\n\n  // inject helper, if needed\n  if (!injectFooter.some((node) => ts.isTypeAliasDeclaration(node) && node?.name?.escapedText === \"WithRequired\")) {\n    const helper = stringToAST(\"type WithRequired<T, K extends keyof T> = T & { [P in K]-?: T[P] };\")[0] as any;\n    injectFooter.push(helper);\n  }\n\n  return ts.factory.createTypeReferenceNode(ts.factory.createIdentifier(\"WithRequired\"), [\n    type,\n    tsUnion(keys.map((k) => tsLiteral(k))),\n  ]);\n}\n\n/**\n * Enhanced ReadonlyArray.\n * eg: type Foo = ReadonlyArray<T>; type Bar = ReadonlyArray<T[]>\n * Foo and Bar are both of type `readonly T[]`\n */\nexport function tsReadonlyArray(type: ts.TypeNode, injectFooter?: ts.Node[]): ts.TypeNode {\n  if (\n    injectFooter &&\n    !injectFooter.some((node) => ts.isTypeAliasDeclaration(node) && node?.name?.escapedText === \"ReadonlyArray\")\n  ) {\n    const helper = stringToAST(\n      \"type ReadonlyArray<T> = [Exclude<T, undefined>] extends [unknown[]] ? Readonly<Exclude<T, undefined>> : Readonly<Exclude<T, undefined>[]>;\",\n    )[0] as any;\n    injectFooter.push(helper);\n  }\n  return ts.factory.createTypeReferenceNode(ts.factory.createIdentifier(\"ReadonlyArray\"), [type]);\n}\n"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/dist/transform/request-body-object.cjs b/dist/transform/request-body-object.cjs
index 16034a1aa6cd15b4f95d2ac76c9282564db42472..75bdd3c9873ca9843c32786afa31dc952d3ba8b4 100644
--- a/dist/transform/request-body-object.cjs
+++ b/dist/transform/request-body-object.cjs
@@ -13,7 +13,7 @@ const ts__default = /*#__PURE__*/_interopDefaultCompat(ts);
 function transformRequestBodyObject(requestBodyObject, options) {
   const type = [];
   for (const [contentType, mediaTypeObject$1] of utils.getEntries(requestBodyObject.content ?? {}, options.ctx)) {
-    const nextPath = utils.createRef([options.path, contentType]);
+    const nextPath = utils.createRef([options.path, "content", contentType]);
     const mediaType = "$ref" in mediaTypeObject$1 ? schemaObject.default(mediaTypeObject$1, {
       ...options,
       path: nextPath
diff --git a/dist/transform/request-body-object.cjs.map b/dist/transform/request-body-object.cjs.map
index 3ccd074a54c8b495d480558c1f547e3475f1b3a3..b460c4f00fe455f290dcebcabd79f65689f6fa88 100644
--- a/dist/transform/request-body-object.cjs.map
+++ b/dist/transform/request-body-object.cjs.map
@@ -1 +1 @@
-{"version":3,"file":"request-body-object.cjs","sources":["../../src/transform/request-body-object.ts"],"sourcesContent":["import ts from \"typescript\";\nimport { addJSDocComment, NEVER, QUESTION_TOKEN, tsModifiers, tsPropertyIndex } from \"../lib/ts.js\";\nimport { createRef, getEntries } from \"../lib/utils.js\";\nimport type { RequestBodyObject, TransformNodeOptions } from \"../types.js\";\nimport transformMediaTypeObject from \"./media-type-object.js\";\nimport transformSchemaObject from \"./schema-object.js\";\n\n/**\n * Transform RequestBodyObject nodes (4.8.13)\n * @see https://spec.openapis.org/oas/v3.1.0#request-body-object\n */\nexport default function transformRequestBodyObject(\n  requestBodyObject: RequestBodyObject,\n  options: TransformNodeOptions,\n): ts.TypeNode {\n  const type: ts.TypeElement[] = [];\n  for (const [contentType, mediaTypeObject] of getEntries(requestBodyObject.content ?? {}, options.ctx)) {\n    const nextPath = createRef([options.path, contentType]);\n    const mediaType =\n      \"$ref\" in mediaTypeObject\n        ? transformSchemaObject(mediaTypeObject, {\n            ...options,\n            path: nextPath,\n          })\n        : transformMediaTypeObject(mediaTypeObject, {\n            ...options,\n            path: nextPath,\n          });\n    const property = ts.factory.createPropertySignature(\n      /* modifiers     */ tsModifiers({ readonly: options.ctx.immutable }),\n      /* name          */ tsPropertyIndex(contentType),\n      /* questionToken */ undefined,\n      /* type          */ mediaType,\n    );\n    addJSDocComment(mediaTypeObject, property);\n    type.push(property);\n  }\n\n  return ts.factory.createTypeLiteralNode([\n    ts.factory.createPropertySignature(\n      /* modifiers     */ tsModifiers({ readonly: options.ctx.immutable }),\n      /* name          */ tsPropertyIndex(\"content\"),\n      /* questionToken */ undefined,\n      /* type          */ ts.factory.createTypeLiteralNode(\n        type.length\n          ? type\n          : // add `\"*/*\": never` if no media types are defined\n            [\n              ts.factory.createPropertySignature(\n                /* modifiers     */ undefined,\n                /* name          */ tsPropertyIndex(\"*/*\"),\n                /* questionToken */ QUESTION_TOKEN,\n                /* type          */ NEVER,\n              ),\n            ],\n      ),\n    ),\n  ]);\n}\n"],"names":["mediaTypeObject","getEntries","createRef","transformSchemaObject","transformMediaTypeObject","ts","tsModifiers","tsPropertyIndex","addJSDocComment","QUESTION_TOKEN","NEVER"],"mappings":";;;;;;;;;;;;AAWA,SAAwB,0BAAA,CACtB,mBACA,OAAA,EACa;AACb,EAAA,MAAM,OAAyB,EAAC;AAChC,EAAA,KAAA,MAAW,CAAC,WAAA,EAAaA,iBAAe,CAAA,IAAKC,gBAAA,CAAW,iBAAA,CAAkB,OAAA,IAAW,EAAC,EAAG,OAAA,CAAQ,GAAG,CAAA,EAAG;AACrG,IAAA,MAAM,WAAWC,eAAA,CAAU,CAAC,OAAA,CAAQ,IAAA,EAAM,WAAW,CAAC,CAAA;AACtD,IAAA,MAAM,SAAA,GACJ,MAAA,IAAUF,iBAAA,GACNG,oBAAA,CAAsBH,iBAAA,EAAiB;AAAA,MACrC,GAAG,OAAA;AAAA,MACH,IAAA,EAAM;AAAA,KACP,CAAA,GACDI,eAAA,CAAyBJ,iBAAA,EAAiB;AAAA,MACxC,GAAG,OAAA;AAAA,MACH,IAAA,EAAM;AAAA,KACP,CAAA;AACP,IAAA,MAAM,QAAA,GAAWK,YAAG,OAAA,CAAQ,uBAAA;AAAA;AAAA,MACNC,iBAAY,EAAE,QAAA,EAAU,OAAA,CAAQ,GAAA,CAAI,WAAW,CAAA;AAAA;AAAA,MAC/CC,qBAAgB,WAAW,CAAA;AAAA;AAAA,MAC3B,MAAA;AAAA;AAAA,MACA;AAAA,KACtB;AACA,IAAAC,oBAAA,CAAgBR,mBAAiB,QAAQ,CAAA;AACzC,IAAA,IAAA,CAAK,KAAK,QAAQ,CAAA;AAAA,EACpB;AAEA,EAAA,OAAOK,WAAA,CAAG,QAAQ,qBAAA,CAAsB;AAAA,IACtCA,YAAG,OAAA,CAAQ,uBAAA;AAAA;AAAA,MACWC,iBAAY,EAAE,QAAA,EAAU,OAAA,CAAQ,GAAA,CAAI,WAAW,CAAA;AAAA;AAAA,MAC/CC,qBAAgB,SAAS,CAAA;AAAA;AAAA,MACzB,MAAA;AAAA;AAAA,MACAF,YAAG,OAAA,CAAQ,qBAAA;AAAA,QAC7B,KAAK,MAAA,GACD,IAAA;AAAA;AAAA,UAEA;AAAA,YACEA,YAAG,OAAA,CAAQ,uBAAA;AAAA;AAAA,cACW,MAAA;AAAA;AAAA,cACAE,qBAAgB,KAAK,CAAA;AAAA;AAAA,cACrBE,mBAAA;AAAA;AAAA,cACAC;AAAA;AACtB;AACF;AAAA;AACN;AACF,GACD,CAAA;AACH;;;;"}
\ No newline at end of file
+{"version":3,"file":"request-body-object.cjs","sources":["../../src/transform/request-body-object.ts"],"sourcesContent":["import ts from \"typescript\";\nimport { addJSDocComment, NEVER, QUESTION_TOKEN, tsModifiers, tsPropertyIndex } from \"../lib/ts.js\";\nimport { createRef, getEntries } from \"../lib/utils.js\";\nimport type { RequestBodyObject, TransformNodeOptions } from \"../types.js\";\nimport transformMediaTypeObject from \"./media-type-object.js\";\nimport transformSchemaObject from \"./schema-object.js\";\n\n/**\n * Transform RequestBodyObject nodes (4.8.13)\n * @see https://spec.openapis.org/oas/v3.1.0#request-body-object\n */\nexport default function transformRequestBodyObject(\n  requestBodyObject: RequestBodyObject,\n  options: TransformNodeOptions,\n): ts.TypeNode {\n  const type: ts.TypeElement[] = [];\n  for (const [contentType, mediaTypeObject] of getEntries(requestBodyObject.content ?? {}, options.ctx)) {\n    const nextPath = createRef([options.path, \"content\", contentType]);\n    const mediaType =\n      \"$ref\" in mediaTypeObject\n        ? transformSchemaObject(mediaTypeObject, {\n            ...options,\n            path: nextPath,\n          })\n        : transformMediaTypeObject(mediaTypeObject, {\n            ...options,\n            path: nextPath,\n          });\n    const property = ts.factory.createPropertySignature(\n      /* modifiers     */ tsModifiers({ readonly: options.ctx.immutable }),\n      /* name          */ tsPropertyIndex(contentType),\n      /* questionToken */ undefined,\n      /* type          */ mediaType,\n    );\n    addJSDocComment(mediaTypeObject, property);\n    type.push(property);\n  }\n\n  return ts.factory.createTypeLiteralNode([\n    ts.factory.createPropertySignature(\n      /* modifiers     */ tsModifiers({ readonly: options.ctx.immutable }),\n      /* name          */ tsPropertyIndex(\"content\"),\n      /* questionToken */ undefined,\n      /* type          */ ts.factory.createTypeLiteralNode(\n        type.length\n          ? type\n          : // add `\"*/*\": never` if no media types are defined\n            [\n              ts.factory.createPropertySignature(\n                /* modifiers     */ undefined,\n                /* name          */ tsPropertyIndex(\"*/*\"),\n                /* questionToken */ QUESTION_TOKEN,\n                /* type          */ NEVER,\n              ),\n            ],\n      ),\n    ),\n  ]);\n}\n"],"names":["mediaTypeObject","getEntries","createRef","transformSchemaObject","transformMediaTypeObject","ts","tsModifiers","tsPropertyIndex","addJSDocComment","QUESTION_TOKEN","NEVER"],"mappings":";;;;;;;;;;;;AAWA,SAAwB,0BAAA,CACtB,mBACA,OAAA,EACa;AACb,EAAA,MAAM,OAAyB,EAAC;AAChC,EAAA,KAAA,MAAW,CAAC,WAAA,EAAaA,iBAAe,CAAA,IAAKC,gBAAA,CAAW,iBAAA,CAAkB,OAAA,IAAW,EAAC,EAAG,OAAA,CAAQ,GAAG,CAAA,EAAG;AACrG,IAAA,MAAM,WAAWC,eAAA,CAAU,CAAC,QAAQ,IAAA,EAAM,SAAA,EAAW,WAAW,CAAC,CAAA;AACjE,IAAA,MAAM,SAAA,GACJ,MAAA,IAAUF,iBAAA,GACNG,oBAAA,CAAsBH,iBAAA,EAAiB;AAAA,MACrC,GAAG,OAAA;AAAA,MACH,IAAA,EAAM;AAAA,KACP,CAAA,GACDI,eAAA,CAAyBJ,iBAAA,EAAiB;AAAA,MACxC,GAAG,OAAA;AAAA,MACH,IAAA,EAAM;AAAA,KACP,CAAA;AACP,IAAA,MAAM,QAAA,GAAWK,YAAG,OAAA,CAAQ,uBAAA;AAAA;AAAA,MACNC,iBAAY,EAAE,QAAA,EAAU,OAAA,CAAQ,GAAA,CAAI,WAAW,CAAA;AAAA;AAAA,MAC/CC,qBAAgB,WAAW,CAAA;AAAA;AAAA,MAC3B,MAAA;AAAA;AAAA,MACA;AAAA,KACtB;AACA,IAAAC,oBAAA,CAAgBR,mBAAiB,QAAQ,CAAA;AACzC,IAAA,IAAA,CAAK,KAAK,QAAQ,CAAA;AAAA,EACpB;AAEA,EAAA,OAAOK,WAAA,CAAG,QAAQ,qBAAA,CAAsB;AAAA,IACtCA,YAAG,OAAA,CAAQ,uBAAA;AAAA;AAAA,MACWC,iBAAY,EAAE,QAAA,EAAU,OAAA,CAAQ,GAAA,CAAI,WAAW,CAAA;AAAA;AAAA,MAC/CC,qBAAgB,SAAS,CAAA;AAAA;AAAA,MACzB,MAAA;AAAA;AAAA,MACAF,YAAG,OAAA,CAAQ,qBAAA;AAAA,QAC7B,KAAK,MAAA,GACD,IAAA;AAAA;AAAA,UAEA;AAAA,YACEA,YAAG,OAAA,CAAQ,uBAAA;AAAA;AAAA,cACW,MAAA;AAAA;AAAA,cACAE,qBAAgB,KAAK,CAAA;AAAA;AAAA,cACrBE,mBAAA;AAAA;AAAA,cACAC;AAAA;AACtB;AACF;AAAA;AACN;AACF,GACD,CAAA;AACH;;;;"}
\ No newline at end of file
diff --git a/dist/transform/request-body-object.mjs b/dist/transform/request-body-object.mjs
index b076cb1067987aadbe2f12fb1b7b0fd8cd3db670..0f6583f03382c26a842d1b70d93f3ec374d97696 100644
--- a/dist/transform/request-body-object.mjs
+++ b/dist/transform/request-body-object.mjs
@@ -7,7 +7,7 @@ import transformSchemaObject from './schema-object.mjs';
 function transformRequestBodyObject(requestBodyObject, options) {
   const type = [];
   for (const [contentType, mediaTypeObject] of getEntries(requestBodyObject.content ?? {}, options.ctx)) {
-    const nextPath = createRef([options.path, contentType]);
+    const nextPath = createRef([options.path, "content", contentType]);
     const mediaType = "$ref" in mediaTypeObject ? transformSchemaObject(mediaTypeObject, {
       ...options,
       path: nextPath
diff --git a/dist/transform/request-body-object.mjs.map b/dist/transform/request-body-object.mjs.map
index 5ad7781c257f8c4bce4ea1d463cbd925bf2f51a2..a67c757cd4b470a991e02f0b5efde9ca482c7aad 100644
--- a/dist/transform/request-body-object.mjs.map
+++ b/dist/transform/request-body-object.mjs.map
@@ -1 +1 @@
-{"version":3,"file":"request-body-object.mjs","sources":["../../src/transform/request-body-object.ts"],"sourcesContent":["import ts from \"typescript\";\nimport { addJSDocComment, NEVER, QUESTION_TOKEN, tsModifiers, tsPropertyIndex } from \"../lib/ts.js\";\nimport { createRef, getEntries } from \"../lib/utils.js\";\nimport type { RequestBodyObject, TransformNodeOptions } from \"../types.js\";\nimport transformMediaTypeObject from \"./media-type-object.js\";\nimport transformSchemaObject from \"./schema-object.js\";\n\n/**\n * Transform RequestBodyObject nodes (4.8.13)\n * @see https://spec.openapis.org/oas/v3.1.0#request-body-object\n */\nexport default function transformRequestBodyObject(\n  requestBodyObject: RequestBodyObject,\n  options: TransformNodeOptions,\n): ts.TypeNode {\n  const type: ts.TypeElement[] = [];\n  for (const [contentType, mediaTypeObject] of getEntries(requestBodyObject.content ?? {}, options.ctx)) {\n    const nextPath = createRef([options.path, contentType]);\n    const mediaType =\n      \"$ref\" in mediaTypeObject\n        ? transformSchemaObject(mediaTypeObject, {\n            ...options,\n            path: nextPath,\n          })\n        : transformMediaTypeObject(mediaTypeObject, {\n            ...options,\n            path: nextPath,\n          });\n    const property = ts.factory.createPropertySignature(\n      /* modifiers     */ tsModifiers({ readonly: options.ctx.immutable }),\n      /* name          */ tsPropertyIndex(contentType),\n      /* questionToken */ undefined,\n      /* type          */ mediaType,\n    );\n    addJSDocComment(mediaTypeObject, property);\n    type.push(property);\n  }\n\n  return ts.factory.createTypeLiteralNode([\n    ts.factory.createPropertySignature(\n      /* modifiers     */ tsModifiers({ readonly: options.ctx.immutable }),\n      /* name          */ tsPropertyIndex(\"content\"),\n      /* questionToken */ undefined,\n      /* type          */ ts.factory.createTypeLiteralNode(\n        type.length\n          ? type\n          : // add `\"*/*\": never` if no media types are defined\n            [\n              ts.factory.createPropertySignature(\n                /* modifiers     */ undefined,\n                /* name          */ tsPropertyIndex(\"*/*\"),\n                /* questionToken */ QUESTION_TOKEN,\n                /* type          */ NEVER,\n              ),\n            ],\n      ),\n    ),\n  ]);\n}\n"],"names":[],"mappings":";;;;;;AAWA,SAAwB,0BAAA,CACtB,mBACA,OAAA,EACa;AACb,EAAA,MAAM,OAAyB,EAAC;AAChC,EAAA,KAAA,MAAW,CAAC,WAAA,EAAa,eAAe,CAAA,IAAK,UAAA,CAAW,iBAAA,CAAkB,OAAA,IAAW,EAAC,EAAG,OAAA,CAAQ,GAAG,CAAA,EAAG;AACrG,IAAA,MAAM,WAAW,SAAA,CAAU,CAAC,OAAA,CAAQ,IAAA,EAAM,WAAW,CAAC,CAAA;AACtD,IAAA,MAAM,SAAA,GACJ,MAAA,IAAU,eAAA,GACN,qBAAA,CAAsB,eAAA,EAAiB;AAAA,MACrC,GAAG,OAAA;AAAA,MACH,IAAA,EAAM;AAAA,KACP,CAAA,GACD,wBAAA,CAAyB,eAAA,EAAiB;AAAA,MACxC,GAAG,OAAA;AAAA,MACH,IAAA,EAAM;AAAA,KACP,CAAA;AACP,IAAA,MAAM,QAAA,GAAW,GAAG,OAAA,CAAQ,uBAAA;AAAA;AAAA,MACN,YAAY,EAAE,QAAA,EAAU,OAAA,CAAQ,GAAA,CAAI,WAAW,CAAA;AAAA;AAAA,MAC/C,gBAAgB,WAAW,CAAA;AAAA;AAAA,MAC3B,MAAA;AAAA;AAAA,MACA;AAAA,KACtB;AACA,IAAA,eAAA,CAAgB,iBAAiB,QAAQ,CAAA;AACzC,IAAA,IAAA,CAAK,KAAK,QAAQ,CAAA;AAAA,EACpB;AAEA,EAAA,OAAO,EAAA,CAAG,QAAQ,qBAAA,CAAsB;AAAA,IACtC,GAAG,OAAA,CAAQ,uBAAA;AAAA;AAAA,MACW,YAAY,EAAE,QAAA,EAAU,OAAA,CAAQ,GAAA,CAAI,WAAW,CAAA;AAAA;AAAA,MAC/C,gBAAgB,SAAS,CAAA;AAAA;AAAA,MACzB,MAAA;AAAA;AAAA,MACA,GAAG,OAAA,CAAQ,qBAAA;AAAA,QAC7B,KAAK,MAAA,GACD,IAAA;AAAA;AAAA,UAEA;AAAA,YACE,GAAG,OAAA,CAAQ,uBAAA;AAAA;AAAA,cACW,MAAA;AAAA;AAAA,cACA,gBAAgB,KAAK,CAAA;AAAA;AAAA,cACrB,cAAA;AAAA;AAAA,cACA;AAAA;AACtB;AACF;AAAA;AACN;AACF,GACD,CAAA;AACH;;;;"}
\ No newline at end of file
+{"version":3,"file":"request-body-object.mjs","sources":["../../src/transform/request-body-object.ts"],"sourcesContent":["import ts from \"typescript\";\nimport { addJSDocComment, NEVER, QUESTION_TOKEN, tsModifiers, tsPropertyIndex } from \"../lib/ts.js\";\nimport { createRef, getEntries } from \"../lib/utils.js\";\nimport type { RequestBodyObject, TransformNodeOptions } from \"../types.js\";\nimport transformMediaTypeObject from \"./media-type-object.js\";\nimport transformSchemaObject from \"./schema-object.js\";\n\n/**\n * Transform RequestBodyObject nodes (4.8.13)\n * @see https://spec.openapis.org/oas/v3.1.0#request-body-object\n */\nexport default function transformRequestBodyObject(\n  requestBodyObject: RequestBodyObject,\n  options: TransformNodeOptions,\n): ts.TypeNode {\n  const type: ts.TypeElement[] = [];\n  for (const [contentType, mediaTypeObject] of getEntries(requestBodyObject.content ?? {}, options.ctx)) {\n    const nextPath = createRef([options.path, \"content\", contentType]);\n    const mediaType =\n      \"$ref\" in mediaTypeObject\n        ? transformSchemaObject(mediaTypeObject, {\n            ...options,\n            path: nextPath,\n          })\n        : transformMediaTypeObject(mediaTypeObject, {\n            ...options,\n            path: nextPath,\n          });\n    const property = ts.factory.createPropertySignature(\n      /* modifiers     */ tsModifiers({ readonly: options.ctx.immutable }),\n      /* name          */ tsPropertyIndex(contentType),\n      /* questionToken */ undefined,\n      /* type          */ mediaType,\n    );\n    addJSDocComment(mediaTypeObject, property);\n    type.push(property);\n  }\n\n  return ts.factory.createTypeLiteralNode([\n    ts.factory.createPropertySignature(\n      /* modifiers     */ tsModifiers({ readonly: options.ctx.immutable }),\n      /* name          */ tsPropertyIndex(\"content\"),\n      /* questionToken */ undefined,\n      /* type          */ ts.factory.createTypeLiteralNode(\n        type.length\n          ? type\n          : // add `\"*/*\": never` if no media types are defined\n            [\n              ts.factory.createPropertySignature(\n                /* modifiers     */ undefined,\n                /* name          */ tsPropertyIndex(\"*/*\"),\n                /* questionToken */ QUESTION_TOKEN,\n                /* type          */ NEVER,\n              ),\n            ],\n      ),\n    ),\n  ]);\n}\n"],"names":[],"mappings":";;;;;;AAWA,SAAwB,0BAAA,CACtB,mBACA,OAAA,EACa;AACb,EAAA,MAAM,OAAyB,EAAC;AAChC,EAAA,KAAA,MAAW,CAAC,WAAA,EAAa,eAAe,CAAA,IAAK,UAAA,CAAW,iBAAA,CAAkB,OAAA,IAAW,EAAC,EAAG,OAAA,CAAQ,GAAG,CAAA,EAAG;AACrG,IAAA,MAAM,WAAW,SAAA,CAAU,CAAC,QAAQ,IAAA,EAAM,SAAA,EAAW,WAAW,CAAC,CAAA;AACjE,IAAA,MAAM,SAAA,GACJ,MAAA,IAAU,eAAA,GACN,qBAAA,CAAsB,eAAA,EAAiB;AAAA,MACrC,GAAG,OAAA;AAAA,MACH,IAAA,EAAM;AAAA,KACP,CAAA,GACD,wBAAA,CAAyB,eAAA,EAAiB;AAAA,MACxC,GAAG,OAAA;AAAA,MACH,IAAA,EAAM;AAAA,KACP,CAAA;AACP,IAAA,MAAM,QAAA,GAAW,GAAG,OAAA,CAAQ,uBAAA;AAAA;AAAA,MACN,YAAY,EAAE,QAAA,EAAU,OAAA,CAAQ,GAAA,CAAI,WAAW,CAAA;AAAA;AAAA,MAC/C,gBAAgB,WAAW,CAAA;AAAA;AAAA,MAC3B,MAAA;AAAA;AAAA,MACA;AAAA,KACtB;AACA,IAAA,eAAA,CAAgB,iBAAiB,QAAQ,CAAA;AACzC,IAAA,IAAA,CAAK,KAAK,QAAQ,CAAA;AAAA,EACpB;AAEA,EAAA,OAAO,EAAA,CAAG,QAAQ,qBAAA,CAAsB;AAAA,IACtC,GAAG,OAAA,CAAQ,uBAAA;AAAA;AAAA,MACW,YAAY,EAAE,QAAA,EAAU,OAAA,CAAQ,GAAA,CAAI,WAAW,CAAA;AAAA;AAAA,MAC/C,gBAAgB,SAAS,CAAA;AAAA;AAAA,MACzB,MAAA;AAAA;AAAA,MACA,GAAG,OAAA,CAAQ,qBAAA;AAAA,QAC7B,KAAK,MAAA,GACD,IAAA;AAAA;AAAA,UAEA;AAAA,YACE,GAAG,OAAA,CAAQ,uBAAA;AAAA;AAAA,cACW,MAAA;AAAA;AAAA,cACA,gBAAgB,KAAK,CAAA;AAAA;AAAA,cACrB,cAAA;AAAA;AAAA,cACA;AAAA;AACtB;AACF;AAAA;AACN;AACF,GACD,CAAA;AACH;;;;"}
\ No newline at end of file
diff --git a/dist/transform/schema-object.cjs b/dist/transform/schema-object.cjs
index 862ee9d753202fe920065df98af815258b217f4e..69b5510916d101c2a33c9a5e02ea8c086301a394 100644
--- a/dist/transform/schema-object.cjs
+++ b/dist/transform/schema-object.cjs
@@ -11,8 +11,8 @@ function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'defau
 
 const ts__default = /*#__PURE__*/_interopDefaultCompat(ts$1);
 
-function transformSchemaObject(schemaObject, options) {
-  const type = transformSchemaObjectWithComposition(schemaObject, options);
+function transformSchemaObject(schemaObject, options, fromAdditionalProperties = false) {
+  const type = transformSchemaObjectWithComposition(schemaObject, options, fromAdditionalProperties);
   if (typeof options.ctx.postTransform === "function") {
     const postTransformResult = options.ctx.postTransform(type, options);
     if (postTransformResult) {
@@ -21,7 +21,7 @@ function transformSchemaObject(schemaObject, options) {
   }
   return type;
 }
-function transformSchemaObjectWithComposition(schemaObject, options) {
+function transformSchemaObjectWithComposition(schemaObject, options, fromAdditionalProperties = false) {
   if (!schemaObject) {
     return ts.NEVER;
   }
@@ -72,12 +72,30 @@ function transformSchemaObjectWithComposition(schemaObject, options) {
     }
     const unionType = ts.tsUnion(enumType);
     if (options.ctx.enumValues && schemaObject.enum.every((v) => typeof v === "string" || typeof v === "number")) {
-      let enumValuesVariableName = refUtils_js.parseRef(options.path ?? "").pointer.join("/");
+      const parsed = refUtils_js.parseRef(options.path ?? "");
+      let enumValuesVariableName = parsed.pointer.join("/");
       enumValuesVariableName = enumValuesVariableName.replace("components/schemas", "");
       enumValuesVariableName = `${enumValuesVariableName}Values`;
+      const cleanedPointer = [];
+      for (let i = 0; i < parsed.pointer.length; i++) {
+        const segment = parsed.pointer[i];
+        if ((segment === "anyOf" || segment === "oneOf") && i < parsed.pointer.length - 1) {
+          const next = parsed.pointer[i + 1];
+          if (/^\d+$/.test(next)) {
+            i++;
+            continue;
+          }
+        }
+        cleanedPointer.push(segment);
+      }
+      const cleanedRefPath = utils.createRef(cleanedPointer);
       const enumValuesArray = ts.tsArrayLiteralExpression(
         enumValuesVariableName,
-        ts.oapiRef(options.path ?? ""),
+        // If fromAdditionalProperties is true we are dealing with a record type and we should append [string] to the generated type
+        fromAdditionalProperties ? ts__default.factory.createIndexedAccessTypeNode(
+          ts.oapiRef(cleanedRefPath, void 0, true),
+          ts__default.factory.createTypeReferenceNode(ts__default.factory.createIdentifier("string"))
+        ) : ts.oapiRef(cleanedRefPath, void 0, true),
         schemaObject.enum,
         {
           export: true,
@@ -89,10 +107,16 @@ function transformSchemaObjectWithComposition(schemaObject, options) {
     }
     return unionType;
   }
-  function collectUnionCompositions(items) {
+  function collectUnionCompositions(items, unionKey) {
     const output = [];
-    for (const item of items) {
-      output.push(transformSchemaObject(item, options));
+    for (const [index, item] of items.entries()) {
+      output.push(
+        transformSchemaObject(item, {
+          ...options,
+          // include index in path so generated names from nested enums/enumValues are unique
+          path: utils.createRef([options.path, unionKey, String(index)])
+        })
+      );
     }
     return output;
   }
@@ -133,12 +157,13 @@ function transformSchemaObjectWithComposition(schemaObject, options) {
     const allOf = allOfType.length ? ts.tsIntersection(allOfType) : void 0;
     finalType = ts.tsIntersection([...coreObjectType ? [coreObjectType] : [], ...allOf ? [allOf] : []]);
   }
-  const anyOfType = collectUnionCompositions(schemaObject.anyOf ?? []);
+  const anyOfType = collectUnionCompositions(schemaObject.anyOf ?? [], "anyOf");
   if (anyOfType.length) {
     finalType = ts.tsUnion([...finalType ? [finalType] : [], ...anyOfType]);
   }
   const oneOfType = collectUnionCompositions(
-    schemaObject.oneOf || "type" in schemaObject && schemaObject.type === "object" && schemaObject.enum || []
+    schemaObject.oneOf || "type" in schemaObject && schemaObject.type === "object" && schemaObject.enum || [],
+    "oneOf"
   );
   if (oneOfType.length) {
     if (oneOfType.every(ts.tsIsPrimitive)) {
@@ -382,7 +407,7 @@ function transformSchemaObjectCore(schemaObject, options) {
     const hasExplicitPatternProperties = typeof schemaObject.patternProperties === "object" && Object.keys(schemaObject.patternProperties).length;
     const stringIndexTypes = [];
     if (hasExplicitAdditionalProperties) {
-      stringIndexTypes.push(transformSchemaObject(schemaObject.additionalProperties, options));
+      stringIndexTypes.push(transformSchemaObject(schemaObject.additionalProperties, options, true));
     }
     if (hasImplicitAdditionalProperties || !schemaObject.additionalProperties && options.ctx.additionalProperties) {
       stringIndexTypes.push(ts.UNKNOWN);
diff --git a/dist/transform/schema-object.cjs.map b/dist/transform/schema-object.cjs.map
index cbabe4f51233f50aa4d0ff2ca722fc846fbb9dda..140503d0f30d1dac9e4035d1e1bba48dfd726ea6 100644
--- a/dist/transform/schema-object.cjs.map
+++ b/dist/transform/schema-object.cjs.map
@@ -1 +1 @@
-{"version":3,"file":"schema-object.cjs","sources":["../../src/transform/schema-object.ts"],"sourcesContent":["import { parseRef } from \"@redocly/openapi-core/lib/ref-utils.js\";\nimport ts from \"typescript\";\nimport {\n  addJSDocComment,\n  BOOLEAN,\n  NEVER,\n  NULL,\n  NUMBER,\n  oapiRef,\n  QUESTION_TOKEN,\n  STRING,\n  tsArrayLiteralExpression,\n  tsEnum,\n  tsIntersection,\n  tsIsPrimitive,\n  tsLiteral,\n  tsModifiers,\n  tsNullable,\n  tsOmit,\n  tsPropertyIndex,\n  tsRecord,\n  tsUnion,\n  tsWithRequired,\n  UNDEFINED,\n  UNKNOWN,\n} from \"../lib/ts.js\";\nimport { createDiscriminatorProperty, createRef, getEntries } from \"../lib/utils.js\";\nimport type { ReferenceObject, SchemaObject, TransformNodeOptions } from \"../types.js\";\n\n/**\n * Transform SchemaObject nodes (4.8.24)\n * @see https://spec.openapis.org/oas/v3.1.0#schema-object\n */\nexport default function transformSchemaObject(\n  schemaObject: SchemaObject | ReferenceObject,\n  options: TransformNodeOptions,\n): ts.TypeNode {\n  const type = transformSchemaObjectWithComposition(schemaObject, options);\n  if (typeof options.ctx.postTransform === \"function\") {\n    const postTransformResult = options.ctx.postTransform(type, options);\n    if (postTransformResult) {\n      return postTransformResult;\n    }\n  }\n  return type;\n}\n\n/**\n * Transform SchemaObjects\n */\nexport function transformSchemaObjectWithComposition(\n  schemaObject: SchemaObject | ReferenceObject,\n  options: TransformNodeOptions,\n): ts.TypeNode {\n  /**\n   * Unexpected types & edge cases\n   */\n\n  // missing/falsy type returns `never`\n  if (!schemaObject) {\n    return NEVER;\n  }\n  // `true` returns `unknown` (this exists, but is untyped)\n  if ((schemaObject as unknown) === true) {\n    return UNKNOWN;\n  }\n  // for any other unexpected type, throw error\n  if (Array.isArray(schemaObject) || typeof schemaObject !== \"object\") {\n    throw new Error(\n      `Expected SchemaObject, received ${Array.isArray(schemaObject) ? \"Array\" : typeof schemaObject} at ${options.path}`,\n    );\n  }\n\n  /**\n   * ReferenceObject\n   */\n  if (\"$ref\" in schemaObject) {\n    return oapiRef(schemaObject.$ref);\n  }\n\n  /**\n   * const (valid for any type)\n   */\n  if (schemaObject.const !== null && schemaObject.const !== undefined) {\n    return tsLiteral(schemaObject.const);\n  }\n\n  /**\n   * enum (non-objects)\n   * note: enum is valid for any type, but for objects, handle in oneOf below\n   */\n  if (\n    Array.isArray(schemaObject.enum) &&\n    (!(\"type\" in schemaObject) || schemaObject.type !== \"object\") &&\n    !(\"properties\" in schemaObject) &&\n    !(\"additionalProperties\" in schemaObject)\n  ) {\n    // hoist enum to top level if string/number enum and option is enabled\n    if (\n      options.ctx.enum &&\n      schemaObject.enum.every((v) => typeof v === \"string\" || typeof v === \"number\" || v === null)\n    ) {\n      let enumName = parseRef(options.path ?? \"\").pointer.join(\"/\");\n      // allow #/components/schemas to have simpler names\n      enumName = enumName.replace(\"components/schemas\", \"\");\n      const metadata = schemaObject.enum.map((_, i) => ({\n        name: schemaObject[\"x-enum-varnames\"]?.[i] ?? schemaObject[\"x-enumNames\"]?.[i],\n        description: schemaObject[\"x-enum-descriptions\"]?.[i] ?? schemaObject[\"x-enumDescriptions\"]?.[i],\n      }));\n\n      // enums can contain null values, but dont want to output them\n      let hasNull = false;\n      const validSchemaEnums = schemaObject.enum.filter((enumValue) => {\n        if (enumValue === null) {\n          hasNull = true;\n          return false;\n        }\n\n        return true;\n      });\n      const enumType = tsEnum(enumName, validSchemaEnums as (string | number)[], metadata, {\n        shouldCache: options.ctx.dedupeEnums,\n        export: true,\n        // readonly: TS enum do not support the readonly modifier\n      });\n      if (!options.ctx.injectFooter.includes(enumType)) {\n        options.ctx.injectFooter.push(enumType);\n      }\n      const ref = ts.factory.createTypeReferenceNode(enumType.name);\n      return hasNull ? tsUnion([ref, NULL]) : ref;\n    }\n    const enumType = schemaObject.enum.map(tsLiteral);\n    if ((Array.isArray(schemaObject.type) && schemaObject.type.includes(\"null\")) || schemaObject.nullable) {\n      enumType.push(NULL);\n    }\n\n    const unionType = tsUnion(enumType);\n\n    // hoist array with valid enum values to top level if string/number enum and option is enabled\n    if (options.ctx.enumValues && schemaObject.enum.every((v) => typeof v === \"string\" || typeof v === \"number\")) {\n      let enumValuesVariableName = parseRef(options.path ?? \"\").pointer.join(\"/\");\n      // allow #/components/schemas to have simpler names\n      enumValuesVariableName = enumValuesVariableName.replace(\"components/schemas\", \"\");\n      enumValuesVariableName = `${enumValuesVariableName}Values`;\n\n      const enumValuesArray = tsArrayLiteralExpression(\n        enumValuesVariableName,\n        oapiRef(options.path ?? \"\"),\n        schemaObject.enum as (string | number)[],\n        {\n          export: true,\n          readonly: true,\n          injectFooter: options.ctx.injectFooter,\n        },\n      );\n\n      options.ctx.injectFooter.push(enumValuesArray);\n    }\n\n    return unionType;\n  }\n\n  /**\n   * Object + composition (anyOf/allOf/oneOf) types\n   */\n\n  /** Collect oneOf/anyOf */\n  function collectUnionCompositions(items: (SchemaObject | ReferenceObject)[]) {\n    const output: ts.TypeNode[] = [];\n    for (const item of items) {\n      output.push(transformSchemaObject(item, options));\n    }\n\n    return output;\n  }\n\n  /** Collect allOf with Omit<> for discriminators */\n  function collectAllOfCompositions(items: (SchemaObject | ReferenceObject)[], required?: string[]): ts.TypeNode[] {\n    const output: ts.TypeNode[] = [];\n    for (const item of items) {\n      let itemType: ts.TypeNode;\n      // if this is a $ref, use WithRequired<X, Y> if parent specifies required properties\n      // (but only for valid keys)\n      if (\"$ref\" in item) {\n        itemType = transformSchemaObject(item, options);\n\n        const resolved = options.ctx.resolve<SchemaObject>(item.$ref);\n\n        // make keys required, if necessary\n        if (\n          resolved &&\n          typeof resolved === \"object\" &&\n          \"properties\" in resolved &&\n          // we have already handled this item (discriminator property was already added as required)\n          !options.ctx.discriminators.refsHandled.includes(item.$ref)\n        ) {\n          // add WithRequired<X, Y> if necessary\n          const validRequired = (required ?? []).filter((key) => !!resolved.properties?.[key]);\n          if (validRequired.length) {\n            itemType = tsWithRequired(itemType, validRequired, options.ctx.injectFooter);\n          }\n        }\n      }\n      // otherwise, if this is a schema object, combine parent `required[]` with its own, if any\n      else {\n        const itemRequired = [...(required ?? [])];\n        if (typeof item === \"object\" && Array.isArray(item.required)) {\n          itemRequired.push(...item.required);\n        }\n        itemType = transformSchemaObject({ ...item, required: itemRequired }, options);\n      }\n\n      const discriminator =\n        (\"$ref\" in item && options.ctx.discriminators.objects[item.$ref]) || (item as any).discriminator;\n      if (discriminator) {\n        output.push(tsOmit(itemType, [discriminator.propertyName]));\n      } else {\n        output.push(itemType);\n      }\n    }\n    return output;\n  }\n\n  // compile final type\n  let finalType: ts.TypeNode | undefined = undefined;\n\n  // core + allOf: intersect\n  const coreObjectType = transformSchemaObjectCore(schemaObject, options);\n  const allOfType = collectAllOfCompositions(schemaObject.allOf ?? [], schemaObject.required);\n  if (coreObjectType || allOfType.length) {\n    const allOf: ts.TypeNode | undefined = allOfType.length ? tsIntersection(allOfType) : undefined;\n    finalType = tsIntersection([...(coreObjectType ? [coreObjectType] : []), ...(allOf ? [allOf] : [])]);\n  }\n  // anyOf: union\n  // (note: this may seem counterintuitive, but as TypeScript’s unions are not true XORs, they mimic behavior closer to anyOf than oneOf)\n  const anyOfType = collectUnionCompositions(schemaObject.anyOf ?? []);\n  if (anyOfType.length) {\n    finalType = tsUnion([...(finalType ? [finalType] : []), ...anyOfType]);\n  }\n  // oneOf: union (within intersection with other types, if any)\n  const oneOfType = collectUnionCompositions(\n    schemaObject.oneOf ||\n      (\"type\" in schemaObject &&\n        schemaObject.type === \"object\" &&\n        (schemaObject.enum as (SchemaObject | ReferenceObject)[])) ||\n      [],\n  );\n  if (oneOfType.length) {\n    // note: oneOf is the only type that may include primitives\n    if (oneOfType.every(tsIsPrimitive)) {\n      finalType = tsUnion([...(finalType ? [finalType] : []), ...oneOfType]);\n    } else {\n      finalType = tsIntersection([...(finalType ? [finalType] : []), tsUnion(oneOfType)]);\n    }\n  }\n\n  // When no final type can be generated, fall back to unknown type (or related variants)\n  if (!finalType) {\n    if (\"type\" in schemaObject) {\n      finalType = tsRecord(STRING, options.ctx.emptyObjectsUnknown ? UNKNOWN : NEVER);\n    } else {\n      finalType = UNKNOWN;\n    }\n  }\n\n  if (finalType !== UNKNOWN && schemaObject.nullable) {\n    finalType = tsNullable([finalType]);\n  }\n\n  return finalType;\n}\n\n/**\n * Handle SchemaObject minus composition (anyOf/allOf/oneOf)\n */\nfunction transformSchemaObjectCore(schemaObject: SchemaObject, options: TransformNodeOptions): ts.TypeNode | undefined {\n  if (\"type\" in schemaObject && schemaObject.type) {\n    if (typeof options.ctx.transform === \"function\") {\n      const result = options.ctx.transform(schemaObject, options);\n      if (result && typeof result === \"object\") {\n        if (\"schema\" in result) {\n          if (result.questionToken) {\n            return ts.factory.createUnionTypeNode([result.schema, UNDEFINED]);\n          } else {\n            return result.schema;\n          }\n        } else {\n          return result;\n        }\n      }\n    }\n\n    // primitives\n    // type: null\n    if (schemaObject.type === \"null\") {\n      return NULL;\n    }\n    // type: string\n    if (schemaObject.type === \"string\") {\n      return STRING;\n    }\n    // type: number / type: integer\n    if (schemaObject.type === \"number\" || schemaObject.type === \"integer\") {\n      return NUMBER;\n    }\n    // type: boolean\n    if (schemaObject.type === \"boolean\") {\n      return BOOLEAN;\n    }\n\n    // type: array (with support for tuples)\n    if (schemaObject.type === \"array\") {\n      // default to `unknown[]`\n      let itemType: ts.TypeNode = UNKNOWN;\n      // tuple type\n      if (schemaObject.prefixItems || Array.isArray(schemaObject.items)) {\n        const prefixItems = schemaObject.prefixItems ?? (schemaObject.items as (SchemaObject | ReferenceObject)[]);\n        itemType = ts.factory.createTupleTypeNode(prefixItems.map((item) => transformSchemaObject(item, options)));\n      }\n      // standard array type\n      else if (schemaObject.items) {\n        if (hasKey(schemaObject.items, \"type\") && schemaObject.items.type === \"array\") {\n          itemType = ts.factory.createArrayTypeNode(transformSchemaObject(schemaObject.items, options));\n        } else {\n          itemType = transformSchemaObject(schemaObject.items, options);\n        }\n      }\n\n      const min: number =\n        typeof schemaObject.minItems === \"number\" && schemaObject.minItems >= 0 ? schemaObject.minItems : 0;\n      const max: number | undefined =\n        typeof schemaObject.maxItems === \"number\" && schemaObject.maxItems >= 0 && min <= schemaObject.maxItems\n          ? schemaObject.maxItems\n          : undefined;\n      const estimateCodeSize = typeof max !== \"number\" ? min : (max * (max + 1) - min * (min - 1)) / 2;\n      if (\n        options.ctx.arrayLength &&\n        (min !== 0 || max !== undefined) &&\n        estimateCodeSize < 30 // \"30\" is an arbitrary number but roughly around when TS starts to struggle with tuple inference in practice\n      ) {\n        if (min === max) {\n          const elements: ts.TypeNode[] = [];\n          for (let i = 0; i < min; i++) {\n            elements.push(itemType);\n          }\n          return tsUnion([ts.factory.createTupleTypeNode(elements)]);\n        } else if ((schemaObject.maxItems as number) > 0) {\n          // if maxItems is set, then return a union of all permutations of possible tuple types\n          const members: ts.TypeNode[] = [];\n          // populate 1 short of min …\n          for (let i = 0; i <= (max ?? 0) - min; i++) {\n            const elements: ts.TypeNode[] = [];\n            for (let j = min; j < i + min; j++) {\n              elements.push(itemType);\n            }\n            members.push(ts.factory.createTupleTypeNode(elements));\n          }\n          return tsUnion(members);\n        }\n        // if maxItems not set, then return a simple tuple type the length of `min`\n        else {\n          const elements: ts.TypeNode[] = [];\n          for (let i = 0; i < min; i++) {\n            elements.push(itemType);\n          }\n          elements.push(ts.factory.createRestTypeNode(ts.factory.createArrayTypeNode(itemType)));\n          return ts.factory.createTupleTypeNode(elements);\n        }\n      }\n\n      const finalType =\n        ts.isTupleTypeNode(itemType) || ts.isArrayTypeNode(itemType)\n          ? itemType\n          : ts.factory.createArrayTypeNode(itemType); // wrap itemType in array type, but only if not a tuple or array already\n\n      return options.ctx.immutable\n        ? ts.factory.createTypeOperatorNode(ts.SyntaxKind.ReadonlyKeyword, finalType)\n        : finalType;\n    }\n\n    // polymorphic, or 3.1 nullable\n    if (Array.isArray(schemaObject.type) && !Array.isArray(schemaObject)) {\n      // skip any primitive types that appear in oneOf as well\n      const uniqueTypes: ts.TypeNode[] = [];\n      if (Array.isArray(schemaObject.oneOf)) {\n        for (const t of schemaObject.type) {\n          if (\n            (t === \"boolean\" || t === \"string\" || t === \"number\" || t === \"integer\" || t === \"null\") &&\n            schemaObject.oneOf.find((o) => typeof o === \"object\" && \"type\" in o && o.type === t)\n          ) {\n            continue;\n          }\n          uniqueTypes.push(\n            t === \"null\" || t === null\n              ? NULL\n              : transformSchemaObject(\n                  { ...schemaObject, type: t, oneOf: undefined } as SchemaObject, // don’t stack oneOf transforms\n                  options,\n                ),\n          );\n        }\n      } else {\n        for (const t of schemaObject.type) {\n          if (t === \"null\" || t === null) {\n            uniqueTypes.push(NULL);\n          } else {\n            uniqueTypes.push(transformSchemaObject({ ...schemaObject, type: t } as SchemaObject, options));\n          }\n        }\n      }\n      return tsUnion(uniqueTypes);\n    }\n  }\n\n  // type: object\n  const coreObjectType: ts.TypeElement[] = [];\n\n  // discriminators: explicit mapping on schema object\n  for (const k of [\"allOf\", \"anyOf\"] as const) {\n    if (!schemaObject[k]) {\n      continue;\n    }\n    // for all magic inheritance, we will have already gathered it into\n    // ctx.discriminators. But stop objects from referencing their own\n    // discriminator meant for children (!schemaObject.discriminator)\n    // and don't add discriminator properties if we already added/patched\n    // them (options.ctx.discriminators.refsHandled.includes(options.path!).\n    const discriminator =\n      !schemaObject.discriminator &&\n      !options.ctx.discriminators.refsHandled.includes(options.path ?? \"\") &&\n      options.ctx.discriminators.objects[options.path ?? \"\"];\n    if (discriminator) {\n      coreObjectType.unshift(\n        createDiscriminatorProperty(discriminator, {\n          path: options.path ?? \"\",\n          readonly: options.ctx.immutable,\n        }),\n      );\n      break;\n    }\n  }\n\n  if (\n    (\"properties\" in schemaObject && schemaObject.properties && Object.keys(schemaObject.properties).length) ||\n    (\"additionalProperties\" in schemaObject && schemaObject.additionalProperties) ||\n    (\"patternProperties\" in schemaObject && schemaObject.patternProperties) ||\n    (\"$defs\" in schemaObject && schemaObject.$defs)\n  ) {\n    // properties\n    if (Object.keys(schemaObject.properties ?? {}).length) {\n      for (const [k, v] of getEntries(schemaObject.properties ?? {}, options.ctx)) {\n        if ((typeof v !== \"object\" && typeof v !== \"boolean\") || Array.isArray(v)) {\n          throw new Error(\n            `${options.path}: invalid property ${k}. Expected Schema Object or boolean, got ${\n              Array.isArray(v) ? \"Array\" : typeof v\n            }`,\n          );\n        }\n\n        const { $ref, readOnly, hasDefault } =\n          typeof v === \"object\"\n            ? {\n                $ref: \"$ref\" in v && v.$ref,\n                readOnly: \"readOnly\" in v && v.readOnly,\n                hasDefault: \"default\" in v && v.default !== undefined,\n              }\n            : {};\n\n        // handle excludeDeprecated option\n        if (options.ctx.excludeDeprecated) {\n          const resolved = $ref ? options.ctx.resolve<SchemaObject>($ref) : v;\n          if ((resolved as SchemaObject)?.deprecated) {\n            continue;\n          }\n        }\n        let optional =\n          schemaObject.required?.includes(k) ||\n          (schemaObject.required === undefined && options.ctx.propertiesRequiredByDefault) ||\n          (hasDefault &&\n            options.ctx.defaultNonNullable &&\n            !options.path?.includes(\"parameters\") &&\n            !options.path?.includes(\"requestBody\") &&\n            !options.path?.includes(\"requestBodies\")) // can’t be required, even with defaults\n            ? undefined\n            : QUESTION_TOKEN;\n        let type = $ref\n          ? oapiRef($ref)\n          : transformSchemaObject(v, {\n              ...options,\n              path: createRef([options.path, k]),\n            });\n\n        if (typeof options.ctx.transform === \"function\") {\n          const result = options.ctx.transform(v as SchemaObject, options);\n          if (result && typeof result === \"object\") {\n            if (\"schema\" in result) {\n              type = result.schema;\n              optional = result.questionToken ? QUESTION_TOKEN : optional;\n            } else {\n              type = result;\n            }\n          }\n        }\n\n        let property = ts.factory.createPropertySignature(\n          /* modifiers     */ tsModifiers({\n            readonly: options.ctx.immutable || readOnly,\n          }),\n          /* name          */ tsPropertyIndex(k),\n          /* questionToken */ optional,\n          /* type          */ type,\n        );\n\n        // Apply transformProperty hook if available\n        if (typeof options.ctx.transformProperty === \"function\") {\n          const result = options.ctx.transformProperty(property, v as SchemaObject, {\n            ...options,\n            path: createRef([options.path, k]),\n          });\n          if (result) {\n            property = result;\n          }\n        }\n\n        addJSDocComment(v, property);\n        coreObjectType.push(property);\n      }\n    }\n\n    // $defs\n    if (schemaObject.$defs && typeof schemaObject.$defs === \"object\" && Object.keys(schemaObject.$defs).length) {\n      const defKeys: ts.TypeElement[] = [];\n      for (const [k, v] of Object.entries(schemaObject.$defs)) {\n        let property = ts.factory.createPropertySignature(\n          /* modifiers    */ tsModifiers({\n            readonly: options.ctx.immutable || (\"readonly\" in v && !!v.readOnly),\n          }),\n          /* name          */ tsPropertyIndex(k),\n          /* questionToken */ undefined,\n          /* type          */ transformSchemaObject(v, {\n            ...options,\n            path: createRef([options.path, \"$defs\", k]),\n          }),\n        );\n\n        // Apply transformProperty hook if available\n        if (typeof options.ctx.transformProperty === \"function\") {\n          const result = options.ctx.transformProperty(property, v as SchemaObject, {\n            ...options,\n            path: createRef([options.path, \"$defs\", k]),\n          });\n          if (result) {\n            property = result;\n          }\n        }\n\n        addJSDocComment(v, property);\n        defKeys.push(property);\n      }\n      coreObjectType.push(\n        ts.factory.createPropertySignature(\n          /* modifiers     */ undefined,\n          /* name          */ tsPropertyIndex(\"$defs\"),\n          /* questionToken */ undefined,\n          /* type          */ ts.factory.createTypeLiteralNode(defKeys),\n        ),\n      );\n    }\n\n    // additionalProperties / patternProperties\n    const hasExplicitAdditionalProperties =\n      typeof schemaObject.additionalProperties === \"object\" && Object.keys(schemaObject.additionalProperties).length;\n    const hasImplicitAdditionalProperties =\n      schemaObject.additionalProperties === true ||\n      (typeof schemaObject.additionalProperties === \"object\" &&\n        Object.keys(schemaObject.additionalProperties).length === 0);\n    const hasExplicitPatternProperties =\n      typeof schemaObject.patternProperties === \"object\" && Object.keys(schemaObject.patternProperties).length;\n    const stringIndexTypes = [];\n    if (hasExplicitAdditionalProperties) {\n      stringIndexTypes.push(transformSchemaObject(schemaObject.additionalProperties as SchemaObject, options));\n    }\n    if (hasImplicitAdditionalProperties || (!schemaObject.additionalProperties && options.ctx.additionalProperties)) {\n      stringIndexTypes.push(UNKNOWN);\n    }\n    if (hasExplicitPatternProperties) {\n      for (const [_, v] of getEntries(schemaObject.patternProperties ?? {}, options.ctx)) {\n        stringIndexTypes.push(transformSchemaObject(v, options));\n      }\n    }\n\n    if (stringIndexTypes.length === 0) {\n      return coreObjectType.length ? ts.factory.createTypeLiteralNode(coreObjectType) : undefined;\n    }\n\n    const stringIndexType = tsUnion(stringIndexTypes);\n\n    return tsIntersection([\n      ...(coreObjectType.length ? [ts.factory.createTypeLiteralNode(coreObjectType)] : []),\n      ts.factory.createTypeLiteralNode([\n        ts.factory.createIndexSignature(\n          /* modifiers  */ tsModifiers({\n            readonly: options.ctx.immutable,\n          }),\n          /* parameters */ [\n            ts.factory.createParameterDeclaration(\n              /* modifiers      */ undefined,\n              /* dotDotDotToken */ undefined,\n              /* name           */ ts.factory.createIdentifier(\"key\"),\n              /* questionToken  */ undefined,\n              /* type           */ STRING,\n            ),\n          ],\n          /* type       */ stringIndexType,\n        ),\n      ]),\n    ]);\n  }\n\n  return coreObjectType.length ? ts.factory.createTypeLiteralNode(coreObjectType) : undefined;\n}\n\n/**\n * Check if an object has a key\n * @param possibleObject - The object to check\n * @param key - The key to check for\n * @returns True if the object has the key, false otherwise\n */\nfunction hasKey<K extends string>(possibleObject: unknown, key: K): possibleObject is { [key in K]: unknown } {\n  return typeof possibleObject === \"object\" && possibleObject !== null && key in possibleObject;\n}\n"],"names":["NEVER","UNKNOWN","oapiRef","tsLiteral","parseRef","enumType","tsEnum","ts","tsUnion","NULL","tsArrayLiteralExpression","tsWithRequired","tsOmit","tsIntersection","tsIsPrimitive","tsRecord","STRING","tsNullable","UNDEFINED","NUMBER","BOOLEAN","createDiscriminatorProperty","getEntries","QUESTION_TOKEN","createRef","tsModifiers","tsPropertyIndex","addJSDocComment"],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"schema-object.cjs","sources":["../../src/transform/schema-object.ts"],"sourcesContent":["import { parseRef } from \"@redocly/openapi-core/lib/ref-utils.js\";\nimport ts from \"typescript\";\nimport {\n  addJSDocComment,\n  BOOLEAN,\n  NEVER,\n  NULL,\n  NUMBER,\n  oapiRef,\n  QUESTION_TOKEN,\n  STRING,\n  tsArrayLiteralExpression,\n  tsEnum,\n  tsIntersection,\n  tsIsPrimitive,\n  tsLiteral,\n  tsModifiers,\n  tsNullable,\n  tsOmit,\n  tsPropertyIndex,\n  tsRecord,\n  tsUnion,\n  tsWithRequired,\n  UNDEFINED,\n  UNKNOWN,\n} from \"../lib/ts.js\";\nimport { createDiscriminatorProperty, createRef, getEntries } from \"../lib/utils.js\";\nimport type { ReferenceObject, SchemaObject, TransformNodeOptions } from \"../types.js\";\n\n/**\n * Transform SchemaObject nodes (4.8.24)\n * @see https://spec.openapis.org/oas/v3.1.0#schema-object\n */\nexport default function transformSchemaObject(\n  schemaObject: SchemaObject | ReferenceObject,\n  options: TransformNodeOptions,\n  fromAdditionalProperties = false,\n): ts.TypeNode {\n  const type = transformSchemaObjectWithComposition(schemaObject, options, fromAdditionalProperties);\n  if (typeof options.ctx.postTransform === \"function\") {\n    const postTransformResult = options.ctx.postTransform(type, options);\n    if (postTransformResult) {\n      return postTransformResult;\n    }\n  }\n  return type;\n}\n\n/**\n * Transform SchemaObjects\n */\nexport function transformSchemaObjectWithComposition(\n  schemaObject: SchemaObject | ReferenceObject,\n  options: TransformNodeOptions,\n  fromAdditionalProperties = false,\n): ts.TypeNode {\n  /**\n   * Unexpected types & edge cases\n   */\n\n  // missing/falsy type returns `never`\n  if (!schemaObject) {\n    return NEVER;\n  }\n  // `true` returns `unknown` (this exists, but is untyped)\n  if ((schemaObject as unknown) === true) {\n    return UNKNOWN;\n  }\n  // for any other unexpected type, throw error\n  if (Array.isArray(schemaObject) || typeof schemaObject !== \"object\") {\n    throw new Error(\n      `Expected SchemaObject, received ${Array.isArray(schemaObject) ? \"Array\" : typeof schemaObject} at ${options.path}`,\n    );\n  }\n\n  /**\n   * ReferenceObject\n   */\n  if (\"$ref\" in schemaObject) {\n    return oapiRef(schemaObject.$ref);\n  }\n\n  /**\n   * const (valid for any type)\n   */\n  if (schemaObject.const !== null && schemaObject.const !== undefined) {\n    return tsLiteral(schemaObject.const);\n  }\n\n  /**\n   * enum (non-objects)\n   * note: enum is valid for any type, but for objects, handle in oneOf below\n   */\n  if (\n    Array.isArray(schemaObject.enum) &&\n    (!(\"type\" in schemaObject) || schemaObject.type !== \"object\") &&\n    !(\"properties\" in schemaObject) &&\n    !(\"additionalProperties\" in schemaObject)\n  ) {\n    // hoist enum to top level if string/number enum and option is enabled\n    if (\n      options.ctx.enum &&\n      schemaObject.enum.every((v) => typeof v === \"string\" || typeof v === \"number\" || v === null)\n    ) {\n      let enumName = parseRef(options.path ?? \"\").pointer.join(\"/\");\n      // allow #/components/schemas to have simpler names\n      enumName = enumName.replace(\"components/schemas\", \"\");\n      const metadata = schemaObject.enum.map((_, i) => ({\n        name: schemaObject[\"x-enum-varnames\"]?.[i] ?? schemaObject[\"x-enumNames\"]?.[i],\n        description: schemaObject[\"x-enum-descriptions\"]?.[i] ?? schemaObject[\"x-enumDescriptions\"]?.[i],\n      }));\n\n      // enums can contain null values, but dont want to output them\n      let hasNull = false;\n      const validSchemaEnums = schemaObject.enum.filter((enumValue) => {\n        if (enumValue === null) {\n          hasNull = true;\n          return false;\n        }\n\n        return true;\n      });\n      const enumType = tsEnum(enumName, validSchemaEnums as (string | number)[], metadata, {\n        shouldCache: options.ctx.dedupeEnums,\n        export: true,\n        // readonly: TS enum do not support the readonly modifier\n      });\n      if (!options.ctx.injectFooter.includes(enumType)) {\n        options.ctx.injectFooter.push(enumType);\n      }\n      const ref = ts.factory.createTypeReferenceNode(enumType.name);\n      return hasNull ? tsUnion([ref, NULL]) : ref;\n    }\n    const enumType = schemaObject.enum.map(tsLiteral);\n    if ((Array.isArray(schemaObject.type) && schemaObject.type.includes(\"null\")) || schemaObject.nullable) {\n      enumType.push(NULL);\n    }\n\n    const unionType = tsUnion(enumType);\n\n    // hoist array with valid enum values to top level if string/number enum and option is enabled\n    if (options.ctx.enumValues && schemaObject.enum.every((v) => typeof v === \"string\" || typeof v === \"number\")) {\n      const parsed = parseRef(options.path ?? \"\");\n      let enumValuesVariableName = parsed.pointer.join(\"/\");\n      // allow #/components/schemas to have simpler names\n      enumValuesVariableName = enumValuesVariableName.replace(\"components/schemas\", \"\");\n      enumValuesVariableName = `${enumValuesVariableName}Values`;\n\n      // build a ref path for the type that ignores union indices (anyOf/oneOf) so\n      // type references remain stable even when names include union positions\n      const cleanedPointer: string[] = [];\n      for (let i = 0; i < parsed.pointer.length; i++) {\n        // Example: #/paths/analytics/data/get/responses/400/content/application/json/anyOf/0/message\n        const segment = parsed.pointer[i];\n        if ((segment === \"anyOf\" || segment === \"oneOf\") && i < parsed.pointer.length - 1) {\n          const next = parsed.pointer[i + 1];\n          if (/^\\d+$/.test(next)) {\n            // If we encounter something like \"anyOf/0\", we want to skip that part of the path\n            i++;\n            continue;\n          }\n        }\n        cleanedPointer.push(segment);\n      }\n      const cleanedRefPath = createRef(cleanedPointer);\n\n      const enumValuesArray = tsArrayLiteralExpression(\n        enumValuesVariableName,\n        // If fromAdditionalProperties is true we are dealing with a record type and we should append [string] to the generated type\n        fromAdditionalProperties\n          ? ts.factory.createIndexedAccessTypeNode(\n              oapiRef(cleanedRefPath, undefined, true),\n              ts.factory.createTypeReferenceNode(ts.factory.createIdentifier(\"string\")),\n            )\n          : oapiRef(cleanedRefPath, undefined, true),\n        schemaObject.enum as (string | number)[],\n        {\n          export: true,\n          readonly: true,\n          injectFooter: options.ctx.injectFooter,\n        },\n      );\n\n      options.ctx.injectFooter.push(enumValuesArray);\n    }\n\n    return unionType;\n  }\n\n  /**\n   * Object + composition (anyOf/allOf/oneOf) types\n   */\n\n  /** Collect oneOf/anyOf */\n  function collectUnionCompositions(items: (SchemaObject | ReferenceObject)[], unionKey: \"anyOf\" | \"oneOf\") {\n    const output: ts.TypeNode[] = [];\n    for (const [index, item] of items.entries()) {\n      output.push(\n        transformSchemaObject(item, {\n          ...options,\n          // include index in path so generated names from nested enums/enumValues are unique\n          path: createRef([options.path, unionKey, String(index)]),\n        }),\n      );\n    }\n\n    return output;\n  }\n\n  /** Collect allOf with Omit<> for discriminators */\n  function collectAllOfCompositions(items: (SchemaObject | ReferenceObject)[], required?: string[]): ts.TypeNode[] {\n    const output: ts.TypeNode[] = [];\n    for (const item of items) {\n      let itemType: ts.TypeNode;\n      // if this is a $ref, use WithRequired<X, Y> if parent specifies required properties\n      // (but only for valid keys)\n      if (\"$ref\" in item) {\n        itemType = transformSchemaObject(item, options);\n\n        const resolved = options.ctx.resolve<SchemaObject>(item.$ref);\n\n        // make keys required, if necessary\n        if (\n          resolved &&\n          typeof resolved === \"object\" &&\n          \"properties\" in resolved &&\n          // we have already handled this item (discriminator property was already added as required)\n          !options.ctx.discriminators.refsHandled.includes(item.$ref)\n        ) {\n          // add WithRequired<X, Y> if necessary\n          const validRequired = (required ?? []).filter((key) => !!resolved.properties?.[key]);\n          if (validRequired.length) {\n            itemType = tsWithRequired(itemType, validRequired, options.ctx.injectFooter);\n          }\n        }\n      }\n      // otherwise, if this is a schema object, combine parent `required[]` with its own, if any\n      else {\n        const itemRequired = [...(required ?? [])];\n        if (typeof item === \"object\" && Array.isArray(item.required)) {\n          itemRequired.push(...item.required);\n        }\n        itemType = transformSchemaObject({ ...item, required: itemRequired }, options);\n      }\n\n      const discriminator =\n        (\"$ref\" in item && options.ctx.discriminators.objects[item.$ref]) || (item as any).discriminator;\n      if (discriminator) {\n        output.push(tsOmit(itemType, [discriminator.propertyName]));\n      } else {\n        output.push(itemType);\n      }\n    }\n    return output;\n  }\n\n  // compile final type\n  let finalType: ts.TypeNode | undefined = undefined;\n\n  // core + allOf: intersect\n  const coreObjectType = transformSchemaObjectCore(schemaObject, options);\n  const allOfType = collectAllOfCompositions(schemaObject.allOf ?? [], schemaObject.required);\n  if (coreObjectType || allOfType.length) {\n    const allOf: ts.TypeNode | undefined = allOfType.length ? tsIntersection(allOfType) : undefined;\n    finalType = tsIntersection([...(coreObjectType ? [coreObjectType] : []), ...(allOf ? [allOf] : [])]);\n  }\n  // anyOf: union\n  // (note: this may seem counterintuitive, but as TypeScript’s unions are not true XORs, they mimic behavior closer to anyOf than oneOf)\n  const anyOfType = collectUnionCompositions(schemaObject.anyOf ?? [], \"anyOf\");\n  if (anyOfType.length) {\n    finalType = tsUnion([...(finalType ? [finalType] : []), ...anyOfType]);\n  }\n  // oneOf: union (within intersection with other types, if any)\n  const oneOfType = collectUnionCompositions(\n    schemaObject.oneOf ||\n      (\"type\" in schemaObject &&\n        schemaObject.type === \"object\" &&\n        (schemaObject.enum as (SchemaObject | ReferenceObject)[])) ||\n      [],\n    \"oneOf\",\n  );\n  if (oneOfType.length) {\n    // note: oneOf is the only type that may include primitives\n    if (oneOfType.every(tsIsPrimitive)) {\n      finalType = tsUnion([...(finalType ? [finalType] : []), ...oneOfType]);\n    } else {\n      finalType = tsIntersection([...(finalType ? [finalType] : []), tsUnion(oneOfType)]);\n    }\n  }\n\n  // When no final type can be generated, fall back to unknown type (or related variants)\n  if (!finalType) {\n    if (\"type\" in schemaObject) {\n      finalType = tsRecord(STRING, options.ctx.emptyObjectsUnknown ? UNKNOWN : NEVER);\n    } else {\n      finalType = UNKNOWN;\n    }\n  }\n\n  if (finalType !== UNKNOWN && schemaObject.nullable) {\n    finalType = tsNullable([finalType]);\n  }\n\n  return finalType;\n}\n\n/**\n * Handle SchemaObject minus composition (anyOf/allOf/oneOf)\n */\nfunction transformSchemaObjectCore(schemaObject: SchemaObject, options: TransformNodeOptions): ts.TypeNode | undefined {\n  if (\"type\" in schemaObject && schemaObject.type) {\n    if (typeof options.ctx.transform === \"function\") {\n      const result = options.ctx.transform(schemaObject, options);\n      if (result && typeof result === \"object\") {\n        if (\"schema\" in result) {\n          if (result.questionToken) {\n            return ts.factory.createUnionTypeNode([result.schema, UNDEFINED]);\n          } else {\n            return result.schema;\n          }\n        } else {\n          return result;\n        }\n      }\n    }\n\n    // primitives\n    // type: null\n    if (schemaObject.type === \"null\") {\n      return NULL;\n    }\n    // type: string\n    if (schemaObject.type === \"string\") {\n      return STRING;\n    }\n    // type: number / type: integer\n    if (schemaObject.type === \"number\" || schemaObject.type === \"integer\") {\n      return NUMBER;\n    }\n    // type: boolean\n    if (schemaObject.type === \"boolean\") {\n      return BOOLEAN;\n    }\n\n    // type: array (with support for tuples)\n    if (schemaObject.type === \"array\") {\n      // default to `unknown[]`\n      let itemType: ts.TypeNode = UNKNOWN;\n      // tuple type\n      if (schemaObject.prefixItems || Array.isArray(schemaObject.items)) {\n        const prefixItems = schemaObject.prefixItems ?? (schemaObject.items as (SchemaObject | ReferenceObject)[]);\n        itemType = ts.factory.createTupleTypeNode(prefixItems.map((item) => transformSchemaObject(item, options)));\n      }\n      // standard array type\n      else if (schemaObject.items) {\n        if (hasKey(schemaObject.items, \"type\") && schemaObject.items.type === \"array\") {\n          itemType = ts.factory.createArrayTypeNode(transformSchemaObject(schemaObject.items, options));\n        } else {\n          itemType = transformSchemaObject(schemaObject.items, options);\n        }\n      }\n\n      const min: number =\n        typeof schemaObject.minItems === \"number\" && schemaObject.minItems >= 0 ? schemaObject.minItems : 0;\n      const max: number | undefined =\n        typeof schemaObject.maxItems === \"number\" && schemaObject.maxItems >= 0 && min <= schemaObject.maxItems\n          ? schemaObject.maxItems\n          : undefined;\n      const estimateCodeSize = typeof max !== \"number\" ? min : (max * (max + 1) - min * (min - 1)) / 2;\n      if (\n        options.ctx.arrayLength &&\n        (min !== 0 || max !== undefined) &&\n        estimateCodeSize < 30 // \"30\" is an arbitrary number but roughly around when TS starts to struggle with tuple inference in practice\n      ) {\n        if (min === max) {\n          const elements: ts.TypeNode[] = [];\n          for (let i = 0; i < min; i++) {\n            elements.push(itemType);\n          }\n          return tsUnion([ts.factory.createTupleTypeNode(elements)]);\n        } else if ((schemaObject.maxItems as number) > 0) {\n          // if maxItems is set, then return a union of all permutations of possible tuple types\n          const members: ts.TypeNode[] = [];\n          // populate 1 short of min …\n          for (let i = 0; i <= (max ?? 0) - min; i++) {\n            const elements: ts.TypeNode[] = [];\n            for (let j = min; j < i + min; j++) {\n              elements.push(itemType);\n            }\n            members.push(ts.factory.createTupleTypeNode(elements));\n          }\n          return tsUnion(members);\n        }\n        // if maxItems not set, then return a simple tuple type the length of `min`\n        else {\n          const elements: ts.TypeNode[] = [];\n          for (let i = 0; i < min; i++) {\n            elements.push(itemType);\n          }\n          elements.push(ts.factory.createRestTypeNode(ts.factory.createArrayTypeNode(itemType)));\n          return ts.factory.createTupleTypeNode(elements);\n        }\n      }\n\n      const finalType =\n        ts.isTupleTypeNode(itemType) || ts.isArrayTypeNode(itemType)\n          ? itemType\n          : ts.factory.createArrayTypeNode(itemType); // wrap itemType in array type, but only if not a tuple or array already\n\n      return options.ctx.immutable\n        ? ts.factory.createTypeOperatorNode(ts.SyntaxKind.ReadonlyKeyword, finalType)\n        : finalType;\n    }\n\n    // polymorphic, or 3.1 nullable\n    if (Array.isArray(schemaObject.type) && !Array.isArray(schemaObject)) {\n      // skip any primitive types that appear in oneOf as well\n      const uniqueTypes: ts.TypeNode[] = [];\n      if (Array.isArray(schemaObject.oneOf)) {\n        for (const t of schemaObject.type) {\n          if (\n            (t === \"boolean\" || t === \"string\" || t === \"number\" || t === \"integer\" || t === \"null\") &&\n            schemaObject.oneOf.find((o) => typeof o === \"object\" && \"type\" in o && o.type === t)\n          ) {\n            continue;\n          }\n          uniqueTypes.push(\n            t === \"null\" || t === null\n              ? NULL\n              : transformSchemaObject(\n                  { ...schemaObject, type: t, oneOf: undefined } as SchemaObject, // don’t stack oneOf transforms\n                  options,\n                ),\n          );\n        }\n      } else {\n        for (const t of schemaObject.type) {\n          if (t === \"null\" || t === null) {\n            uniqueTypes.push(NULL);\n          } else {\n            uniqueTypes.push(transformSchemaObject({ ...schemaObject, type: t } as SchemaObject, options));\n          }\n        }\n      }\n      return tsUnion(uniqueTypes);\n    }\n  }\n\n  // type: object\n  const coreObjectType: ts.TypeElement[] = [];\n\n  // discriminators: explicit mapping on schema object\n  for (const k of [\"allOf\", \"anyOf\"] as const) {\n    if (!schemaObject[k]) {\n      continue;\n    }\n    // for all magic inheritance, we will have already gathered it into\n    // ctx.discriminators. But stop objects from referencing their own\n    // discriminator meant for children (!schemaObject.discriminator)\n    // and don't add discriminator properties if we already added/patched\n    // them (options.ctx.discriminators.refsHandled.includes(options.path!).\n    const discriminator =\n      !schemaObject.discriminator &&\n      !options.ctx.discriminators.refsHandled.includes(options.path ?? \"\") &&\n      options.ctx.discriminators.objects[options.path ?? \"\"];\n    if (discriminator) {\n      coreObjectType.unshift(\n        createDiscriminatorProperty(discriminator, {\n          path: options.path ?? \"\",\n          readonly: options.ctx.immutable,\n        }),\n      );\n      break;\n    }\n  }\n\n  if (\n    (\"properties\" in schemaObject && schemaObject.properties && Object.keys(schemaObject.properties).length) ||\n    (\"additionalProperties\" in schemaObject && schemaObject.additionalProperties) ||\n    (\"patternProperties\" in schemaObject && schemaObject.patternProperties) ||\n    (\"$defs\" in schemaObject && schemaObject.$defs)\n  ) {\n    // properties\n    if (Object.keys(schemaObject.properties ?? {}).length) {\n      for (const [k, v] of getEntries(schemaObject.properties ?? {}, options.ctx)) {\n        if ((typeof v !== \"object\" && typeof v !== \"boolean\") || Array.isArray(v)) {\n          throw new Error(\n            `${options.path}: invalid property ${k}. Expected Schema Object or boolean, got ${\n              Array.isArray(v) ? \"Array\" : typeof v\n            }`,\n          );\n        }\n\n        const { $ref, readOnly, hasDefault } =\n          typeof v === \"object\"\n            ? {\n                $ref: \"$ref\" in v && v.$ref,\n                readOnly: \"readOnly\" in v && v.readOnly,\n                hasDefault: \"default\" in v && v.default !== undefined,\n              }\n            : {};\n\n        // handle excludeDeprecated option\n        if (options.ctx.excludeDeprecated) {\n          const resolved = $ref ? options.ctx.resolve<SchemaObject>($ref) : v;\n          if ((resolved as SchemaObject)?.deprecated) {\n            continue;\n          }\n        }\n        let optional =\n          schemaObject.required?.includes(k) ||\n          (schemaObject.required === undefined && options.ctx.propertiesRequiredByDefault) ||\n          (hasDefault &&\n            options.ctx.defaultNonNullable &&\n            !options.path?.includes(\"parameters\") &&\n            !options.path?.includes(\"requestBody\") &&\n            !options.path?.includes(\"requestBodies\")) // can’t be required, even with defaults\n            ? undefined\n            : QUESTION_TOKEN;\n        let type = $ref\n          ? oapiRef($ref)\n          : transformSchemaObject(v, {\n              ...options,\n              path: createRef([options.path, k]),\n            });\n\n        if (typeof options.ctx.transform === \"function\") {\n          const result = options.ctx.transform(v as SchemaObject, options);\n          if (result && typeof result === \"object\") {\n            if (\"schema\" in result) {\n              type = result.schema;\n              optional = result.questionToken ? QUESTION_TOKEN : optional;\n            } else {\n              type = result;\n            }\n          }\n        }\n\n        let property = ts.factory.createPropertySignature(\n          /* modifiers     */ tsModifiers({\n            readonly: options.ctx.immutable || readOnly,\n          }),\n          /* name          */ tsPropertyIndex(k),\n          /* questionToken */ optional,\n          /* type          */ type,\n        );\n\n        // Apply transformProperty hook if available\n        if (typeof options.ctx.transformProperty === \"function\") {\n          const result = options.ctx.transformProperty(property, v as SchemaObject, {\n            ...options,\n            path: createRef([options.path, k]),\n          });\n          if (result) {\n            property = result;\n          }\n        }\n\n        addJSDocComment(v, property);\n        coreObjectType.push(property);\n      }\n    }\n\n    // $defs\n    if (schemaObject.$defs && typeof schemaObject.$defs === \"object\" && Object.keys(schemaObject.$defs).length) {\n      const defKeys: ts.TypeElement[] = [];\n      for (const [k, v] of Object.entries(schemaObject.$defs)) {\n        let property = ts.factory.createPropertySignature(\n          /* modifiers    */ tsModifiers({\n            readonly: options.ctx.immutable || (\"readonly\" in v && !!v.readOnly),\n          }),\n          /* name          */ tsPropertyIndex(k),\n          /* questionToken */ undefined,\n          /* type          */ transformSchemaObject(v, {\n            ...options,\n            path: createRef([options.path, \"$defs\", k]),\n          }),\n        );\n\n        // Apply transformProperty hook if available\n        if (typeof options.ctx.transformProperty === \"function\") {\n          const result = options.ctx.transformProperty(property, v as SchemaObject, {\n            ...options,\n            path: createRef([options.path, \"$defs\", k]),\n          });\n          if (result) {\n            property = result;\n          }\n        }\n\n        addJSDocComment(v, property);\n        defKeys.push(property);\n      }\n      coreObjectType.push(\n        ts.factory.createPropertySignature(\n          /* modifiers     */ undefined,\n          /* name          */ tsPropertyIndex(\"$defs\"),\n          /* questionToken */ undefined,\n          /* type          */ ts.factory.createTypeLiteralNode(defKeys),\n        ),\n      );\n    }\n\n    // additionalProperties / patternProperties\n    const hasExplicitAdditionalProperties =\n      typeof schemaObject.additionalProperties === \"object\" && Object.keys(schemaObject.additionalProperties).length;\n    const hasImplicitAdditionalProperties =\n      schemaObject.additionalProperties === true ||\n      (typeof schemaObject.additionalProperties === \"object\" &&\n        Object.keys(schemaObject.additionalProperties).length === 0);\n    const hasExplicitPatternProperties =\n      typeof schemaObject.patternProperties === \"object\" && Object.keys(schemaObject.patternProperties).length;\n    const stringIndexTypes = [];\n    if (hasExplicitAdditionalProperties) {\n      stringIndexTypes.push(transformSchemaObject(schemaObject.additionalProperties as SchemaObject, options, true));\n    }\n    if (hasImplicitAdditionalProperties || (!schemaObject.additionalProperties && options.ctx.additionalProperties)) {\n      stringIndexTypes.push(UNKNOWN);\n    }\n    if (hasExplicitPatternProperties) {\n      for (const [_, v] of getEntries(schemaObject.patternProperties ?? {}, options.ctx)) {\n        stringIndexTypes.push(transformSchemaObject(v, options));\n      }\n    }\n\n    if (stringIndexTypes.length === 0) {\n      return coreObjectType.length ? ts.factory.createTypeLiteralNode(coreObjectType) : undefined;\n    }\n\n    const stringIndexType = tsUnion(stringIndexTypes);\n\n    return tsIntersection([\n      ...(coreObjectType.length ? [ts.factory.createTypeLiteralNode(coreObjectType)] : []),\n      ts.factory.createTypeLiteralNode([\n        ts.factory.createIndexSignature(\n          /* modifiers  */ tsModifiers({\n            readonly: options.ctx.immutable,\n          }),\n          /* parameters */ [\n            ts.factory.createParameterDeclaration(\n              /* modifiers      */ undefined,\n              /* dotDotDotToken */ undefined,\n              /* name           */ ts.factory.createIdentifier(\"key\"),\n              /* questionToken  */ undefined,\n              /* type           */ STRING,\n            ),\n          ],\n          /* type       */ stringIndexType,\n        ),\n      ]),\n    ]);\n  }\n\n  return coreObjectType.length ? ts.factory.createTypeLiteralNode(coreObjectType) : undefined;\n}\n\n/**\n * Check if an object has a key\n * @param possibleObject - The object to check\n * @param key - The key to check for\n * @returns True if the object has the key, false otherwise\n */\nfunction hasKey<K extends string>(possibleObject: unknown, key: K): possibleObject is { [key in K]: unknown } {\n  return typeof possibleObject === \"object\" && possibleObject !== null && key in possibleObject;\n}\n"],"names":["NEVER","UNKNOWN","oapiRef","tsLiteral","parseRef","enumType","tsEnum","ts","tsUnion","NULL","createRef","tsArrayLiteralExpression","tsWithRequired","tsOmit","tsIntersection","tsIsPrimitive","tsRecord","STRING","tsNullable","UNDEFINED","NUMBER","BOOLEAN","createDiscriminatorProperty","getEntries","QUESTION_TOKEN","tsModifiers","tsPropertyIndex","addJSDocComment"],"mappings":"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"}
\ No newline at end of file
diff --git a/dist/transform/schema-object.mjs b/dist/transform/schema-object.mjs
index f13ebbad3bee4844d1fb5e9c1563e6fb7a21610d..9d15bb63fbbf93d8f43bcaae2f7a9c698c63682e 100644
--- a/dist/transform/schema-object.mjs
+++ b/dist/transform/schema-object.mjs
@@ -1,10 +1,10 @@
 import { parseRef } from '@redocly/openapi-core/lib/ref-utils.js';
 import ts from 'typescript';
 import { NEVER, UNKNOWN, oapiRef, tsLiteral, tsEnum, tsUnion, NULL, tsArrayLiteralExpression, tsIntersection, tsIsPrimitive, tsRecord, STRING, tsNullable, UNDEFINED, NUMBER, BOOLEAN, QUESTION_TOKEN, tsModifiers, tsPropertyIndex, addJSDocComment, tsWithRequired, tsOmit } from '../lib/ts.mjs';
-import { createDiscriminatorProperty, getEntries, createRef } from '../lib/utils.mjs';
+import { createRef, createDiscriminatorProperty, getEntries } from '../lib/utils.mjs';
 
-function transformSchemaObject(schemaObject, options) {
-  const type = transformSchemaObjectWithComposition(schemaObject, options);
+function transformSchemaObject(schemaObject, options, fromAdditionalProperties = false) {
+  const type = transformSchemaObjectWithComposition(schemaObject, options, fromAdditionalProperties);
   if (typeof options.ctx.postTransform === "function") {
     const postTransformResult = options.ctx.postTransform(type, options);
     if (postTransformResult) {
@@ -13,7 +13,7 @@ function transformSchemaObject(schemaObject, options) {
   }
   return type;
 }
-function transformSchemaObjectWithComposition(schemaObject, options) {
+function transformSchemaObjectWithComposition(schemaObject, options, fromAdditionalProperties = false) {
   if (!schemaObject) {
     return NEVER;
   }
@@ -64,12 +64,30 @@ function transformSchemaObjectWithComposition(schemaObject, options) {
     }
     const unionType = tsUnion(enumType);
     if (options.ctx.enumValues && schemaObject.enum.every((v) => typeof v === "string" || typeof v === "number")) {
-      let enumValuesVariableName = parseRef(options.path ?? "").pointer.join("/");
+      const parsed = parseRef(options.path ?? "");
+      let enumValuesVariableName = parsed.pointer.join("/");
       enumValuesVariableName = enumValuesVariableName.replace("components/schemas", "");
       enumValuesVariableName = `${enumValuesVariableName}Values`;
+      const cleanedPointer = [];
+      for (let i = 0; i < parsed.pointer.length; i++) {
+        const segment = parsed.pointer[i];
+        if ((segment === "anyOf" || segment === "oneOf") && i < parsed.pointer.length - 1) {
+          const next = parsed.pointer[i + 1];
+          if (/^\d+$/.test(next)) {
+            i++;
+            continue;
+          }
+        }
+        cleanedPointer.push(segment);
+      }
+      const cleanedRefPath = createRef(cleanedPointer);
       const enumValuesArray = tsArrayLiteralExpression(
         enumValuesVariableName,
-        oapiRef(options.path ?? ""),
+        // If fromAdditionalProperties is true we are dealing with a record type and we should append [string] to the generated type
+        fromAdditionalProperties ? ts.factory.createIndexedAccessTypeNode(
+          oapiRef(cleanedRefPath, void 0, true),
+          ts.factory.createTypeReferenceNode(ts.factory.createIdentifier("string"))
+        ) : oapiRef(cleanedRefPath, void 0, true),
         schemaObject.enum,
         {
           export: true,
@@ -81,10 +99,16 @@ function transformSchemaObjectWithComposition(schemaObject, options) {
     }
     return unionType;
   }
-  function collectUnionCompositions(items) {
+  function collectUnionCompositions(items, unionKey) {
     const output = [];
-    for (const item of items) {
-      output.push(transformSchemaObject(item, options));
+    for (const [index, item] of items.entries()) {
+      output.push(
+        transformSchemaObject(item, {
+          ...options,
+          // include index in path so generated names from nested enums/enumValues are unique
+          path: createRef([options.path, unionKey, String(index)])
+        })
+      );
     }
     return output;
   }
@@ -125,12 +149,13 @@ function transformSchemaObjectWithComposition(schemaObject, options) {
     const allOf = allOfType.length ? tsIntersection(allOfType) : void 0;
     finalType = tsIntersection([...coreObjectType ? [coreObjectType] : [], ...allOf ? [allOf] : []]);
   }
-  const anyOfType = collectUnionCompositions(schemaObject.anyOf ?? []);
+  const anyOfType = collectUnionCompositions(schemaObject.anyOf ?? [], "anyOf");
   if (anyOfType.length) {
     finalType = tsUnion([...finalType ? [finalType] : [], ...anyOfType]);
   }
   const oneOfType = collectUnionCompositions(
-    schemaObject.oneOf || "type" in schemaObject && schemaObject.type === "object" && schemaObject.enum || []
+    schemaObject.oneOf || "type" in schemaObject && schemaObject.type === "object" && schemaObject.enum || [],
+    "oneOf"
   );
   if (oneOfType.length) {
     if (oneOfType.every(tsIsPrimitive)) {
@@ -374,7 +399,7 @@ function transformSchemaObjectCore(schemaObject, options) {
     const hasExplicitPatternProperties = typeof schemaObject.patternProperties === "object" && Object.keys(schemaObject.patternProperties).length;
     const stringIndexTypes = [];
     if (hasExplicitAdditionalProperties) {
-      stringIndexTypes.push(transformSchemaObject(schemaObject.additionalProperties, options));
+      stringIndexTypes.push(transformSchemaObject(schemaObject.additionalProperties, options, true));
     }
     if (hasImplicitAdditionalProperties || !schemaObject.additionalProperties && options.ctx.additionalProperties) {
       stringIndexTypes.push(UNKNOWN);
diff --git a/dist/transform/schema-object.mjs.map b/dist/transform/schema-object.mjs.map
index 3d87a1c0c7eccce598985d3815eeb89919b7398d..a68d20e12081b0afe9a51b05f09eed094bcb3465 100644
--- a/dist/transform/schema-object.mjs.map
+++ b/dist/transform/schema-object.mjs.map
@@ -1 +1 @@
-{"version":3,"file":"schema-object.mjs","sources":["../../src/transform/schema-object.ts"],"sourcesContent":["import { parseRef } from \"@redocly/openapi-core/lib/ref-utils.js\";\nimport ts from \"typescript\";\nimport {\n  addJSDocComment,\n  BOOLEAN,\n  NEVER,\n  NULL,\n  NUMBER,\n  oapiRef,\n  QUESTION_TOKEN,\n  STRING,\n  tsArrayLiteralExpression,\n  tsEnum,\n  tsIntersection,\n  tsIsPrimitive,\n  tsLiteral,\n  tsModifiers,\n  tsNullable,\n  tsOmit,\n  tsPropertyIndex,\n  tsRecord,\n  tsUnion,\n  tsWithRequired,\n  UNDEFINED,\n  UNKNOWN,\n} from \"../lib/ts.js\";\nimport { createDiscriminatorProperty, createRef, getEntries } from \"../lib/utils.js\";\nimport type { ReferenceObject, SchemaObject, TransformNodeOptions } from \"../types.js\";\n\n/**\n * Transform SchemaObject nodes (4.8.24)\n * @see https://spec.openapis.org/oas/v3.1.0#schema-object\n */\nexport default function transformSchemaObject(\n  schemaObject: SchemaObject | ReferenceObject,\n  options: TransformNodeOptions,\n): ts.TypeNode {\n  const type = transformSchemaObjectWithComposition(schemaObject, options);\n  if (typeof options.ctx.postTransform === \"function\") {\n    const postTransformResult = options.ctx.postTransform(type, options);\n    if (postTransformResult) {\n      return postTransformResult;\n    }\n  }\n  return type;\n}\n\n/**\n * Transform SchemaObjects\n */\nexport function transformSchemaObjectWithComposition(\n  schemaObject: SchemaObject | ReferenceObject,\n  options: TransformNodeOptions,\n): ts.TypeNode {\n  /**\n   * Unexpected types & edge cases\n   */\n\n  // missing/falsy type returns `never`\n  if (!schemaObject) {\n    return NEVER;\n  }\n  // `true` returns `unknown` (this exists, but is untyped)\n  if ((schemaObject as unknown) === true) {\n    return UNKNOWN;\n  }\n  // for any other unexpected type, throw error\n  if (Array.isArray(schemaObject) || typeof schemaObject !== \"object\") {\n    throw new Error(\n      `Expected SchemaObject, received ${Array.isArray(schemaObject) ? \"Array\" : typeof schemaObject} at ${options.path}`,\n    );\n  }\n\n  /**\n   * ReferenceObject\n   */\n  if (\"$ref\" in schemaObject) {\n    return oapiRef(schemaObject.$ref);\n  }\n\n  /**\n   * const (valid for any type)\n   */\n  if (schemaObject.const !== null && schemaObject.const !== undefined) {\n    return tsLiteral(schemaObject.const);\n  }\n\n  /**\n   * enum (non-objects)\n   * note: enum is valid for any type, but for objects, handle in oneOf below\n   */\n  if (\n    Array.isArray(schemaObject.enum) &&\n    (!(\"type\" in schemaObject) || schemaObject.type !== \"object\") &&\n    !(\"properties\" in schemaObject) &&\n    !(\"additionalProperties\" in schemaObject)\n  ) {\n    // hoist enum to top level if string/number enum and option is enabled\n    if (\n      options.ctx.enum &&\n      schemaObject.enum.every((v) => typeof v === \"string\" || typeof v === \"number\" || v === null)\n    ) {\n      let enumName = parseRef(options.path ?? \"\").pointer.join(\"/\");\n      // allow #/components/schemas to have simpler names\n      enumName = enumName.replace(\"components/schemas\", \"\");\n      const metadata = schemaObject.enum.map((_, i) => ({\n        name: schemaObject[\"x-enum-varnames\"]?.[i] ?? schemaObject[\"x-enumNames\"]?.[i],\n        description: schemaObject[\"x-enum-descriptions\"]?.[i] ?? schemaObject[\"x-enumDescriptions\"]?.[i],\n      }));\n\n      // enums can contain null values, but dont want to output them\n      let hasNull = false;\n      const validSchemaEnums = schemaObject.enum.filter((enumValue) => {\n        if (enumValue === null) {\n          hasNull = true;\n          return false;\n        }\n\n        return true;\n      });\n      const enumType = tsEnum(enumName, validSchemaEnums as (string | number)[], metadata, {\n        shouldCache: options.ctx.dedupeEnums,\n        export: true,\n        // readonly: TS enum do not support the readonly modifier\n      });\n      if (!options.ctx.injectFooter.includes(enumType)) {\n        options.ctx.injectFooter.push(enumType);\n      }\n      const ref = ts.factory.createTypeReferenceNode(enumType.name);\n      return hasNull ? tsUnion([ref, NULL]) : ref;\n    }\n    const enumType = schemaObject.enum.map(tsLiteral);\n    if ((Array.isArray(schemaObject.type) && schemaObject.type.includes(\"null\")) || schemaObject.nullable) {\n      enumType.push(NULL);\n    }\n\n    const unionType = tsUnion(enumType);\n\n    // hoist array with valid enum values to top level if string/number enum and option is enabled\n    if (options.ctx.enumValues && schemaObject.enum.every((v) => typeof v === \"string\" || typeof v === \"number\")) {\n      let enumValuesVariableName = parseRef(options.path ?? \"\").pointer.join(\"/\");\n      // allow #/components/schemas to have simpler names\n      enumValuesVariableName = enumValuesVariableName.replace(\"components/schemas\", \"\");\n      enumValuesVariableName = `${enumValuesVariableName}Values`;\n\n      const enumValuesArray = tsArrayLiteralExpression(\n        enumValuesVariableName,\n        oapiRef(options.path ?? \"\"),\n        schemaObject.enum as (string | number)[],\n        {\n          export: true,\n          readonly: true,\n          injectFooter: options.ctx.injectFooter,\n        },\n      );\n\n      options.ctx.injectFooter.push(enumValuesArray);\n    }\n\n    return unionType;\n  }\n\n  /**\n   * Object + composition (anyOf/allOf/oneOf) types\n   */\n\n  /** Collect oneOf/anyOf */\n  function collectUnionCompositions(items: (SchemaObject | ReferenceObject)[]) {\n    const output: ts.TypeNode[] = [];\n    for (const item of items) {\n      output.push(transformSchemaObject(item, options));\n    }\n\n    return output;\n  }\n\n  /** Collect allOf with Omit<> for discriminators */\n  function collectAllOfCompositions(items: (SchemaObject | ReferenceObject)[], required?: string[]): ts.TypeNode[] {\n    const output: ts.TypeNode[] = [];\n    for (const item of items) {\n      let itemType: ts.TypeNode;\n      // if this is a $ref, use WithRequired<X, Y> if parent specifies required properties\n      // (but only for valid keys)\n      if (\"$ref\" in item) {\n        itemType = transformSchemaObject(item, options);\n\n        const resolved = options.ctx.resolve<SchemaObject>(item.$ref);\n\n        // make keys required, if necessary\n        if (\n          resolved &&\n          typeof resolved === \"object\" &&\n          \"properties\" in resolved &&\n          // we have already handled this item (discriminator property was already added as required)\n          !options.ctx.discriminators.refsHandled.includes(item.$ref)\n        ) {\n          // add WithRequired<X, Y> if necessary\n          const validRequired = (required ?? []).filter((key) => !!resolved.properties?.[key]);\n          if (validRequired.length) {\n            itemType = tsWithRequired(itemType, validRequired, options.ctx.injectFooter);\n          }\n        }\n      }\n      // otherwise, if this is a schema object, combine parent `required[]` with its own, if any\n      else {\n        const itemRequired = [...(required ?? [])];\n        if (typeof item === \"object\" && Array.isArray(item.required)) {\n          itemRequired.push(...item.required);\n        }\n        itemType = transformSchemaObject({ ...item, required: itemRequired }, options);\n      }\n\n      const discriminator =\n        (\"$ref\" in item && options.ctx.discriminators.objects[item.$ref]) || (item as any).discriminator;\n      if (discriminator) {\n        output.push(tsOmit(itemType, [discriminator.propertyName]));\n      } else {\n        output.push(itemType);\n      }\n    }\n    return output;\n  }\n\n  // compile final type\n  let finalType: ts.TypeNode | undefined = undefined;\n\n  // core + allOf: intersect\n  const coreObjectType = transformSchemaObjectCore(schemaObject, options);\n  const allOfType = collectAllOfCompositions(schemaObject.allOf ?? [], schemaObject.required);\n  if (coreObjectType || allOfType.length) {\n    const allOf: ts.TypeNode | undefined = allOfType.length ? tsIntersection(allOfType) : undefined;\n    finalType = tsIntersection([...(coreObjectType ? [coreObjectType] : []), ...(allOf ? [allOf] : [])]);\n  }\n  // anyOf: union\n  // (note: this may seem counterintuitive, but as TypeScript’s unions are not true XORs, they mimic behavior closer to anyOf than oneOf)\n  const anyOfType = collectUnionCompositions(schemaObject.anyOf ?? []);\n  if (anyOfType.length) {\n    finalType = tsUnion([...(finalType ? [finalType] : []), ...anyOfType]);\n  }\n  // oneOf: union (within intersection with other types, if any)\n  const oneOfType = collectUnionCompositions(\n    schemaObject.oneOf ||\n      (\"type\" in schemaObject &&\n        schemaObject.type === \"object\" &&\n        (schemaObject.enum as (SchemaObject | ReferenceObject)[])) ||\n      [],\n  );\n  if (oneOfType.length) {\n    // note: oneOf is the only type that may include primitives\n    if (oneOfType.every(tsIsPrimitive)) {\n      finalType = tsUnion([...(finalType ? [finalType] : []), ...oneOfType]);\n    } else {\n      finalType = tsIntersection([...(finalType ? [finalType] : []), tsUnion(oneOfType)]);\n    }\n  }\n\n  // When no final type can be generated, fall back to unknown type (or related variants)\n  if (!finalType) {\n    if (\"type\" in schemaObject) {\n      finalType = tsRecord(STRING, options.ctx.emptyObjectsUnknown ? UNKNOWN : NEVER);\n    } else {\n      finalType = UNKNOWN;\n    }\n  }\n\n  if (finalType !== UNKNOWN && schemaObject.nullable) {\n    finalType = tsNullable([finalType]);\n  }\n\n  return finalType;\n}\n\n/**\n * Handle SchemaObject minus composition (anyOf/allOf/oneOf)\n */\nfunction transformSchemaObjectCore(schemaObject: SchemaObject, options: TransformNodeOptions): ts.TypeNode | undefined {\n  if (\"type\" in schemaObject && schemaObject.type) {\n    if (typeof options.ctx.transform === \"function\") {\n      const result = options.ctx.transform(schemaObject, options);\n      if (result && typeof result === \"object\") {\n        if (\"schema\" in result) {\n          if (result.questionToken) {\n            return ts.factory.createUnionTypeNode([result.schema, UNDEFINED]);\n          } else {\n            return result.schema;\n          }\n        } else {\n          return result;\n        }\n      }\n    }\n\n    // primitives\n    // type: null\n    if (schemaObject.type === \"null\") {\n      return NULL;\n    }\n    // type: string\n    if (schemaObject.type === \"string\") {\n      return STRING;\n    }\n    // type: number / type: integer\n    if (schemaObject.type === \"number\" || schemaObject.type === \"integer\") {\n      return NUMBER;\n    }\n    // type: boolean\n    if (schemaObject.type === \"boolean\") {\n      return BOOLEAN;\n    }\n\n    // type: array (with support for tuples)\n    if (schemaObject.type === \"array\") {\n      // default to `unknown[]`\n      let itemType: ts.TypeNode = UNKNOWN;\n      // tuple type\n      if (schemaObject.prefixItems || Array.isArray(schemaObject.items)) {\n        const prefixItems = schemaObject.prefixItems ?? (schemaObject.items as (SchemaObject | ReferenceObject)[]);\n        itemType = ts.factory.createTupleTypeNode(prefixItems.map((item) => transformSchemaObject(item, options)));\n      }\n      // standard array type\n      else if (schemaObject.items) {\n        if (hasKey(schemaObject.items, \"type\") && schemaObject.items.type === \"array\") {\n          itemType = ts.factory.createArrayTypeNode(transformSchemaObject(schemaObject.items, options));\n        } else {\n          itemType = transformSchemaObject(schemaObject.items, options);\n        }\n      }\n\n      const min: number =\n        typeof schemaObject.minItems === \"number\" && schemaObject.minItems >= 0 ? schemaObject.minItems : 0;\n      const max: number | undefined =\n        typeof schemaObject.maxItems === \"number\" && schemaObject.maxItems >= 0 && min <= schemaObject.maxItems\n          ? schemaObject.maxItems\n          : undefined;\n      const estimateCodeSize = typeof max !== \"number\" ? min : (max * (max + 1) - min * (min - 1)) / 2;\n      if (\n        options.ctx.arrayLength &&\n        (min !== 0 || max !== undefined) &&\n        estimateCodeSize < 30 // \"30\" is an arbitrary number but roughly around when TS starts to struggle with tuple inference in practice\n      ) {\n        if (min === max) {\n          const elements: ts.TypeNode[] = [];\n          for (let i = 0; i < min; i++) {\n            elements.push(itemType);\n          }\n          return tsUnion([ts.factory.createTupleTypeNode(elements)]);\n        } else if ((schemaObject.maxItems as number) > 0) {\n          // if maxItems is set, then return a union of all permutations of possible tuple types\n          const members: ts.TypeNode[] = [];\n          // populate 1 short of min …\n          for (let i = 0; i <= (max ?? 0) - min; i++) {\n            const elements: ts.TypeNode[] = [];\n            for (let j = min; j < i + min; j++) {\n              elements.push(itemType);\n            }\n            members.push(ts.factory.createTupleTypeNode(elements));\n          }\n          return tsUnion(members);\n        }\n        // if maxItems not set, then return a simple tuple type the length of `min`\n        else {\n          const elements: ts.TypeNode[] = [];\n          for (let i = 0; i < min; i++) {\n            elements.push(itemType);\n          }\n          elements.push(ts.factory.createRestTypeNode(ts.factory.createArrayTypeNode(itemType)));\n          return ts.factory.createTupleTypeNode(elements);\n        }\n      }\n\n      const finalType =\n        ts.isTupleTypeNode(itemType) || ts.isArrayTypeNode(itemType)\n          ? itemType\n          : ts.factory.createArrayTypeNode(itemType); // wrap itemType in array type, but only if not a tuple or array already\n\n      return options.ctx.immutable\n        ? ts.factory.createTypeOperatorNode(ts.SyntaxKind.ReadonlyKeyword, finalType)\n        : finalType;\n    }\n\n    // polymorphic, or 3.1 nullable\n    if (Array.isArray(schemaObject.type) && !Array.isArray(schemaObject)) {\n      // skip any primitive types that appear in oneOf as well\n      const uniqueTypes: ts.TypeNode[] = [];\n      if (Array.isArray(schemaObject.oneOf)) {\n        for (const t of schemaObject.type) {\n          if (\n            (t === \"boolean\" || t === \"string\" || t === \"number\" || t === \"integer\" || t === \"null\") &&\n            schemaObject.oneOf.find((o) => typeof o === \"object\" && \"type\" in o && o.type === t)\n          ) {\n            continue;\n          }\n          uniqueTypes.push(\n            t === \"null\" || t === null\n              ? NULL\n              : transformSchemaObject(\n                  { ...schemaObject, type: t, oneOf: undefined } as SchemaObject, // don’t stack oneOf transforms\n                  options,\n                ),\n          );\n        }\n      } else {\n        for (const t of schemaObject.type) {\n          if (t === \"null\" || t === null) {\n            uniqueTypes.push(NULL);\n          } else {\n            uniqueTypes.push(transformSchemaObject({ ...schemaObject, type: t } as SchemaObject, options));\n          }\n        }\n      }\n      return tsUnion(uniqueTypes);\n    }\n  }\n\n  // type: object\n  const coreObjectType: ts.TypeElement[] = [];\n\n  // discriminators: explicit mapping on schema object\n  for (const k of [\"allOf\", \"anyOf\"] as const) {\n    if (!schemaObject[k]) {\n      continue;\n    }\n    // for all magic inheritance, we will have already gathered it into\n    // ctx.discriminators. But stop objects from referencing their own\n    // discriminator meant for children (!schemaObject.discriminator)\n    // and don't add discriminator properties if we already added/patched\n    // them (options.ctx.discriminators.refsHandled.includes(options.path!).\n    const discriminator =\n      !schemaObject.discriminator &&\n      !options.ctx.discriminators.refsHandled.includes(options.path ?? \"\") &&\n      options.ctx.discriminators.objects[options.path ?? \"\"];\n    if (discriminator) {\n      coreObjectType.unshift(\n        createDiscriminatorProperty(discriminator, {\n          path: options.path ?? \"\",\n          readonly: options.ctx.immutable,\n        }),\n      );\n      break;\n    }\n  }\n\n  if (\n    (\"properties\" in schemaObject && schemaObject.properties && Object.keys(schemaObject.properties).length) ||\n    (\"additionalProperties\" in schemaObject && schemaObject.additionalProperties) ||\n    (\"patternProperties\" in schemaObject && schemaObject.patternProperties) ||\n    (\"$defs\" in schemaObject && schemaObject.$defs)\n  ) {\n    // properties\n    if (Object.keys(schemaObject.properties ?? {}).length) {\n      for (const [k, v] of getEntries(schemaObject.properties ?? {}, options.ctx)) {\n        if ((typeof v !== \"object\" && typeof v !== \"boolean\") || Array.isArray(v)) {\n          throw new Error(\n            `${options.path}: invalid property ${k}. Expected Schema Object or boolean, got ${\n              Array.isArray(v) ? \"Array\" : typeof v\n            }`,\n          );\n        }\n\n        const { $ref, readOnly, hasDefault } =\n          typeof v === \"object\"\n            ? {\n                $ref: \"$ref\" in v && v.$ref,\n                readOnly: \"readOnly\" in v && v.readOnly,\n                hasDefault: \"default\" in v && v.default !== undefined,\n              }\n            : {};\n\n        // handle excludeDeprecated option\n        if (options.ctx.excludeDeprecated) {\n          const resolved = $ref ? options.ctx.resolve<SchemaObject>($ref) : v;\n          if ((resolved as SchemaObject)?.deprecated) {\n            continue;\n          }\n        }\n        let optional =\n          schemaObject.required?.includes(k) ||\n          (schemaObject.required === undefined && options.ctx.propertiesRequiredByDefault) ||\n          (hasDefault &&\n            options.ctx.defaultNonNullable &&\n            !options.path?.includes(\"parameters\") &&\n            !options.path?.includes(\"requestBody\") &&\n            !options.path?.includes(\"requestBodies\")) // can’t be required, even with defaults\n            ? undefined\n            : QUESTION_TOKEN;\n        let type = $ref\n          ? oapiRef($ref)\n          : transformSchemaObject(v, {\n              ...options,\n              path: createRef([options.path, k]),\n            });\n\n        if (typeof options.ctx.transform === \"function\") {\n          const result = options.ctx.transform(v as SchemaObject, options);\n          if (result && typeof result === \"object\") {\n            if (\"schema\" in result) {\n              type = result.schema;\n              optional = result.questionToken ? QUESTION_TOKEN : optional;\n            } else {\n              type = result;\n            }\n          }\n        }\n\n        let property = ts.factory.createPropertySignature(\n          /* modifiers     */ tsModifiers({\n            readonly: options.ctx.immutable || readOnly,\n          }),\n          /* name          */ tsPropertyIndex(k),\n          /* questionToken */ optional,\n          /* type          */ type,\n        );\n\n        // Apply transformProperty hook if available\n        if (typeof options.ctx.transformProperty === \"function\") {\n          const result = options.ctx.transformProperty(property, v as SchemaObject, {\n            ...options,\n            path: createRef([options.path, k]),\n          });\n          if (result) {\n            property = result;\n          }\n        }\n\n        addJSDocComment(v, property);\n        coreObjectType.push(property);\n      }\n    }\n\n    // $defs\n    if (schemaObject.$defs && typeof schemaObject.$defs === \"object\" && Object.keys(schemaObject.$defs).length) {\n      const defKeys: ts.TypeElement[] = [];\n      for (const [k, v] of Object.entries(schemaObject.$defs)) {\n        let property = ts.factory.createPropertySignature(\n          /* modifiers    */ tsModifiers({\n            readonly: options.ctx.immutable || (\"readonly\" in v && !!v.readOnly),\n          }),\n          /* name          */ tsPropertyIndex(k),\n          /* questionToken */ undefined,\n          /* type          */ transformSchemaObject(v, {\n            ...options,\n            path: createRef([options.path, \"$defs\", k]),\n          }),\n        );\n\n        // Apply transformProperty hook if available\n        if (typeof options.ctx.transformProperty === \"function\") {\n          const result = options.ctx.transformProperty(property, v as SchemaObject, {\n            ...options,\n            path: createRef([options.path, \"$defs\", k]),\n          });\n          if (result) {\n            property = result;\n          }\n        }\n\n        addJSDocComment(v, property);\n        defKeys.push(property);\n      }\n      coreObjectType.push(\n        ts.factory.createPropertySignature(\n          /* modifiers     */ undefined,\n          /* name          */ tsPropertyIndex(\"$defs\"),\n          /* questionToken */ undefined,\n          /* type          */ ts.factory.createTypeLiteralNode(defKeys),\n        ),\n      );\n    }\n\n    // additionalProperties / patternProperties\n    const hasExplicitAdditionalProperties =\n      typeof schemaObject.additionalProperties === \"object\" && Object.keys(schemaObject.additionalProperties).length;\n    const hasImplicitAdditionalProperties =\n      schemaObject.additionalProperties === true ||\n      (typeof schemaObject.additionalProperties === \"object\" &&\n        Object.keys(schemaObject.additionalProperties).length === 0);\n    const hasExplicitPatternProperties =\n      typeof schemaObject.patternProperties === \"object\" && Object.keys(schemaObject.patternProperties).length;\n    const stringIndexTypes = [];\n    if (hasExplicitAdditionalProperties) {\n      stringIndexTypes.push(transformSchemaObject(schemaObject.additionalProperties as SchemaObject, options));\n    }\n    if (hasImplicitAdditionalProperties || (!schemaObject.additionalProperties && options.ctx.additionalProperties)) {\n      stringIndexTypes.push(UNKNOWN);\n    }\n    if (hasExplicitPatternProperties) {\n      for (const [_, v] of getEntries(schemaObject.patternProperties ?? {}, options.ctx)) {\n        stringIndexTypes.push(transformSchemaObject(v, options));\n      }\n    }\n\n    if (stringIndexTypes.length === 0) {\n      return coreObjectType.length ? ts.factory.createTypeLiteralNode(coreObjectType) : undefined;\n    }\n\n    const stringIndexType = tsUnion(stringIndexTypes);\n\n    return tsIntersection([\n      ...(coreObjectType.length ? [ts.factory.createTypeLiteralNode(coreObjectType)] : []),\n      ts.factory.createTypeLiteralNode([\n        ts.factory.createIndexSignature(\n          /* modifiers  */ tsModifiers({\n            readonly: options.ctx.immutable,\n          }),\n          /* parameters */ [\n            ts.factory.createParameterDeclaration(\n              /* modifiers      */ undefined,\n              /* dotDotDotToken */ undefined,\n              /* name           */ ts.factory.createIdentifier(\"key\"),\n              /* questionToken  */ undefined,\n              /* type           */ STRING,\n            ),\n          ],\n          /* type       */ stringIndexType,\n        ),\n      ]),\n    ]);\n  }\n\n  return coreObjectType.length ? ts.factory.createTypeLiteralNode(coreObjectType) : undefined;\n}\n\n/**\n * Check if an object has a key\n * @param possibleObject - The object to check\n * @param key - The key to check for\n * @returns True if the object has the key, false otherwise\n */\nfunction hasKey<K extends string>(possibleObject: unknown, key: K): possibleObject is { [key in K]: unknown } {\n  return typeof possibleObject === \"object\" && possibleObject !== null && key in possibleObject;\n}\n"],"names":["enumType"],"mappings":";;;;;AAiCA,SAAwB,qBAAA,CACtB,cACA,OAAA,EACa;AACb,EAAA,MAAM,IAAA,GAAO,oCAAA,CAAqC,YAAA,EAAc,OAAO,CAAA;AACvE,EAAA,IAAI,OAAO,OAAA,CAAQ,GAAA,CAAI,aAAA,KAAkB,UAAA,EAAY;AACnD,IAAA,MAAM,mBAAA,GAAsB,OAAA,CAAQ,GAAA,CAAI,aAAA,CAAc,MAAM,OAAO,CAAA;AACnE,IAAA,IAAI,mBAAA,EAAqB;AACvB,MAAA,OAAO,mBAAA;AAAA,IACT;AAAA,EACF;AACA,EAAA,OAAO,IAAA;AACT;AAKO,SAAS,oCAAA,CACd,cACA,OAAA,EACa;AAMb,EAAA,IAAI,CAAC,YAAA,EAAc;AACjB,IAAA,OAAO,KAAA;AAAA,EACT;AAEA,EAAA,IAAK,iBAA6B,IAAA,EAAM;AACtC,IAAA,OAAO,OAAA;AAAA,EACT;AAEA,EAAA,IAAI,MAAM,OAAA,CAAQ,YAAY,CAAA,IAAK,OAAO,iBAAiB,QAAA,EAAU;AACnE,IAAA,MAAM,IAAI,KAAA;AAAA,MACR,CAAA,gCAAA,EAAmC,KAAA,CAAM,OAAA,CAAQ,YAAY,CAAA,GAAI,UAAU,OAAO,YAAY,CAAA,IAAA,EAAO,OAAA,CAAQ,IAAI,CAAA;AAAA,KACnH;AAAA,EACF;AAKA,EAAA,IAAI,UAAU,YAAA,EAAc;AAC1B,IAAA,OAAO,OAAA,CAAQ,aAAa,IAAI,CAAA;AAAA,EAClC;AAKA,EAAA,IAAI,YAAA,CAAa,KAAA,KAAU,IAAA,IAAQ,YAAA,CAAa,UAAU,MAAA,EAAW;AACnE,IAAA,OAAO,SAAA,CAAU,aAAa,KAAK,CAAA;AAAA,EACrC;AAMA,EAAA,IACE,MAAM,OAAA,CAAQ,YAAA,CAAa,IAAI,CAAA,KAC9B,EAAE,MAAA,IAAU,YAAA,CAAA,IAAiB,YAAA,CAAa,IAAA,KAAS,aACpD,EAAE,YAAA,IAAgB,YAAA,CAAA,IAClB,EAAE,0BAA0B,YAAA,CAAA,EAC5B;AAEA,IAAA,IACE,QAAQ,GAAA,CAAI,IAAA,IACZ,YAAA,CAAa,IAAA,CAAK,MAAM,CAAC,CAAA,KAAM,OAAO,CAAA,KAAM,YAAY,OAAO,CAAA,KAAM,QAAA,IAAY,CAAA,KAAM,IAAI,CAAA,EAC3F;AACA,MAAA,IAAI,QAAA,GAAW,SAAS,OAAA,CAAQ,IAAA,IAAQ,EAAE,CAAA,CAAE,OAAA,CAAQ,KAAK,GAAG,CAAA;AAE5D,MAAA,QAAA,GAAW,QAAA,CAAS,OAAA,CAAQ,oBAAA,EAAsB,EAAE,CAAA;AACpD,MAAA,MAAM,WAAW,YAAA,CAAa,IAAA,CAAK,GAAA,CAAI,CAAC,GAAG,CAAA,MAAO;AAAA,QAChD,IAAA,EAAM,aAAa,iBAAiB,CAAA,GAAI,CAAC,CAAA,IAAK,YAAA,CAAa,aAAa,CAAA,GAAI,CAAC,CAAA;AAAA,QAC7E,WAAA,EAAa,aAAa,qBAAqB,CAAA,GAAI,CAAC,CAAA,IAAK,YAAA,CAAa,oBAAoB,CAAA,GAAI,CAAC;AAAA,OACjG,CAAE,CAAA;AAGF,MAAA,IAAI,OAAA,GAAU,KAAA;AACd,MAAA,MAAM,gBAAA,GAAmB,YAAA,CAAa,IAAA,CAAK,MAAA,CAAO,CAAC,SAAA,KAAc;AAC/D,QAAA,IAAI,cAAc,IAAA,EAAM;AACtB,UAAA,OAAA,GAAU,IAAA;AACV,UAAA,OAAO,KAAA;AAAA,QACT;AAEA,QAAA,OAAO,IAAA;AAAA,MACT,CAAC,CAAA;AACD,MAAA,MAAMA,SAAAA,GAAW,MAAA,CAAO,QAAA,EAAU,gBAAA,EAAyC,QAAA,EAAU;AAAA,QACnF,WAAA,EAAa,QAAQ,GAAA,CAAI,WAAA;AAAA,QACzB,MAAA,EAAQ;AAAA;AAAA,OAET,CAAA;AACD,MAAA,IAAI,CAAC,OAAA,CAAQ,GAAA,CAAI,YAAA,CAAa,QAAA,CAASA,SAAQ,CAAA,EAAG;AAChD,QAAA,OAAA,CAAQ,GAAA,CAAI,YAAA,CAAa,IAAA,CAAKA,SAAQ,CAAA;AAAA,MACxC;AACA,MAAA,MAAM,GAAA,GAAM,EAAA,CAAG,OAAA,CAAQ,uBAAA,CAAwBA,UAAS,IAAI,CAAA;AAC5D,MAAA,OAAO,UAAU,OAAA,CAAQ,CAAC,GAAA,EAAK,IAAI,CAAC,CAAA,GAAI,GAAA;AAAA,IAC1C;AACA,IAAA,MAAM,QAAA,GAAW,YAAA,CAAa,IAAA,CAAK,GAAA,CAAI,SAAS,CAAA;AAChD,IAAA,IAAK,KAAA,CAAM,OAAA,CAAQ,YAAA,CAAa,IAAI,CAAA,IAAK,YAAA,CAAa,IAAA,CAAK,QAAA,CAAS,MAAM,CAAA,IAAM,YAAA,CAAa,QAAA,EAAU;AACrG,MAAA,QAAA,CAAS,KAAK,IAAI,CAAA;AAAA,IACpB;AAEA,IAAA,MAAM,SAAA,GAAY,QAAQ,QAAQ,CAAA;AAGlC,IAAA,IAAI,OAAA,CAAQ,GAAA,CAAI,UAAA,IAAc,YAAA,CAAa,KAAK,KAAA,CAAM,CAAC,CAAA,KAAM,OAAO,CAAA,KAAM,QAAA,IAAY,OAAO,CAAA,KAAM,QAAQ,CAAA,EAAG;AAC5G,MAAA,IAAI,sBAAA,GAAyB,SAAS,OAAA,CAAQ,IAAA,IAAQ,EAAE,CAAA,CAAE,OAAA,CAAQ,KAAK,GAAG,CAAA;AAE1E,MAAA,sBAAA,GAAyB,sBAAA,CAAuB,OAAA,CAAQ,oBAAA,EAAsB,EAAE,CAAA;AAChF,MAAA,sBAAA,GAAyB,GAAG,sBAAsB,CAAA,MAAA,CAAA;AAElD,MAAA,MAAM,eAAA,GAAkB,wBAAA;AAAA,QACtB,sBAAA;AAAA,QACA,OAAA,CAAQ,OAAA,CAAQ,IAAA,IAAQ,EAAE,CAAA;AAAA,QAC1B,YAAA,CAAa,IAAA;AAAA,QACb;AAAA,UACE,MAAA,EAAQ,IAAA;AAAA,UACR,QAAA,EAAU,IAAA;AAAA,UACV,YAAA,EAAc,QAAQ,GAAA,CAAI;AAAA;AAC5B,OACF;AAEA,MAAA,OAAA,CAAQ,GAAA,CAAI,YAAA,CAAa,IAAA,CAAK,eAAe,CAAA;AAAA,IAC/C;AAEA,IAAA,OAAO,SAAA;AAAA,EACT;AAOA,EAAA,SAAS,yBAAyB,KAAA,EAA2C;AAC3E,IAAA,MAAM,SAAwB,EAAC;AAC/B,IAAA,KAAA,MAAW,QAAQ,KAAA,EAAO;AACxB,MAAA,MAAA,CAAO,IAAA,CAAK,qBAAA,CAAsB,IAAA,EAAM,OAAO,CAAC,CAAA;AAAA,IAClD;AAEA,IAAA,OAAO,MAAA;AAAA,EACT;AAGA,EAAA,SAAS,wBAAA,CAAyB,OAA2C,QAAA,EAAoC;AAC/G,IAAA,MAAM,SAAwB,EAAC;AAC/B,IAAA,KAAA,MAAW,QAAQ,KAAA,EAAO;AACxB,MAAA,IAAI,QAAA;AAGJ,MAAA,IAAI,UAAU,IAAA,EAAM;AAClB,QAAA,QAAA,GAAW,qBAAA,CAAsB,MAAM,OAAO,CAAA;AAE9C,QAAA,MAAM,QAAA,GAAW,OAAA,CAAQ,GAAA,CAAI,OAAA,CAAsB,KAAK,IAAI,CAAA;AAG5D,QAAA,IACE,QAAA,IACA,OAAO,QAAA,KAAa,QAAA,IACpB,YAAA,IAAgB,QAAA;AAAA,QAEhB,CAAC,QAAQ,GAAA,CAAI,cAAA,CAAe,YAAY,QAAA,CAAS,IAAA,CAAK,IAAI,CAAA,EAC1D;AAEA,UAAA,MAAM,aAAA,GAAA,CAAiB,QAAA,IAAY,EAAC,EAAG,MAAA,CAAO,CAAC,GAAA,KAAQ,CAAC,CAAC,QAAA,CAAS,UAAA,GAAa,GAAG,CAAC,CAAA;AACnF,UAAA,IAAI,cAAc,MAAA,EAAQ;AACxB,YAAA,QAAA,GAAW,cAAA,CAAe,QAAA,EAAU,aAAA,EAAe,OAAA,CAAQ,IAAI,YAAY,CAAA;AAAA,UAC7E;AAAA,QACF;AAAA,MACF,CAAA,MAEK;AACH,QAAA,MAAM,YAAA,GAAe,CAAC,GAAI,QAAA,IAAY,EAAG,CAAA;AACzC,QAAA,IAAI,OAAO,IAAA,KAAS,QAAA,IAAY,MAAM,OAAA,CAAQ,IAAA,CAAK,QAAQ,CAAA,EAAG;AAC5D,UAAA,YAAA,CAAa,IAAA,CAAK,GAAG,IAAA,CAAK,QAAQ,CAAA;AAAA,QACpC;AACA,QAAA,QAAA,GAAW,sBAAsB,EAAE,GAAG,MAAM,QAAA,EAAU,YAAA,IAAgB,OAAO,CAAA;AAAA,MAC/E;AAEA,MAAA,MAAM,aAAA,GACH,MAAA,IAAU,IAAA,IAAQ,OAAA,CAAQ,GAAA,CAAI,eAAe,OAAA,CAAQ,IAAA,CAAK,IAAI,CAAA,IAAO,IAAA,CAAa,aAAA;AACrF,MAAA,IAAI,aAAA,EAAe;AACjB,QAAA,MAAA,CAAO,KAAK,MAAA,CAAO,QAAA,EAAU,CAAC,aAAA,CAAc,YAAY,CAAC,CAAC,CAAA;AAAA,MAC5D,CAAA,MAAO;AACL,QAAA,MAAA,CAAO,KAAK,QAAQ,CAAA;AAAA,MACtB;AAAA,IACF;AACA,IAAA,OAAO,MAAA;AAAA,EACT;AAGA,EAAA,IAAI,SAAA,GAAqC,MAAA;AAGzC,EAAA,MAAM,cAAA,GAAiB,yBAAA,CAA0B,YAAA,EAAc,OAAO,CAAA;AACtE,EAAA,MAAM,YAAY,wBAAA,CAAyB,YAAA,CAAa,SAAS,EAAC,EAAG,aAAa,QAAQ,CAAA;AAC1F,EAAA,IAAI,cAAA,IAAkB,UAAU,MAAA,EAAQ;AACtC,IAAA,MAAM,KAAA,GAAiC,SAAA,CAAU,MAAA,GAAS,cAAA,CAAe,SAAS,CAAA,GAAI,MAAA;AACtF,IAAA,SAAA,GAAY,eAAe,CAAC,GAAI,cAAA,GAAiB,CAAC,cAAc,CAAA,GAAI,EAAC,EAAI,GAAI,QAAQ,CAAC,KAAK,CAAA,GAAI,EAAG,CAAC,CAAA;AAAA,EACrG;AAGA,EAAA,MAAM,SAAA,GAAY,wBAAA,CAAyB,YAAA,CAAa,KAAA,IAAS,EAAE,CAAA;AACnE,EAAA,IAAI,UAAU,MAAA,EAAQ;AACpB,IAAA,SAAA,GAAY,OAAA,CAAQ,CAAC,GAAI,SAAA,GAAY,CAAC,SAAS,CAAA,GAAI,EAAC,EAAI,GAAG,SAAS,CAAC,CAAA;AAAA,EACvE;AAEA,EAAA,MAAM,SAAA,GAAY,wBAAA;AAAA,IAChB,YAAA,CAAa,SACV,MAAA,IAAU,YAAA,IACT,aAAa,IAAA,KAAS,QAAA,IACrB,YAAA,CAAa,IAAA,IAChB;AAAC,GACL;AACA,EAAA,IAAI,UAAU,MAAA,EAAQ;AAEpB,IAAA,IAAI,SAAA,CAAU,KAAA,CAAM,aAAa,CAAA,EAAG;AAClC,MAAA,SAAA,GAAY,OAAA,CAAQ,CAAC,GAAI,SAAA,GAAY,CAAC,SAAS,CAAA,GAAI,EAAC,EAAI,GAAG,SAAS,CAAC,CAAA;AAAA,IACvE,CAAA,MAAO;AACL,MAAA,SAAA,GAAY,cAAA,CAAe,CAAC,GAAI,SAAA,GAAY,CAAC,SAAS,CAAA,GAAI,EAAC,EAAI,OAAA,CAAQ,SAAS,CAAC,CAAC,CAAA;AAAA,IACpF;AAAA,EACF;AAGA,EAAA,IAAI,CAAC,SAAA,EAAW;AACd,IAAA,IAAI,UAAU,YAAA,EAAc;AAC1B,MAAA,SAAA,GAAY,SAAS,MAAA,EAAQ,OAAA,CAAQ,GAAA,CAAI,mBAAA,GAAsB,UAAU,KAAK,CAAA;AAAA,IAChF,CAAA,MAAO;AACL,MAAA,SAAA,GAAY,OAAA;AAAA,IACd;AAAA,EACF;AAEA,EAAA,IAAI,SAAA,KAAc,OAAA,IAAW,YAAA,CAAa,QAAA,EAAU;AAClD,IAAA,SAAA,GAAY,UAAA,CAAW,CAAC,SAAS,CAAC,CAAA;AAAA,EACpC;AAEA,EAAA,OAAO,SAAA;AACT;AAKA,SAAS,yBAAA,CAA0B,cAA4B,OAAA,EAAwD;AACrH,EAAA,IAAI,MAAA,IAAU,YAAA,IAAgB,YAAA,CAAa,IAAA,EAAM;AAC/C,IAAA,IAAI,OAAO,OAAA,CAAQ,GAAA,CAAI,SAAA,KAAc,UAAA,EAAY;AAC/C,MAAA,MAAM,MAAA,GAAS,OAAA,CAAQ,GAAA,CAAI,SAAA,CAAU,cAAc,OAAO,CAAA;AAC1D,MAAA,IAAI,MAAA,IAAU,OAAO,MAAA,KAAW,QAAA,EAAU;AACxC,QAAA,IAAI,YAAY,MAAA,EAAQ;AACtB,UAAA,IAAI,OAAO,aAAA,EAAe;AACxB,YAAA,OAAO,GAAG,OAAA,CAAQ,mBAAA,CAAoB,CAAC,MAAA,CAAO,MAAA,EAAQ,SAAS,CAAC,CAAA;AAAA,UAClE,CAAA,MAAO;AACL,YAAA,OAAO,MAAA,CAAO,MAAA;AAAA,UAChB;AAAA,QACF,CAAA,MAAO;AACL,UAAA,OAAO,MAAA;AAAA,QACT;AAAA,MACF;AAAA,IACF;AAIA,IAAA,IAAI,YAAA,CAAa,SAAS,MAAA,EAAQ;AAChC,MAAA,OAAO,IAAA;AAAA,IACT;AAEA,IAAA,IAAI,YAAA,CAAa,SAAS,QAAA,EAAU;AAClC,MAAA,OAAO,MAAA;AAAA,IACT;AAEA,IAAA,IAAI,YAAA,CAAa,IAAA,KAAS,QAAA,IAAY,YAAA,CAAa,SAAS,SAAA,EAAW;AACrE,MAAA,OAAO,MAAA;AAAA,IACT;AAEA,IAAA,IAAI,YAAA,CAAa,SAAS,SAAA,EAAW;AACnC,MAAA,OAAO,OAAA;AAAA,IACT;AAGA,IAAA,IAAI,YAAA,CAAa,SAAS,OAAA,EAAS;AAEjC,MAAA,IAAI,QAAA,GAAwB,OAAA;AAE5B,MAAA,IAAI,aAAa,WAAA,IAAe,KAAA,CAAM,OAAA,CAAQ,YAAA,CAAa,KAAK,CAAA,EAAG;AACjE,QAAA,MAAM,WAAA,GAAc,YAAA,CAAa,WAAA,IAAgB,YAAA,CAAa,KAAA;AAC9D,QAAA,QAAA,GAAW,EAAA,CAAG,OAAA,CAAQ,mBAAA,CAAoB,WAAA,CAAY,GAAA,CAAI,CAAC,IAAA,KAAS,qBAAA,CAAsB,IAAA,EAAM,OAAO,CAAC,CAAC,CAAA;AAAA,MAC3G,CAAA,MAAA,IAES,aAAa,KAAA,EAAO;AAC3B,QAAA,IAAI,MAAA,CAAO,aAAa,KAAA,EAAO,MAAM,KAAK,YAAA,CAAa,KAAA,CAAM,SAAS,OAAA,EAAS;AAC7E,UAAA,QAAA,GAAW,GAAG,OAAA,CAAQ,mBAAA,CAAoB,sBAAsB,YAAA,CAAa,KAAA,EAAO,OAAO,CAAC,CAAA;AAAA,QAC9F,CAAA,MAAO;AACL,UAAA,QAAA,GAAW,qBAAA,CAAsB,YAAA,CAAa,KAAA,EAAO,OAAO,CAAA;AAAA,QAC9D;AAAA,MACF;AAEA,MAAA,MAAM,GAAA,GACJ,OAAO,YAAA,CAAa,QAAA,KAAa,YAAY,YAAA,CAAa,QAAA,IAAY,CAAA,GAAI,YAAA,CAAa,QAAA,GAAW,CAAA;AACpG,MAAA,MAAM,GAAA,GACJ,OAAO,YAAA,CAAa,QAAA,KAAa,QAAA,IAAY,YAAA,CAAa,QAAA,IAAY,CAAA,IAAK,GAAA,IAAO,YAAA,CAAa,QAAA,GAC3F,YAAA,CAAa,QAAA,GACb,MAAA;AACN,MAAA,MAAM,gBAAA,GAAmB,OAAO,GAAA,KAAQ,QAAA,GAAW,GAAA,GAAA,CAAO,OAAO,GAAA,GAAM,CAAA,CAAA,GAAK,GAAA,IAAO,GAAA,GAAM,CAAA,CAAA,IAAM,CAAA;AAC/F,MAAA,IACE,OAAA,CAAQ,IAAI,WAAA,KACX,GAAA,KAAQ,KAAK,GAAA,KAAQ,MAAA,CAAA,IACtB,mBAAmB,EAAA,EACnB;AACA,QAAA,IAAI,QAAQ,GAAA,EAAK;AACf,UAAA,MAAM,WAA0B,EAAC;AACjC,UAAA,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,GAAA,EAAK,CAAA,EAAA,EAAK;AAC5B,YAAA,QAAA,CAAS,KAAK,QAAQ,CAAA;AAAA,UACxB;AACA,UAAA,OAAO,QAAQ,CAAC,EAAA,CAAG,QAAQ,mBAAA,CAAoB,QAAQ,CAAC,CAAC,CAAA;AAAA,QAC3D,CAAA,MAAA,IAAY,YAAA,CAAa,QAAA,GAAsB,CAAA,EAAG;AAEhD,UAAA,MAAM,UAAyB,EAAC;AAEhC,UAAA,KAAA,IAAS,IAAI,CAAA,EAAG,CAAA,IAAA,CAAM,GAAA,IAAO,CAAA,IAAK,KAAK,CAAA,EAAA,EAAK;AAC1C,YAAA,MAAM,WAA0B,EAAC;AACjC,YAAA,KAAA,IAAS,CAAA,GAAI,GAAA,EAAK,CAAA,GAAI,CAAA,GAAI,KAAK,CAAA,EAAA,EAAK;AAClC,cAAA,QAAA,CAAS,KAAK,QAAQ,CAAA;AAAA,YACxB;AACA,YAAA,OAAA,CAAQ,IAAA,CAAK,EAAA,CAAG,OAAA,CAAQ,mBAAA,CAAoB,QAAQ,CAAC,CAAA;AAAA,UACvD;AACA,UAAA,OAAO,QAAQ,OAAO,CAAA;AAAA,QACxB,CAAA,MAEK;AACH,UAAA,MAAM,WAA0B,EAAC;AACjC,UAAA,KAAA,IAAS,CAAA,GAAI,CAAA,EAAG,CAAA,GAAI,GAAA,EAAK,CAAA,EAAA,EAAK;AAC5B,YAAA,QAAA,CAAS,KAAK,QAAQ,CAAA;AAAA,UACxB;AACA,UAAA,QAAA,CAAS,IAAA,CAAK,GAAG,OAAA,CAAQ,kBAAA,CAAmB,GAAG,OAAA,CAAQ,mBAAA,CAAoB,QAAQ,CAAC,CAAC,CAAA;AACrF,UAAA,OAAO,EAAA,CAAG,OAAA,CAAQ,mBAAA,CAAoB,QAAQ,CAAA;AAAA,QAChD;AAAA,MACF;AAEA,MAAA,MAAM,SAAA,GACJ,EAAA,CAAG,eAAA,CAAgB,QAAQ,CAAA,IAAK,EAAA,CAAG,eAAA,CAAgB,QAAQ,CAAA,GACvD,QAAA,GACA,EAAA,CAAG,OAAA,CAAQ,oBAAoB,QAAQ,CAAA;AAE7C,MAAA,OAAO,OAAA,CAAQ,GAAA,CAAI,SAAA,GACf,EAAA,CAAG,OAAA,CAAQ,uBAAuB,EAAA,CAAG,UAAA,CAAW,eAAA,EAAiB,SAAS,CAAA,GAC1E,SAAA;AAAA,IACN;AAGA,IAAA,IAAI,KAAA,CAAM,QAAQ,YAAA,CAAa,IAAI,KAAK,CAAC,KAAA,CAAM,OAAA,CAAQ,YAAY,CAAA,EAAG;AAEpE,MAAA,MAAM,cAA6B,EAAC;AACpC,MAAA,IAAI,KAAA,CAAM,OAAA,CAAQ,YAAA,CAAa,KAAK,CAAA,EAAG;AACrC,QAAA,KAAA,MAAW,CAAA,IAAK,aAAa,IAAA,EAAM;AACjC,UAAA,IAAA,CACG,CAAA,KAAM,aAAa,CAAA,KAAM,QAAA,IAAY,MAAM,QAAA,IAAY,CAAA,KAAM,SAAA,IAAa,CAAA,KAAM,MAAA,KACjF,YAAA,CAAa,MAAM,IAAA,CAAK,CAAC,CAAA,KAAM,OAAO,CAAA,KAAM,QAAA,IAAY,UAAU,CAAA,IAAK,CAAA,CAAE,IAAA,KAAS,CAAC,CAAA,EACnF;AACA,YAAA;AAAA,UACF;AACA,UAAA,WAAA,CAAY,IAAA;AAAA,YACV,CAAA,KAAM,MAAA,IAAU,CAAA,KAAM,IAAA,GAClB,IAAA,GACA,qBAAA;AAAA,cACE,EAAE,GAAG,YAAA,EAAc,IAAA,EAAM,CAAA,EAAG,OAAO,MAAA,EAAU;AAAA;AAAA,cAC7C;AAAA;AACF,WACN;AAAA,QACF;AAAA,MACF,CAAA,MAAO;AACL,QAAA,KAAA,MAAW,CAAA,IAAK,aAAa,IAAA,EAAM;AACjC,UAAA,IAAI,CAAA,KAAM,MAAA,IAAU,CAAA,KAAM,IAAA,EAAM;AAC9B,YAAA,WAAA,CAAY,KAAK,IAAI,CAAA;AAAA,UACvB,CAAA,MAAO;AACL,YAAA,WAAA,CAAY,IAAA,CAAK,sBAAsB,EAAE,GAAG,cAAc,IAAA,EAAM,CAAA,EAAE,EAAmB,OAAO,CAAC,CAAA;AAAA,UAC/F;AAAA,QACF;AAAA,MACF;AACA,MAAA,OAAO,QAAQ,WAAW,CAAA;AAAA,IAC5B;AAAA,EACF;AAGA,EAAA,MAAM,iBAAmC,EAAC;AAG1C,EAAA,KAAA,MAAW,CAAA,IAAK,CAAC,OAAA,EAAS,OAAO,CAAA,EAAY;AAC3C,IAAA,IAAI,CAAC,YAAA,CAAa,CAAC,CAAA,EAAG;AACpB,MAAA;AAAA,IACF;AAMA,IAAA,MAAM,aAAA,GACJ,CAAC,YAAA,CAAa,aAAA,IACd,CAAC,OAAA,CAAQ,GAAA,CAAI,eAAe,WAAA,CAAY,QAAA,CAAS,QAAQ,IAAA,IAAQ,EAAE,KACnE,OAAA,CAAQ,GAAA,CAAI,eAAe,OAAA,CAAQ,OAAA,CAAQ,QAAQ,EAAE,CAAA;AACvD,IAAA,IAAI,aAAA,EAAe;AACjB,MAAA,cAAA,CAAe,OAAA;AAAA,QACb,4BAA4B,aAAA,EAAe;AAAA,UACzC,IAAA,EAAM,QAAQ,IAAA,IAAQ,EAAA;AAAA,UACtB,QAAA,EAAU,QAAQ,GAAA,CAAI;AAAA,SACvB;AAAA,OACH;AACA,MAAA;AAAA,IACF;AAAA,EACF;AAEA,EAAA,IACG,YAAA,IAAgB,gBAAgB,YAAA,CAAa,UAAA,IAAc,OAAO,IAAA,CAAK,YAAA,CAAa,UAAU,CAAA,CAAE,MAAA,IAChG,0BAA0B,YAAA,IAAgB,YAAA,CAAa,wBACvD,mBAAA,IAAuB,YAAA,IAAgB,aAAa,iBAAA,IACpD,OAAA,IAAW,YAAA,IAAgB,YAAA,CAAa,KAAA,EACzC;AAEA,IAAA,IAAI,OAAO,IAAA,CAAK,YAAA,CAAa,cAAc,EAAE,EAAE,MAAA,EAAQ;AACrD,MAAA,KAAA,MAAW,CAAC,CAAA,EAAG,CAAC,CAAA,IAAK,UAAA,CAAW,YAAA,CAAa,UAAA,IAAc,EAAC,EAAG,OAAA,CAAQ,GAAG,CAAA,EAAG;AAC3E,QAAA,IAAK,OAAO,MAAM,QAAA,IAAY,OAAO,MAAM,SAAA,IAAc,KAAA,CAAM,OAAA,CAAQ,CAAC,CAAA,EAAG;AACzE,UAAA,MAAM,IAAI,KAAA;AAAA,YACR,CAAA,EAAG,OAAA,CAAQ,IAAI,CAAA,mBAAA,EAAsB,CAAC,CAAA,yCAAA,EACpC,KAAA,CAAM,OAAA,CAAQ,CAAC,CAAA,GAAI,OAAA,GAAU,OAAO,CACtC,CAAA;AAAA,WACF;AAAA,QACF;AAEA,QAAA,MAAM,EAAE,IAAA,EAAM,QAAA,EAAU,YAAW,GACjC,OAAO,MAAM,QAAA,GACT;AAAA,UACE,IAAA,EAAM,MAAA,IAAU,CAAA,IAAK,CAAA,CAAE,IAAA;AAAA,UACvB,QAAA,EAAU,UAAA,IAAc,CAAA,IAAK,CAAA,CAAE,QAAA;AAAA,UAC/B,UAAA,EAAY,SAAA,IAAa,CAAA,IAAK,CAAA,CAAE,OAAA,KAAY;AAAA,YAE9C,EAAC;AAGP,QAAA,IAAI,OAAA,CAAQ,IAAI,iBAAA,EAAmB;AACjC,UAAA,MAAM,WAAW,IAAA,GAAO,OAAA,CAAQ,GAAA,CAAI,OAAA,CAAsB,IAAI,CAAA,GAAI,CAAA;AAClE,UAAA,IAAK,UAA2B,UAAA,EAAY;AAC1C,YAAA;AAAA,UACF;AAAA,QACF;AACA,QAAA,IAAI,QAAA,GACF,YAAA,CAAa,QAAA,EAAU,QAAA,CAAS,CAAC,CAAA,IAChC,YAAA,CAAa,QAAA,KAAa,MAAA,IAAa,QAAQ,GAAA,CAAI,2BAAA,IACnD,UAAA,IACC,OAAA,CAAQ,IAAI,kBAAA,IACZ,CAAC,OAAA,CAAQ,IAAA,EAAM,QAAA,CAAS,YAAY,CAAA,IACpC,CAAC,QAAQ,IAAA,EAAM,QAAA,CAAS,aAAa,CAAA,IACrC,CAAC,OAAA,CAAQ,IAAA,EAAM,QAAA,CAAS,eAAe,IACrC,MAAA,GACA,cAAA;AACN,QAAA,IAAI,OAAO,IAAA,GACP,OAAA,CAAQ,IAAI,CAAA,GACZ,sBAAsB,CAAA,EAAG;AAAA,UACvB,GAAG,OAAA;AAAA,UACH,MAAM,SAAA,CAAU,CAAC,OAAA,CAAQ,IAAA,EAAM,CAAC,CAAC;AAAA,SAClC,CAAA;AAEL,QAAA,IAAI,OAAO,OAAA,CAAQ,GAAA,CAAI,SAAA,KAAc,UAAA,EAAY;AAC/C,UAAA,MAAM,MAAA,GAAS,OAAA,CAAQ,GAAA,CAAI,SAAA,CAAU,GAAmB,OAAO,CAAA;AAC/D,UAAA,IAAI,MAAA,IAAU,OAAO,MAAA,KAAW,QAAA,EAAU;AACxC,YAAA,IAAI,YAAY,MAAA,EAAQ;AACtB,cAAA,IAAA,GAAO,MAAA,CAAO,MAAA;AACd,cAAA,QAAA,GAAW,MAAA,CAAO,gBAAgB,cAAA,GAAiB,QAAA;AAAA,YACrD,CAAA,MAAO;AACL,cAAA,IAAA,GAAO,MAAA;AAAA,YACT;AAAA,UACF;AAAA,QACF;AAEA,QAAA,IAAI,QAAA,GAAW,GAAG,OAAA,CAAQ,uBAAA;AAAA;AAAA,UACJ,WAAA,CAAY;AAAA,YAC9B,QAAA,EAAU,OAAA,CAAQ,GAAA,CAAI,SAAA,IAAa;AAAA,WACpC,CAAA;AAAA;AAAA,UACmB,gBAAgB,CAAC,CAAA;AAAA;AAAA,UACjB,QAAA;AAAA;AAAA,UACA;AAAA,SACtB;AAGA,QAAA,IAAI,OAAO,OAAA,CAAQ,GAAA,CAAI,iBAAA,KAAsB,UAAA,EAAY;AACvD,UAAA,MAAM,MAAA,GAAS,OAAA,CAAQ,GAAA,CAAI,iBAAA,CAAkB,UAAU,CAAA,EAAmB;AAAA,YACxE,GAAG,OAAA;AAAA,YACH,MAAM,SAAA,CAAU,CAAC,OAAA,CAAQ,IAAA,EAAM,CAAC,CAAC;AAAA,WAClC,CAAA;AACD,UAAA,IAAI,MAAA,EAAQ;AACV,YAAA,QAAA,GAAW,MAAA;AAAA,UACb;AAAA,QACF;AAEA,QAAA,eAAA,CAAgB,GAAG,QAAQ,CAAA;AAC3B,QAAA,cAAA,CAAe,KAAK,QAAQ,CAAA;AAAA,MAC9B;AAAA,IACF;AAGA,IAAA,IAAI,YAAA,CAAa,KAAA,IAAS,OAAO,YAAA,CAAa,KAAA,KAAU,QAAA,IAAY,MAAA,CAAO,IAAA,CAAK,YAAA,CAAa,KAAK,CAAA,CAAE,MAAA,EAAQ;AAC1G,MAAA,MAAM,UAA4B,EAAC;AACnC,MAAA,KAAA,MAAW,CAAC,GAAG,CAAC,CAAA,IAAK,OAAO,OAAA,CAAQ,YAAA,CAAa,KAAK,CAAA,EAAG;AACvD,QAAA,IAAI,QAAA,GAAW,GAAG,OAAA,CAAQ,uBAAA;AAAA;AAAA,UACL,WAAA,CAAY;AAAA,YAC7B,QAAA,EAAU,QAAQ,GAAA,CAAI,SAAA,IAAc,cAAc,CAAA,IAAK,CAAC,CAAC,CAAA,CAAE;AAAA,WAC5D,CAAA;AAAA;AAAA,UACmB,gBAAgB,CAAC,CAAA;AAAA;AAAA,UACjB,MAAA;AAAA;AAAA,UACA,sBAAsB,CAAA,EAAG;AAAA,YAC3C,GAAG,OAAA;AAAA,YACH,MAAM,SAAA,CAAU,CAAC,QAAQ,IAAA,EAAM,OAAA,EAAS,CAAC,CAAC;AAAA,WAC3C;AAAA,SACH;AAGA,QAAA,IAAI,OAAO,OAAA,CAAQ,GAAA,CAAI,iBAAA,KAAsB,UAAA,EAAY;AACvD,UAAA,MAAM,MAAA,GAAS,OAAA,CAAQ,GAAA,CAAI,iBAAA,CAAkB,UAAU,CAAA,EAAmB;AAAA,YACxE,GAAG,OAAA;AAAA,YACH,MAAM,SAAA,CAAU,CAAC,QAAQ,IAAA,EAAM,OAAA,EAAS,CAAC,CAAC;AAAA,WAC3C,CAAA;AACD,UAAA,IAAI,MAAA,EAAQ;AACV,YAAA,QAAA,GAAW,MAAA;AAAA,UACb;AAAA,QACF;AAEA,QAAA,eAAA,CAAgB,GAAG,QAAQ,CAAA;AAC3B,QAAA,OAAA,CAAQ,KAAK,QAAQ,CAAA;AAAA,MACvB;AACA,MAAA,cAAA,CAAe,IAAA;AAAA,QACb,GAAG,OAAA,CAAQ,uBAAA;AAAA;AAAA,UACW,MAAA;AAAA;AAAA,UACA,gBAAgB,OAAO,CAAA;AAAA;AAAA,UACvB,MAAA;AAAA;AAAA,UACA,EAAA,CAAG,OAAA,CAAQ,qBAAA,CAAsB,OAAO;AAAA;AAC9D,OACF;AAAA,IACF;AAGA,IAAA,MAAM,+BAAA,GACJ,OAAO,YAAA,CAAa,oBAAA,KAAyB,YAAY,MAAA,CAAO,IAAA,CAAK,YAAA,CAAa,oBAAoB,CAAA,CAAE,MAAA;AAC1G,IAAA,MAAM,+BAAA,GACJ,YAAA,CAAa,oBAAA,KAAyB,IAAA,IACrC,OAAO,YAAA,CAAa,oBAAA,KAAyB,QAAA,IAC5C,MAAA,CAAO,IAAA,CAAK,YAAA,CAAa,oBAAoB,EAAE,MAAA,KAAW,CAAA;AAC9D,IAAA,MAAM,4BAAA,GACJ,OAAO,YAAA,CAAa,iBAAA,KAAsB,YAAY,MAAA,CAAO,IAAA,CAAK,YAAA,CAAa,iBAAiB,CAAA,CAAE,MAAA;AACpG,IAAA,MAAM,mBAAmB,EAAC;AAC1B,IAAA,IAAI,+BAAA,EAAiC;AACnC,MAAA,gBAAA,CAAiB,IAAA,CAAK,qBAAA,CAAsB,YAAA,CAAa,oBAAA,EAAsC,OAAO,CAAC,CAAA;AAAA,IACzG;AACA,IAAA,IAAI,mCAAoC,CAAC,YAAA,CAAa,oBAAA,IAAwB,OAAA,CAAQ,IAAI,oBAAA,EAAuB;AAC/G,MAAA,gBAAA,CAAiB,KAAK,OAAO,CAAA;AAAA,IAC/B;AACA,IAAA,IAAI,4BAAA,EAA8B;AAChC,MAAA,KAAA,MAAW,CAAC,CAAA,EAAG,CAAC,CAAA,IAAK,UAAA,CAAW,YAAA,CAAa,iBAAA,IAAqB,EAAC,EAAG,OAAA,CAAQ,GAAG,CAAA,EAAG;AAClF,QAAA,gBAAA,CAAiB,IAAA,CAAK,qBAAA,CAAsB,CAAA,EAAG,OAAO,CAAC,CAAA;AAAA,MACzD;AAAA,IACF;AAEA,IAAA,IAAI,gBAAA,CAAiB,WAAW,CAAA,EAAG;AACjC,MAAA,OAAO,eAAe,MAAA,GAAS,EAAA,CAAG,OAAA,CAAQ,qBAAA,CAAsB,cAAc,CAAA,GAAI,MAAA;AAAA,IACpF;AAEA,IAAA,MAAM,eAAA,GAAkB,QAAQ,gBAAgB,CAAA;AAEhD,IAAA,OAAO,cAAA,CAAe;AAAA,MACpB,GAAI,cAAA,CAAe,MAAA,GAAS,CAAC,EAAA,CAAG,QAAQ,qBAAA,CAAsB,cAAc,CAAC,CAAA,GAAI,EAAC;AAAA,MAClF,EAAA,CAAG,QAAQ,qBAAA,CAAsB;AAAA,QAC/B,GAAG,OAAA,CAAQ,oBAAA;AAAA;AAAA,UACQ,WAAA,CAAY;AAAA,YAC3B,QAAA,EAAU,QAAQ,GAAA,CAAI;AAAA,WACvB,CAAA;AAAA;AAAA,UACgB;AAAA,YACf,GAAG,OAAA,CAAQ,0BAAA;AAAA;AAAA,cACY,MAAA;AAAA;AAAA,cACA,MAAA;AAAA;AAAA,cACA,EAAA,CAAG,OAAA,CAAQ,gBAAA,CAAiB,KAAK,CAAA;AAAA;AAAA,cACjC,MAAA;AAAA;AAAA,cACA;AAAA;AACvB,WACF;AAAA;AAAA,UACiB;AAAA;AACnB,OACD;AAAA,KACF,CAAA;AAAA,EACH;AAEA,EAAA,OAAO,eAAe,MAAA,GAAS,EAAA,CAAG,OAAA,CAAQ,qBAAA,CAAsB,cAAc,CAAA,GAAI,MAAA;AACpF;AAQA,SAAS,MAAA,CAAyB,gBAAyB,GAAA,EAAmD;AAC5G,EAAA,OAAO,OAAO,cAAA,KAAmB,QAAA,IAAY,cAAA,KAAmB,QAAQ,GAAA,IAAO,cAAA;AACjF;;;;"}
\ No newline at end of file
+{"version":3,"file":"schema-object.mjs","sources":["../../src/transform/schema-object.ts"],"sourcesContent":["import { parseRef } from \"@redocly/openapi-core/lib/ref-utils.js\";\nimport ts from \"typescript\";\nimport {\n  addJSDocComment,\n  BOOLEAN,\n  NEVER,\n  NULL,\n  NUMBER,\n  oapiRef,\n  QUESTION_TOKEN,\n  STRING,\n  tsArrayLiteralExpression,\n  tsEnum,\n  tsIntersection,\n  tsIsPrimitive,\n  tsLiteral,\n  tsModifiers,\n  tsNullable,\n  tsOmit,\n  tsPropertyIndex,\n  tsRecord,\n  tsUnion,\n  tsWithRequired,\n  UNDEFINED,\n  UNKNOWN,\n} from \"../lib/ts.js\";\nimport { createDiscriminatorProperty, createRef, getEntries } from \"../lib/utils.js\";\nimport type { ReferenceObject, SchemaObject, TransformNodeOptions } from \"../types.js\";\n\n/**\n * Transform SchemaObject nodes (4.8.24)\n * @see https://spec.openapis.org/oas/v3.1.0#schema-object\n */\nexport default function transformSchemaObject(\n  schemaObject: SchemaObject | ReferenceObject,\n  options: TransformNodeOptions,\n  fromAdditionalProperties = false,\n): ts.TypeNode {\n  const type = transformSchemaObjectWithComposition(schemaObject, options, fromAdditionalProperties);\n  if (typeof options.ctx.postTransform === \"function\") {\n    const postTransformResult = options.ctx.postTransform(type, options);\n    if (postTransformResult) {\n      return postTransformResult;\n    }\n  }\n  return type;\n}\n\n/**\n * Transform SchemaObjects\n */\nexport function transformSchemaObjectWithComposition(\n  schemaObject: SchemaObject | ReferenceObject,\n  options: TransformNodeOptions,\n  fromAdditionalProperties = false,\n): ts.TypeNode {\n  /**\n   * Unexpected types & edge cases\n   */\n\n  // missing/falsy type returns `never`\n  if (!schemaObject) {\n    return NEVER;\n  }\n  // `true` returns `unknown` (this exists, but is untyped)\n  if ((schemaObject as unknown) === true) {\n    return UNKNOWN;\n  }\n  // for any other unexpected type, throw error\n  if (Array.isArray(schemaObject) || typeof schemaObject !== \"object\") {\n    throw new Error(\n      `Expected SchemaObject, received ${Array.isArray(schemaObject) ? \"Array\" : typeof schemaObject} at ${options.path}`,\n    );\n  }\n\n  /**\n   * ReferenceObject\n   */\n  if (\"$ref\" in schemaObject) {\n    return oapiRef(schemaObject.$ref);\n  }\n\n  /**\n   * const (valid for any type)\n   */\n  if (schemaObject.const !== null && schemaObject.const !== undefined) {\n    return tsLiteral(schemaObject.const);\n  }\n\n  /**\n   * enum (non-objects)\n   * note: enum is valid for any type, but for objects, handle in oneOf below\n   */\n  if (\n    Array.isArray(schemaObject.enum) &&\n    (!(\"type\" in schemaObject) || schemaObject.type !== \"object\") &&\n    !(\"properties\" in schemaObject) &&\n    !(\"additionalProperties\" in schemaObject)\n  ) {\n    // hoist enum to top level if string/number enum and option is enabled\n    if (\n      options.ctx.enum &&\n      schemaObject.enum.every((v) => typeof v === \"string\" || typeof v === \"number\" || v === null)\n    ) {\n      let enumName = parseRef(options.path ?? \"\").pointer.join(\"/\");\n      // allow #/components/schemas to have simpler names\n      enumName = enumName.replace(\"components/schemas\", \"\");\n      const metadata = schemaObject.enum.map((_, i) => ({\n        name: schemaObject[\"x-enum-varnames\"]?.[i] ?? schemaObject[\"x-enumNames\"]?.[i],\n        description: schemaObject[\"x-enum-descriptions\"]?.[i] ?? schemaObject[\"x-enumDescriptions\"]?.[i],\n      }));\n\n      // enums can contain null values, but dont want to output them\n      let hasNull = false;\n      const validSchemaEnums = schemaObject.enum.filter((enumValue) => {\n        if (enumValue === null) {\n          hasNull = true;\n          return false;\n        }\n\n        return true;\n      });\n      const enumType = tsEnum(enumName, validSchemaEnums as (string | number)[], metadata, {\n        shouldCache: options.ctx.dedupeEnums,\n        export: true,\n        // readonly: TS enum do not support the readonly modifier\n      });\n      if (!options.ctx.injectFooter.includes(enumType)) {\n        options.ctx.injectFooter.push(enumType);\n      }\n      const ref = ts.factory.createTypeReferenceNode(enumType.name);\n      return hasNull ? tsUnion([ref, NULL]) : ref;\n    }\n    const enumType = schemaObject.enum.map(tsLiteral);\n    if ((Array.isArray(schemaObject.type) && schemaObject.type.includes(\"null\")) || schemaObject.nullable) {\n      enumType.push(NULL);\n    }\n\n    const unionType = tsUnion(enumType);\n\n    // hoist array with valid enum values to top level if string/number enum and option is enabled\n    if (options.ctx.enumValues && schemaObject.enum.every((v) => typeof v === \"string\" || typeof v === \"number\")) {\n      const parsed = parseRef(options.path ?? \"\");\n      let enumValuesVariableName = parsed.pointer.join(\"/\");\n      // allow #/components/schemas to have simpler names\n      enumValuesVariableName = enumValuesVariableName.replace(\"components/schemas\", \"\");\n      enumValuesVariableName = `${enumValuesVariableName}Values`;\n\n      // build a ref path for the type that ignores union indices (anyOf/oneOf) so\n      // type references remain stable even when names include union positions\n      const cleanedPointer: string[] = [];\n      for (let i = 0; i < parsed.pointer.length; i++) {\n        // Example: #/paths/analytics/data/get/responses/400/content/application/json/anyOf/0/message\n        const segment = parsed.pointer[i];\n        if ((segment === \"anyOf\" || segment === \"oneOf\") && i < parsed.pointer.length - 1) {\n          const next = parsed.pointer[i + 1];\n          if (/^\\d+$/.test(next)) {\n            // If we encounter something like \"anyOf/0\", we want to skip that part of the path\n            i++;\n            continue;\n          }\n        }\n        cleanedPointer.push(segment);\n      }\n      const cleanedRefPath = createRef(cleanedPointer);\n\n      const enumValuesArray = tsArrayLiteralExpression(\n        enumValuesVariableName,\n        // If fromAdditionalProperties is true we are dealing with a record type and we should append [string] to the generated type\n        fromAdditionalProperties\n          ? ts.factory.createIndexedAccessTypeNode(\n              oapiRef(cleanedRefPath, undefined, true),\n              ts.factory.createTypeReferenceNode(ts.factory.createIdentifier(\"string\")),\n            )\n          : oapiRef(cleanedRefPath, undefined, true),\n        schemaObject.enum as (string | number)[],\n        {\n          export: true,\n          readonly: true,\n          injectFooter: options.ctx.injectFooter,\n        },\n      );\n\n      options.ctx.injectFooter.push(enumValuesArray);\n    }\n\n    return unionType;\n  }\n\n  /**\n   * Object + composition (anyOf/allOf/oneOf) types\n   */\n\n  /** Collect oneOf/anyOf */\n  function collectUnionCompositions(items: (SchemaObject | ReferenceObject)[], unionKey: \"anyOf\" | \"oneOf\") {\n    const output: ts.TypeNode[] = [];\n    for (const [index, item] of items.entries()) {\n      output.push(\n        transformSchemaObject(item, {\n          ...options,\n          // include index in path so generated names from nested enums/enumValues are unique\n          path: createRef([options.path, unionKey, String(index)]),\n        }),\n      );\n    }\n\n    return output;\n  }\n\n  /** Collect allOf with Omit<> for discriminators */\n  function collectAllOfCompositions(items: (SchemaObject | ReferenceObject)[], required?: string[]): ts.TypeNode[] {\n    const output: ts.TypeNode[] = [];\n    for (const item of items) {\n      let itemType: ts.TypeNode;\n      // if this is a $ref, use WithRequired<X, Y> if parent specifies required properties\n      // (but only for valid keys)\n      if (\"$ref\" in item) {\n        itemType = transformSchemaObject(item, options);\n\n        const resolved = options.ctx.resolve<SchemaObject>(item.$ref);\n\n        // make keys required, if necessary\n        if (\n          resolved &&\n          typeof resolved === \"object\" &&\n          \"properties\" in resolved &&\n          // we have already handled this item (discriminator property was already added as required)\n          !options.ctx.discriminators.refsHandled.includes(item.$ref)\n        ) {\n          // add WithRequired<X, Y> if necessary\n          const validRequired = (required ?? []).filter((key) => !!resolved.properties?.[key]);\n          if (validRequired.length) {\n            itemType = tsWithRequired(itemType, validRequired, options.ctx.injectFooter);\n          }\n        }\n      }\n      // otherwise, if this is a schema object, combine parent `required[]` with its own, if any\n      else {\n        const itemRequired = [...(required ?? [])];\n        if (typeof item === \"object\" && Array.isArray(item.required)) {\n          itemRequired.push(...item.required);\n        }\n        itemType = transformSchemaObject({ ...item, required: itemRequired }, options);\n      }\n\n      const discriminator =\n        (\"$ref\" in item && options.ctx.discriminators.objects[item.$ref]) || (item as any).discriminator;\n      if (discriminator) {\n        output.push(tsOmit(itemType, [discriminator.propertyName]));\n      } else {\n        output.push(itemType);\n      }\n    }\n    return output;\n  }\n\n  // compile final type\n  let finalType: ts.TypeNode | undefined = undefined;\n\n  // core + allOf: intersect\n  const coreObjectType = transformSchemaObjectCore(schemaObject, options);\n  const allOfType = collectAllOfCompositions(schemaObject.allOf ?? [], schemaObject.required);\n  if (coreObjectType || allOfType.length) {\n    const allOf: ts.TypeNode | undefined = allOfType.length ? tsIntersection(allOfType) : undefined;\n    finalType = tsIntersection([...(coreObjectType ? [coreObjectType] : []), ...(allOf ? [allOf] : [])]);\n  }\n  // anyOf: union\n  // (note: this may seem counterintuitive, but as TypeScript’s unions are not true XORs, they mimic behavior closer to anyOf than oneOf)\n  const anyOfType = collectUnionCompositions(schemaObject.anyOf ?? [], \"anyOf\");\n  if (anyOfType.length) {\n    finalType = tsUnion([...(finalType ? [finalType] : []), ...anyOfType]);\n  }\n  // oneOf: union (within intersection with other types, if any)\n  const oneOfType = collectUnionCompositions(\n    schemaObject.oneOf ||\n      (\"type\" in schemaObject &&\n        schemaObject.type === \"object\" &&\n        (schemaObject.enum as (SchemaObject | ReferenceObject)[])) ||\n      [],\n    \"oneOf\",\n  );\n  if (oneOfType.length) {\n    // note: oneOf is the only type that may include primitives\n    if (oneOfType.every(tsIsPrimitive)) {\n      finalType = tsUnion([...(finalType ? [finalType] : []), ...oneOfType]);\n    } else {\n      finalType = tsIntersection([...(finalType ? [finalType] : []), tsUnion(oneOfType)]);\n    }\n  }\n\n  // When no final type can be generated, fall back to unknown type (or related variants)\n  if (!finalType) {\n    if (\"type\" in schemaObject) {\n      finalType = tsRecord(STRING, options.ctx.emptyObjectsUnknown ? UNKNOWN : NEVER);\n    } else {\n      finalType = UNKNOWN;\n    }\n  }\n\n  if (finalType !== UNKNOWN && schemaObject.nullable) {\n    finalType = tsNullable([finalType]);\n  }\n\n  return finalType;\n}\n\n/**\n * Handle SchemaObject minus composition (anyOf/allOf/oneOf)\n */\nfunction transformSchemaObjectCore(schemaObject: SchemaObject, options: TransformNodeOptions): ts.TypeNode | undefined {\n  if (\"type\" in schemaObject && schemaObject.type) {\n    if (typeof options.ctx.transform === \"function\") {\n      const result = options.ctx.transform(schemaObject, options);\n      if (result && typeof result === \"object\") {\n        if (\"schema\" in result) {\n          if (result.questionToken) {\n            return ts.factory.createUnionTypeNode([result.schema, UNDEFINED]);\n          } else {\n            return result.schema;\n          }\n        } else {\n          return result;\n        }\n      }\n    }\n\n    // primitives\n    // type: null\n    if (schemaObject.type === \"null\") {\n      return NULL;\n    }\n    // type: string\n    if (schemaObject.type === \"string\") {\n      return STRING;\n    }\n    // type: number / type: integer\n    if (schemaObject.type === \"number\" || schemaObject.type === \"integer\") {\n      return NUMBER;\n    }\n    // type: boolean\n    if (schemaObject.type === \"boolean\") {\n      return BOOLEAN;\n    }\n\n    // type: array (with support for tuples)\n    if (schemaObject.type === \"array\") {\n      // default to `unknown[]`\n      let itemType: ts.TypeNode = UNKNOWN;\n      // tuple type\n      if (schemaObject.prefixItems || Array.isArray(schemaObject.items)) {\n        const prefixItems = schemaObject.prefixItems ?? (schemaObject.items as (SchemaObject | ReferenceObject)[]);\n        itemType = ts.factory.createTupleTypeNode(prefixItems.map((item) => transformSchemaObject(item, options)));\n      }\n      // standard array type\n      else if (schemaObject.items) {\n        if (hasKey(schemaObject.items, \"type\") && schemaObject.items.type === \"array\") {\n          itemType = ts.factory.createArrayTypeNode(transformSchemaObject(schemaObject.items, options));\n        } else {\n          itemType = transformSchemaObject(schemaObject.items, options);\n        }\n      }\n\n      const min: number =\n        typeof schemaObject.minItems === \"number\" && schemaObject.minItems >= 0 ? schemaObject.minItems : 0;\n      const max: number | undefined =\n        typeof schemaObject.maxItems === \"number\" && schemaObject.maxItems >= 0 && min <= schemaObject.maxItems\n          ? schemaObject.maxItems\n          : undefined;\n      const estimateCodeSize = typeof max !== \"number\" ? min : (max * (max + 1) - min * (min - 1)) / 2;\n      if (\n        options.ctx.arrayLength &&\n        (min !== 0 || max !== undefined) &&\n        estimateCodeSize < 30 // \"30\" is an arbitrary number but roughly around when TS starts to struggle with tuple inference in practice\n      ) {\n        if (min === max) {\n          const elements: ts.TypeNode[] = [];\n          for (let i = 0; i < min; i++) {\n            elements.push(itemType);\n          }\n          return tsUnion([ts.factory.createTupleTypeNode(elements)]);\n        } else if ((schemaObject.maxItems as number) > 0) {\n          // if maxItems is set, then return a union of all permutations of possible tuple types\n          const members: ts.TypeNode[] = [];\n          // populate 1 short of min …\n          for (let i = 0; i <= (max ?? 0) - min; i++) {\n            const elements: ts.TypeNode[] = [];\n            for (let j = min; j < i + min; j++) {\n              elements.push(itemType);\n            }\n            members.push(ts.factory.createTupleTypeNode(elements));\n          }\n          return tsUnion(members);\n        }\n        // if maxItems not set, then return a simple tuple type the length of `min`\n        else {\n          const elements: ts.TypeNode[] = [];\n          for (let i = 0; i < min; i++) {\n            elements.push(itemType);\n          }\n          elements.push(ts.factory.createRestTypeNode(ts.factory.createArrayTypeNode(itemType)));\n          return ts.factory.createTupleTypeNode(elements);\n        }\n      }\n\n      const finalType =\n        ts.isTupleTypeNode(itemType) || ts.isArrayTypeNode(itemType)\n          ? itemType\n          : ts.factory.createArrayTypeNode(itemType); // wrap itemType in array type, but only if not a tuple or array already\n\n      return options.ctx.immutable\n        ? ts.factory.createTypeOperatorNode(ts.SyntaxKind.ReadonlyKeyword, finalType)\n        : finalType;\n    }\n\n    // polymorphic, or 3.1 nullable\n    if (Array.isArray(schemaObject.type) && !Array.isArray(schemaObject)) {\n      // skip any primitive types that appear in oneOf as well\n      const uniqueTypes: ts.TypeNode[] = [];\n      if (Array.isArray(schemaObject.oneOf)) {\n        for (const t of schemaObject.type) {\n          if (\n            (t === \"boolean\" || t === \"string\" || t === \"number\" || t === \"integer\" || t === \"null\") &&\n            schemaObject.oneOf.find((o) => typeof o === \"object\" && \"type\" in o && o.type === t)\n          ) {\n            continue;\n          }\n          uniqueTypes.push(\n            t === \"null\" || t === null\n              ? NULL\n              : transformSchemaObject(\n                  { ...schemaObject, type: t, oneOf: undefined } as SchemaObject, // don’t stack oneOf transforms\n                  options,\n                ),\n          );\n        }\n      } else {\n        for (const t of schemaObject.type) {\n          if (t === \"null\" || t === null) {\n            uniqueTypes.push(NULL);\n          } else {\n            uniqueTypes.push(transformSchemaObject({ ...schemaObject, type: t } as SchemaObject, options));\n          }\n        }\n      }\n      return tsUnion(uniqueTypes);\n    }\n  }\n\n  // type: object\n  const coreObjectType: ts.TypeElement[] = [];\n\n  // discriminators: explicit mapping on schema object\n  for (const k of [\"allOf\", \"anyOf\"] as const) {\n    if (!schemaObject[k]) {\n      continue;\n    }\n    // for all magic inheritance, we will have already gathered it into\n    // ctx.discriminators. But stop objects from referencing their own\n    // discriminator meant for children (!schemaObject.discriminator)\n    // and don't add discriminator properties if we already added/patched\n    // them (options.ctx.discriminators.refsHandled.includes(options.path!).\n    const discriminator =\n      !schemaObject.discriminator &&\n      !options.ctx.discriminators.refsHandled.includes(options.path ?? \"\") &&\n      options.ctx.discriminators.objects[options.path ?? \"\"];\n    if (discriminator) {\n      coreObjectType.unshift(\n        createDiscriminatorProperty(discriminator, {\n          path: options.path ?? \"\",\n          readonly: options.ctx.immutable,\n        }),\n      );\n      break;\n    }\n  }\n\n  if (\n    (\"properties\" in schemaObject && schemaObject.properties && Object.keys(schemaObject.properties).length) ||\n    (\"additionalProperties\" in schemaObject && schemaObject.additionalProperties) ||\n    (\"patternProperties\" in schemaObject && schemaObject.patternProperties) ||\n    (\"$defs\" in schemaObject && schemaObject.$defs)\n  ) {\n    // properties\n    if (Object.keys(schemaObject.properties ?? {}).length) {\n      for (const [k, v] of getEntries(schemaObject.properties ?? {}, options.ctx)) {\n        if ((typeof v !== \"object\" && typeof v !== \"boolean\") || Array.isArray(v)) {\n          throw new Error(\n            `${options.path}: invalid property ${k}. Expected Schema Object or boolean, got ${\n              Array.isArray(v) ? \"Array\" : typeof v\n            }`,\n          );\n        }\n\n        const { $ref, readOnly, hasDefault } =\n          typeof v === \"object\"\n            ? {\n                $ref: \"$ref\" in v && v.$ref,\n                readOnly: \"readOnly\" in v && v.readOnly,\n                hasDefault: \"default\" in v && v.default !== undefined,\n              }\n            : {};\n\n        // handle excludeDeprecated option\n        if (options.ctx.excludeDeprecated) {\n          const resolved = $ref ? options.ctx.resolve<SchemaObject>($ref) : v;\n          if ((resolved as SchemaObject)?.deprecated) {\n            continue;\n          }\n        }\n        let optional =\n          schemaObject.required?.includes(k) ||\n          (schemaObject.required === undefined && options.ctx.propertiesRequiredByDefault) ||\n          (hasDefault &&\n            options.ctx.defaultNonNullable &&\n            !options.path?.includes(\"parameters\") &&\n            !options.path?.includes(\"requestBody\") &&\n            !options.path?.includes(\"requestBodies\")) // can’t be required, even with defaults\n            ? undefined\n            : QUESTION_TOKEN;\n        let type = $ref\n          ? oapiRef($ref)\n          : transformSchemaObject(v, {\n              ...options,\n              path: createRef([options.path, k]),\n            });\n\n        if (typeof options.ctx.transform === \"function\") {\n          const result = options.ctx.transform(v as SchemaObject, options);\n          if (result && typeof result === \"object\") {\n            if (\"schema\" in result) {\n              type = result.schema;\n              optional = result.questionToken ? QUESTION_TOKEN : optional;\n            } else {\n              type = result;\n            }\n          }\n        }\n\n        let property = ts.factory.createPropertySignature(\n          /* modifiers     */ tsModifiers({\n            readonly: options.ctx.immutable || readOnly,\n          }),\n          /* name          */ tsPropertyIndex(k),\n          /* questionToken */ optional,\n          /* type          */ type,\n        );\n\n        // Apply transformProperty hook if available\n        if (typeof options.ctx.transformProperty === \"function\") {\n          const result = options.ctx.transformProperty(property, v as SchemaObject, {\n            ...options,\n            path: createRef([options.path, k]),\n          });\n          if (result) {\n            property = result;\n          }\n        }\n\n        addJSDocComment(v, property);\n        coreObjectType.push(property);\n      }\n    }\n\n    // $defs\n    if (schemaObject.$defs && typeof schemaObject.$defs === \"object\" && Object.keys(schemaObject.$defs).length) {\n      const defKeys: ts.TypeElement[] = [];\n      for (const [k, v] of Object.entries(schemaObject.$defs)) {\n        let property = ts.factory.createPropertySignature(\n          /* modifiers    */ tsModifiers({\n            readonly: options.ctx.immutable || (\"readonly\" in v && !!v.readOnly),\n          }),\n          /* name          */ tsPropertyIndex(k),\n          /* questionToken */ undefined,\n          /* type          */ transformSchemaObject(v, {\n            ...options,\n            path: createRef([options.path, \"$defs\", k]),\n          }),\n        );\n\n        // Apply transformProperty hook if available\n        if (typeof options.ctx.transformProperty === \"function\") {\n          const result = options.ctx.transformProperty(property, v as SchemaObject, {\n            ...options,\n            path: createRef([options.path, \"$defs\", k]),\n          });\n          if (result) {\n            property = result;\n          }\n        }\n\n        addJSDocComment(v, property);\n        defKeys.push(property);\n      }\n      coreObjectType.push(\n        ts.factory.createPropertySignature(\n          /* modifiers     */ undefined,\n          /* name          */ tsPropertyIndex(\"$defs\"),\n          /* questionToken */ undefined,\n          /* type          */ ts.factory.createTypeLiteralNode(defKeys),\n        ),\n      );\n    }\n\n    // additionalProperties / patternProperties\n    const hasExplicitAdditionalProperties =\n      typeof schemaObject.additionalProperties === \"object\" && Object.keys(schemaObject.additionalProperties).length;\n    const hasImplicitAdditionalProperties =\n      schemaObject.additionalProperties === true ||\n      (typeof schemaObject.additionalProperties === \"object\" &&\n        Object.keys(schemaObject.additionalProperties).length === 0);\n    const hasExplicitPatternProperties =\n      typeof schemaObject.patternProperties === \"object\" && Object.keys(schemaObject.patternProperties).length;\n    const stringIndexTypes = [];\n    if (hasExplicitAdditionalProperties) {\n      stringIndexTypes.push(transformSchemaObject(schemaObject.additionalProperties as SchemaObject, options, true));\n    }\n    if (hasImplicitAdditionalProperties || (!schemaObject.additionalProperties && options.ctx.additionalProperties)) {\n      stringIndexTypes.push(UNKNOWN);\n    }\n    if (hasExplicitPatternProperties) {\n      for (const [_, v] of getEntries(schemaObject.patternProperties ?? {}, options.ctx)) {\n        stringIndexTypes.push(transformSchemaObject(v, options));\n      }\n    }\n\n    if (stringIndexTypes.length === 0) {\n      return coreObjectType.length ? ts.factory.createTypeLiteralNode(coreObjectType) : undefined;\n    }\n\n    const stringIndexType = tsUnion(stringIndexTypes);\n\n    return tsIntersection([\n      ...(coreObjectType.length ? [ts.factory.createTypeLiteralNode(coreObjectType)] : []),\n      ts.factory.createTypeLiteralNode([\n        ts.factory.createIndexSignature(\n          /* modifiers  */ tsModifiers({\n            readonly: options.ctx.immutable,\n          }),\n          /* parameters */ [\n            ts.factory.createParameterDeclaration(\n              /* modifiers      */ undefined,\n              /* dotDotDotToken */ undefined,\n              /* name           */ ts.factory.createIdentifier(\"key\"),\n              /* questionToken  */ undefined,\n              /* type           */ STRING,\n            ),\n          ],\n          /* type       */ stringIndexType,\n        ),\n      ]),\n    ]);\n  }\n\n  return coreObjectType.length ? ts.factory.createTypeLiteralNode(coreObjectType) : undefined;\n}\n\n/**\n * Check if an object has a key\n * @param possibleObject - The object to check\n * @param key - The key to check for\n * @returns True if the object has the key, false otherwise\n */\nfunction hasKey<K extends string>(possibleObject: unknown, key: K): possibleObject is { [key in K]: unknown } {\n  return typeof possibleObject === \"object\" && possibleObject !== null && key in possibleObject;\n}\n"],"names":["enumType"],"mappings":"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"}
