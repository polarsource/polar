{"version":3,"file":"LightningStrike.js","sources":["../../src/geometries/LightningStrike.js"],"sourcesContent":["import {\n  BufferGeometry,\n  DynamicDrawUsage,\n  Float32BufferAttribute,\n  MathUtils,\n  Uint32BufferAttribute,\n  Vector3,\n} from 'three'\nimport { SimplexNoise } from '../math/SimplexNoise'\n\n/**\n * @fileoverview LightningStrike object for creating lightning strikes and voltaic arcs.\n *\n *\n * Usage\n *\n * var myRay = new LightningStrike( paramsObject );\n * var myRayMesh = new THREE.Mesh( myRay, myMaterial );\n * scene.add( myRayMesh );\n * ...\n * myRay.update( currentTime );\n *\n * The \"currentTime\" can vary its rate, go forwards, backwards or even jump, but it cannot be negative.\n *\n * You should normally leave the ray position to (0, 0, 0). You should control it by changing the sourceOffset and destOffset parameters.\n *\n *\n * LightningStrike parameters\n *\n * The paramsObject can contain any of the following parameters.\n *\n * Legend:\n * 'LightningStrike' (also called 'ray'): An independent voltaic arc with its ramifications and defined with a set of parameters.\n * 'Subray': A ramification of the ray. It is not a LightningStrike object.\n * 'Segment': A linear segment piece of a subray.\n * 'Leaf segment': A ray segment which cannot be smaller.\n *\n *\n * The following parameters can be changed any time and if they vary smoothly, the ray form will also change smoothly:\n *\n * @param {Vector3} sourceOffset The point where the ray starts.\n *\n * @param {Vector3} destOffset The point where the ray ends.\n *\n * @param {double} timeScale The rate at wich the ray form changes in time. Default: 1\n *\n * @param {double} roughness From 0 to 1. The higher the value, the more wrinkled is the ray. Default: 0.9\n *\n * @param {double} straightness From 0 to 1. The higher the value, the more straight will be a subray path. Default: 0.7\n *\n * @param {Vector3} up0 Ray 'up' direction at the ray starting point. Must be normalized. It should be perpendicular to the ray forward direction but it doesn't matter much.\n *\n * @param {Vector3} up1 Like the up0 parameter but at the end of the ray. Must be normalized.\n *\n * @param {double} radius0 Radius of the main ray trunk at the start point. Default: 1\n *\n * @param {double} radius1 Radius of the main ray trunk at the end point. Default: 1\n *\n * @param {double} radius0Factor The radius0 of a subray is this factor times the radius0 of its parent subray. Default: 0.5\n *\n * @param {double} radius1Factor The radius1 of a subray is this factor times the radius1 of its parent subray. Default: 0.2\n *\n * @param {minRadius} Minimum value a subray radius0 or radius1 can get. Default: 0.1\n *\n *\n * The following parameters should not be changed after lightning creation. They can be changed but the ray will change its form abruptly:\n *\n * @param {boolean} isEternal If true the ray never extinguishes. Otherwise its life is controlled by the 'birthTime' and 'deathTime' parameters. Default: true if any of those two parameters is undefined.\n *\n * @param {double} birthTime The time at which the ray starts its life and begins propagating. Only if isEternal is false. Default: None.\n *\n * @param {double} deathTime The time at which the ray ends vanishing and its life. Only if isEternal is false. Default: None.\n *\n * @param {double} propagationTimeFactor From 0 to 1. Lifetime factor at which the ray ends propagating and enters the steady phase. For example, 0.1 means it is propagating 1/10 of its lifetime. Default: 0.1\n *\n * @param {double} vanishingTimeFactor From 0 to 1. Lifetime factor at which the ray ends the steady phase and begins vanishing. For example, 0.9 means it is vanishing 1/10 of its lifetime. Default: 0.9\n *\n * @param {double} subrayPeriod Subrays cycle periodically. This is their time period. Default: 4\n *\n * @param {double} subrayDutyCycle From 0 to 1. This is the fraction of time a subray is active. Default: 0.6\n *\n *\n * These parameters cannot change after lightning creation:\n *\n * @param {integer} maxIterations: Greater than 0. The number of ray's leaf segments is 2**maxIterations. Default: 9\n *\n * @param {boolean} isStatic Set to true only for rays which won't change over time and are not attached to moving objects (Rare case). It is used to set the vertex buffers non-dynamic. You can omit calling update() for these rays.\n *\n * @param {integer} ramification Greater than 0. Maximum number of child subrays a subray can have. Default: 5\n *\n * @param {integer} maxSubrayRecursion Greater than 0. Maximum level of recursion (subray descendant generations). Default: 3\n *\n * @param {double} recursionProbability From 0 to 1. The lower the value, the less chance each new generation of subrays has to generate new subrays. Default: 0.6\n *\n * @param {boolean} generateUVs If true, the ray geometry will have uv coordinates generated. u runs along the ray, and v across its perimeter. Default: false.\n *\n * @param {Object} randomGenerator Set here your random number generator which will seed the SimplexNoise and other decisions during ray tree creation.\n * It can be used to generate repeatable rays. For that, set also the noiseSeed parameter, and each ray created with that generator and seed pair will be identical in time.\n * The randomGenerator parameter should be an object with a random() function similar to Math.random, but seedable.\n * It must have also a getSeed() method, which returns the current seed, and a setSeed( seed ) method, which accepts as seed a fractional number from 0 to 1, as well as any other number.\n * The default value is an internal generator for some uses and Math.random for others (It is non-repeatable even if noiseSeed is supplied)\n *\n * @param {double} noiseSeed Seed used to make repeatable rays (see the randomGenerator)\n *\n * @param {function} onDecideSubrayCreation Set this to change the callback which decides subray creation. You can look at the default callback in the code (createDefaultSubrayCreationCallbacks)for more info.\n *\n * @param {function} onSubrayCreation This is another callback, more simple than the previous one. It can be used to adapt the form of subrays or other parameters once a subray has been created and initialized. It is used in the examples to adapt subrays to a sphere or to a plane.\n *\n *\n */\n\nclass LightningStrike extends BufferGeometry {\n  // Ray states\n  static RAY_INITIALIZED = 0\n  static RAY_UNBORN = 1\n  static RAY_PROPAGATING = 2\n  static RAY_STEADY = 3\n  static RAY_VANISHING = 4\n  static RAY_EXTINGUISHED = 5\n\n  static COS30DEG = Math.cos((30 * Math.PI) / 180)\n  static SIN30DEG = Math.sin((30 * Math.PI) / 180)\n\n  constructor(rayParameters = {}) {\n    super()\n\n    this.isLightningStrike = true\n\n    this.type = 'LightningStrike'\n\n    // Set parameters, and set undefined parameters to default values\n    this.init(LightningStrike.copyParameters(rayParameters, rayParameters))\n\n    // Creates and populates the mesh\n    this.createMesh()\n  }\n\n  static createRandomGenerator() {\n    const numSeeds = 2053\n    const seeds = []\n\n    for (let i = 0; i < numSeeds; i++) {\n      seeds.push(Math.random())\n    }\n\n    const generator = {\n      currentSeed: 0,\n\n      random: function () {\n        const value = seeds[generator.currentSeed]\n\n        generator.currentSeed = (generator.currentSeed + 1) % numSeeds\n\n        return value\n      },\n\n      getSeed: function () {\n        return generator.currentSeed / numSeeds\n      },\n\n      setSeed: function (seed) {\n        generator.currentSeed = Math.floor(seed * numSeeds) % numSeeds\n      },\n    }\n\n    return generator\n  }\n\n  static copyParameters(dest = {}, source = {}) {\n    const vecCopy = function (v) {\n      if (source === dest) {\n        return v\n      } else {\n        return v.clone()\n      }\n    }\n\n    ;(dest.sourceOffset = source.sourceOffset !== undefined ? vecCopy(source.sourceOffset) : new Vector3(0, 100, 0)),\n      (dest.destOffset = source.destOffset !== undefined ? vecCopy(source.destOffset) : new Vector3(0, 0, 0)),\n      (dest.timeScale = source.timeScale !== undefined ? source.timeScale : 1),\n      (dest.roughness = source.roughness !== undefined ? source.roughness : 0.9),\n      (dest.straightness = source.straightness !== undefined ? source.straightness : 0.7),\n      (dest.up0 = source.up0 !== undefined ? vecCopy(source.up0) : new Vector3(0, 0, 1))\n    ;(dest.up1 = source.up1 !== undefined ? vecCopy(source.up1) : new Vector3(0, 0, 1)),\n      (dest.radius0 = source.radius0 !== undefined ? source.radius0 : 1),\n      (dest.radius1 = source.radius1 !== undefined ? source.radius1 : 1),\n      (dest.radius0Factor = source.radius0Factor !== undefined ? source.radius0Factor : 0.5),\n      (dest.radius1Factor = source.radius1Factor !== undefined ? source.radius1Factor : 0.2),\n      (dest.minRadius = source.minRadius !== undefined ? source.minRadius : 0.2),\n      // These parameters should not be changed after lightning creation. They can be changed but the ray will change its form abruptly:\n\n      (dest.isEternal =\n        source.isEternal !== undefined\n          ? source.isEternal\n          : source.birthTime === undefined || source.deathTime === undefined),\n      (dest.birthTime = source.birthTime),\n      (dest.deathTime = source.deathTime),\n      (dest.propagationTimeFactor = source.propagationTimeFactor !== undefined ? source.propagationTimeFactor : 0.1),\n      (dest.vanishingTimeFactor = source.vanishingTimeFactor !== undefined ? source.vanishingTimeFactor : 0.9),\n      (dest.subrayPeriod = source.subrayPeriod !== undefined ? source.subrayPeriod : 4),\n      (dest.subrayDutyCycle = source.subrayDutyCycle !== undefined ? source.subrayDutyCycle : 0.6)\n\n    // These parameters cannot change after lightning creation:\n\n    dest.maxIterations = source.maxIterations !== undefined ? source.maxIterations : 9\n    dest.isStatic = source.isStatic !== undefined ? source.isStatic : false\n    dest.ramification = source.ramification !== undefined ? source.ramification : 5\n    dest.maxSubrayRecursion = source.maxSubrayRecursion !== undefined ? source.maxSubrayRecursion : 3\n    dest.recursionProbability = source.recursionProbability !== undefined ? source.recursionProbability : 0.6\n    dest.generateUVs = source.generateUVs !== undefined ? source.generateUVs : false\n    ;(dest.randomGenerator = source.randomGenerator),\n      (dest.noiseSeed = source.noiseSeed),\n      (dest.onDecideSubrayCreation = source.onDecideSubrayCreation),\n      (dest.onSubrayCreation = source.onSubrayCreation)\n\n    return dest\n  }\n\n  update(time) {\n    if (this.isStatic) return\n\n    if (\n      this.rayParameters.isEternal ||\n      (this.rayParameters.birthTime <= time && time <= this.rayParameters.deathTime)\n    ) {\n      this.updateMesh(time)\n\n      if (time < this.subrays[0].endPropagationTime) {\n        this.state = LightningStrike.RAY_PROPAGATING\n      } else if (time > this.subrays[0].beginVanishingTime) {\n        this.state = LightningStrike.RAY_VANISHING\n      } else {\n        this.state = LightningStrike.RAY_STEADY\n      }\n\n      this.visible = true\n    } else {\n      this.visible = false\n\n      if (time < this.rayParameters.birthTime) {\n        this.state = LightningStrike.RAY_UNBORN\n      } else {\n        this.state = LightningStrike.RAY_EXTINGUISHED\n      }\n    }\n  }\n\n  init(rayParameters) {\n    // Init all the state from the parameters\n\n    this.rayParameters = rayParameters\n\n    // These parameters cannot change after lightning creation:\n\n    this.maxIterations = rayParameters.maxIterations !== undefined ? Math.floor(rayParameters.maxIterations) : 9\n    rayParameters.maxIterations = this.maxIterations\n    this.isStatic = rayParameters.isStatic !== undefined ? rayParameters.isStatic : false\n    rayParameters.isStatic = this.isStatic\n    this.ramification = rayParameters.ramification !== undefined ? Math.floor(rayParameters.ramification) : 5\n    rayParameters.ramification = this.ramification\n    this.maxSubrayRecursion =\n      rayParameters.maxSubrayRecursion !== undefined ? Math.floor(rayParameters.maxSubrayRecursion) : 3\n    rayParameters.maxSubrayRecursion = this.maxSubrayRecursion\n    this.recursionProbability =\n      rayParameters.recursionProbability !== undefined ? rayParameters.recursionProbability : 0.6\n    rayParameters.recursionProbability = this.recursionProbability\n    this.generateUVs = rayParameters.generateUVs !== undefined ? rayParameters.generateUVs : false\n    rayParameters.generateUVs = this.generateUVs\n\n    // Random generator\n    if (rayParameters.randomGenerator !== undefined) {\n      this.randomGenerator = rayParameters.randomGenerator\n      this.seedGenerator = rayParameters.randomGenerator\n\n      if (rayParameters.noiseSeed !== undefined) {\n        this.seedGenerator.setSeed(rayParameters.noiseSeed)\n      }\n    } else {\n      this.randomGenerator = LightningStrike.createRandomGenerator()\n      this.seedGenerator = Math\n    }\n\n    // Ray creation callbacks\n    if (rayParameters.onDecideSubrayCreation !== undefined) {\n      this.onDecideSubrayCreation = rayParameters.onDecideSubrayCreation\n    } else {\n      this.createDefaultSubrayCreationCallbacks()\n\n      if (rayParameters.onSubrayCreation !== undefined) {\n        this.onSubrayCreation = rayParameters.onSubrayCreation\n      }\n    }\n\n    // Internal state\n\n    this.state = LightningStrike.RAY_INITIALIZED\n\n    this.maxSubrays = Math.ceil(1 + Math.pow(this.ramification, Math.max(0, this.maxSubrayRecursion - 1)))\n    rayParameters.maxSubrays = this.maxSubrays\n\n    this.maxRaySegments = 2 * (1 << this.maxIterations)\n\n    this.subrays = []\n\n    for (let i = 0; i < this.maxSubrays; i++) {\n      this.subrays.push(this.createSubray())\n    }\n\n    this.raySegments = []\n\n    for (let i = 0; i < this.maxRaySegments; i++) {\n      this.raySegments.push(this.createSegment())\n    }\n\n    this.time = 0\n    this.timeFraction = 0\n    this.currentSegmentCallback = null\n    this.currentCreateTriangleVertices = this.generateUVs\n      ? this.createTriangleVerticesWithUVs\n      : this.createTriangleVerticesWithoutUVs\n    this.numSubrays = 0\n    this.currentSubray = null\n    this.currentSegmentIndex = 0\n    this.isInitialSegment = false\n    this.subrayProbability = 0\n\n    this.currentVertex = 0\n    this.currentIndex = 0\n    this.currentCoordinate = 0\n    this.currentUVCoordinate = 0\n    this.vertices = null\n    this.uvs = null\n    this.indices = null\n    this.positionAttribute = null\n    this.uvsAttribute = null\n\n    this.simplexX = new SimplexNoise(this.seedGenerator)\n    this.simplexY = new SimplexNoise(this.seedGenerator)\n    this.simplexZ = new SimplexNoise(this.seedGenerator)\n\n    // Temp vectors\n    this.forwards = new Vector3()\n    this.forwardsFill = new Vector3()\n    this.side = new Vector3()\n    this.down = new Vector3()\n    this.middlePos = new Vector3()\n    this.middleLinPos = new Vector3()\n    this.newPos = new Vector3()\n    this.vPos = new Vector3()\n    this.cross1 = new Vector3()\n  }\n\n  createMesh() {\n    const maxDrawableSegmentsPerSubRay = 1 << this.maxIterations\n\n    const maxVerts = 3 * (maxDrawableSegmentsPerSubRay + 1) * this.maxSubrays\n    const maxIndices = 18 * maxDrawableSegmentsPerSubRay * this.maxSubrays\n\n    this.vertices = new Float32Array(maxVerts * 3)\n    this.indices = new Uint32Array(maxIndices)\n\n    if (this.generateUVs) {\n      this.uvs = new Float32Array(maxVerts * 2)\n    }\n\n    // Populate the mesh\n    this.fillMesh(0)\n\n    this.setIndex(new Uint32BufferAttribute(this.indices, 1))\n\n    this.positionAttribute = new Float32BufferAttribute(this.vertices, 3)\n    this.setAttribute('position', this.positionAttribute)\n\n    if (this.generateUVs) {\n      this.uvsAttribute = new Float32BufferAttribute(new Float32Array(this.uvs), 2)\n      this.setAttribute('uv', this.uvsAttribute)\n    }\n\n    if (!this.isStatic) {\n      this.index.usage = DynamicDrawUsage\n      this.positionAttribute.usage = DynamicDrawUsage\n\n      if (this.generateUVs) {\n        this.uvsAttribute.usage = DynamicDrawUsage\n      }\n    }\n\n    // Store buffers for later modification\n    this.vertices = this.positionAttribute.array\n    this.indices = this.index.array\n\n    if (this.generateUVs) {\n      this.uvs = this.uvsAttribute.array\n    }\n  }\n\n  updateMesh(time) {\n    this.fillMesh(time)\n\n    this.drawRange.count = this.currentIndex\n\n    this.index.needsUpdate = true\n\n    this.positionAttribute.needsUpdate = true\n\n    if (this.generateUVs) {\n      this.uvsAttribute.needsUpdate = true\n    }\n  }\n\n  fillMesh(time) {\n    const scope = this\n\n    this.currentVertex = 0\n    this.currentIndex = 0\n    this.currentCoordinate = 0\n    this.currentUVCoordinate = 0\n\n    this.fractalRay(time, function fillVertices(segment) {\n      const subray = scope.currentSubray\n\n      if (time < subray.birthTime) {\n        //&& ( ! this.rayParameters.isEternal || scope.currentSubray.recursion > 0 ) ) {\n\n        return\n      } else if (this.rayParameters.isEternal && scope.currentSubray.recursion == 0) {\n        // Eternal rays don't propagate nor vanish, but its subrays do\n\n        scope.createPrism(segment)\n\n        scope.onDecideSubrayCreation(segment, scope)\n      } else if (time < subray.endPropagationTime) {\n        if (scope.timeFraction >= segment.fraction0 * subray.propagationTimeFactor) {\n          // Ray propagation has arrived to this segment\n\n          scope.createPrism(segment)\n\n          scope.onDecideSubrayCreation(segment, scope)\n        }\n      } else if (time < subray.beginVanishingTime) {\n        // Ray is steady (nor propagating nor vanishing)\n\n        scope.createPrism(segment)\n\n        scope.onDecideSubrayCreation(segment, scope)\n      } else {\n        if (scope.timeFraction <= subray.vanishingTimeFactor + segment.fraction1 * (1 - subray.vanishingTimeFactor)) {\n          // Segment has not yet vanished\n\n          scope.createPrism(segment)\n        }\n\n        scope.onDecideSubrayCreation(segment, scope)\n      }\n    })\n  }\n\n  addNewSubray(/*rayParameters*/) {\n    return this.subrays[this.numSubrays++]\n  }\n\n  initSubray(subray, rayParameters) {\n    subray.pos0.copy(rayParameters.sourceOffset)\n    subray.pos1.copy(rayParameters.destOffset)\n    subray.up0.copy(rayParameters.up0)\n    subray.up1.copy(rayParameters.up1)\n    subray.radius0 = rayParameters.radius0\n    subray.radius1 = rayParameters.radius1\n    subray.birthTime = rayParameters.birthTime\n    subray.deathTime = rayParameters.deathTime\n    subray.timeScale = rayParameters.timeScale\n    subray.roughness = rayParameters.roughness\n    subray.straightness = rayParameters.straightness\n    subray.propagationTimeFactor = rayParameters.propagationTimeFactor\n    subray.vanishingTimeFactor = rayParameters.vanishingTimeFactor\n\n    subray.maxIterations = this.maxIterations\n    subray.seed = rayParameters.noiseSeed !== undefined ? rayParameters.noiseSeed : 0\n    subray.recursion = 0\n  }\n\n  fractalRay(time, segmentCallback) {\n    this.time = time\n    this.currentSegmentCallback = segmentCallback\n    this.numSubrays = 0\n\n    // Add the top level subray\n    this.initSubray(this.addNewSubray(), this.rayParameters)\n\n    // Process all subrays that are being generated until consuming all of them\n    for (let subrayIndex = 0; subrayIndex < this.numSubrays; subrayIndex++) {\n      const subray = this.subrays[subrayIndex]\n      this.currentSubray = subray\n\n      this.randomGenerator.setSeed(subray.seed)\n\n      subray.endPropagationTime = MathUtils.lerp(subray.birthTime, subray.deathTime, subray.propagationTimeFactor)\n      subray.beginVanishingTime = MathUtils.lerp(subray.deathTime, subray.birthTime, 1 - subray.vanishingTimeFactor)\n\n      const random1 = this.randomGenerator.random\n      subray.linPos0.set(random1(), random1(), random1()).multiplyScalar(1000)\n      subray.linPos1.set(random1(), random1(), random1()).multiplyScalar(1000)\n\n      this.timeFraction = (time - subray.birthTime) / (subray.deathTime - subray.birthTime)\n\n      this.currentSegmentIndex = 0\n      this.isInitialSegment = true\n\n      const segment = this.getNewSegment()\n      segment.iteration = 0\n      segment.pos0.copy(subray.pos0)\n      segment.pos1.copy(subray.pos1)\n      segment.linPos0.copy(subray.linPos0)\n      segment.linPos1.copy(subray.linPos1)\n      segment.up0.copy(subray.up0)\n      segment.up1.copy(subray.up1)\n      segment.radius0 = subray.radius0\n      segment.radius1 = subray.radius1\n      segment.fraction0 = 0\n      segment.fraction1 = 1\n      segment.positionVariationFactor = 1 - subray.straightness\n\n      this.subrayProbability =\n        (this.ramification * Math.pow(this.recursionProbability, subray.recursion)) / (1 << subray.maxIterations)\n\n      this.fractalRayRecursive(segment)\n    }\n\n    this.currentSegmentCallback = null\n    this.currentSubray = null\n  }\n\n  fractalRayRecursive(segment) {\n    // Leave recursion condition\n    if (segment.iteration >= this.currentSubray.maxIterations) {\n      this.currentSegmentCallback(segment)\n\n      return\n    }\n\n    // Interpolation\n    this.forwards.subVectors(segment.pos1, segment.pos0)\n    let lForwards = this.forwards.length()\n\n    if (lForwards < 0.000001) {\n      this.forwards.set(0, 0, 0.01)\n      lForwards = this.forwards.length()\n    }\n\n    const middleRadius = (segment.radius0 + segment.radius1) * 0.5\n    const middleFraction = (segment.fraction0 + segment.fraction1) * 0.5\n\n    const timeDimension = this.time * this.currentSubray.timeScale * Math.pow(2, segment.iteration)\n\n    this.middlePos.lerpVectors(segment.pos0, segment.pos1, 0.5)\n    this.middleLinPos.lerpVectors(segment.linPos0, segment.linPos1, 0.5)\n    const p = this.middleLinPos\n\n    // Noise\n    this.newPos.set(\n      this.simplexX.noise4d(p.x, p.y, p.z, timeDimension),\n      this.simplexY.noise4d(p.x, p.y, p.z, timeDimension),\n      this.simplexZ.noise4d(p.x, p.y, p.z, timeDimension),\n    )\n\n    this.newPos.multiplyScalar(segment.positionVariationFactor * lForwards)\n    this.newPos.add(this.middlePos)\n\n    // Recursion\n\n    const newSegment1 = this.getNewSegment()\n    newSegment1.pos0.copy(segment.pos0)\n    newSegment1.pos1.copy(this.newPos)\n    newSegment1.linPos0.copy(segment.linPos0)\n    newSegment1.linPos1.copy(this.middleLinPos)\n    newSegment1.up0.copy(segment.up0)\n    newSegment1.up1.copy(segment.up1)\n    newSegment1.radius0 = segment.radius0\n    newSegment1.radius1 = middleRadius\n    newSegment1.fraction0 = segment.fraction0\n    newSegment1.fraction1 = middleFraction\n    newSegment1.positionVariationFactor = segment.positionVariationFactor * this.currentSubray.roughness\n    newSegment1.iteration = segment.iteration + 1\n\n    const newSegment2 = this.getNewSegment()\n    newSegment2.pos0.copy(this.newPos)\n    newSegment2.pos1.copy(segment.pos1)\n    newSegment2.linPos0.copy(this.middleLinPos)\n    newSegment2.linPos1.copy(segment.linPos1)\n    this.cross1.crossVectors(segment.up0, this.forwards.normalize())\n    newSegment2.up0.crossVectors(this.forwards, this.cross1).normalize()\n    newSegment2.up1.copy(segment.up1)\n    newSegment2.radius0 = middleRadius\n    newSegment2.radius1 = segment.radius1\n    newSegment2.fraction0 = middleFraction\n    newSegment2.fraction1 = segment.fraction1\n    newSegment2.positionVariationFactor = segment.positionVariationFactor * this.currentSubray.roughness\n    newSegment2.iteration = segment.iteration + 1\n\n    this.fractalRayRecursive(newSegment1)\n\n    this.fractalRayRecursive(newSegment2)\n  }\n\n  createPrism(segment) {\n    // Creates one triangular prism and its vertices at the segment\n\n    this.forwardsFill.subVectors(segment.pos1, segment.pos0).normalize()\n\n    if (this.isInitialSegment) {\n      this.currentCreateTriangleVertices(segment.pos0, segment.up0, this.forwardsFill, segment.radius0, 0)\n\n      this.isInitialSegment = false\n    }\n\n    this.currentCreateTriangleVertices(segment.pos1, segment.up0, this.forwardsFill, segment.radius1, segment.fraction1)\n\n    this.createPrismFaces()\n  }\n\n  createTriangleVerticesWithoutUVs(pos, up, forwards, radius) {\n    // Create an equilateral triangle (only vertices)\n\n    this.side.crossVectors(up, forwards).multiplyScalar(radius * LightningStrike.COS30DEG)\n    this.down.copy(up).multiplyScalar(-radius * LightningStrike.SIN30DEG)\n\n    const p = this.vPos\n    const v = this.vertices\n\n    p.copy(pos).sub(this.side).add(this.down)\n\n    v[this.currentCoordinate++] = p.x\n    v[this.currentCoordinate++] = p.y\n    v[this.currentCoordinate++] = p.z\n\n    p.copy(pos).add(this.side).add(this.down)\n\n    v[this.currentCoordinate++] = p.x\n    v[this.currentCoordinate++] = p.y\n    v[this.currentCoordinate++] = p.z\n\n    p.copy(up).multiplyScalar(radius).add(pos)\n\n    v[this.currentCoordinate++] = p.x\n    v[this.currentCoordinate++] = p.y\n    v[this.currentCoordinate++] = p.z\n\n    this.currentVertex += 3\n  }\n\n  createTriangleVerticesWithUVs(pos, up, forwards, radius, u) {\n    // Create an equilateral triangle (only vertices)\n\n    this.side.crossVectors(up, forwards).multiplyScalar(radius * LightningStrike.COS30DEG)\n    this.down.copy(up).multiplyScalar(-radius * LightningStrike.SIN30DEG)\n\n    const p = this.vPos\n    const v = this.vertices\n    const uv = this.uvs\n\n    p.copy(pos).sub(this.side).add(this.down)\n\n    v[this.currentCoordinate++] = p.x\n    v[this.currentCoordinate++] = p.y\n    v[this.currentCoordinate++] = p.z\n\n    uv[this.currentUVCoordinate++] = u\n    uv[this.currentUVCoordinate++] = 0\n\n    p.copy(pos).add(this.side).add(this.down)\n\n    v[this.currentCoordinate++] = p.x\n    v[this.currentCoordinate++] = p.y\n    v[this.currentCoordinate++] = p.z\n\n    uv[this.currentUVCoordinate++] = u\n    uv[this.currentUVCoordinate++] = 0.5\n\n    p.copy(up).multiplyScalar(radius).add(pos)\n\n    v[this.currentCoordinate++] = p.x\n    v[this.currentCoordinate++] = p.y\n    v[this.currentCoordinate++] = p.z\n\n    uv[this.currentUVCoordinate++] = u\n    uv[this.currentUVCoordinate++] = 1\n\n    this.currentVertex += 3\n  }\n\n  createPrismFaces(vertex /*, index*/) {\n    const indices = this.indices\n    vertex = this.currentVertex - 6\n\n    indices[this.currentIndex++] = vertex + 1\n    indices[this.currentIndex++] = vertex + 2\n    indices[this.currentIndex++] = vertex + 5\n    indices[this.currentIndex++] = vertex + 1\n    indices[this.currentIndex++] = vertex + 5\n    indices[this.currentIndex++] = vertex + 4\n    indices[this.currentIndex++] = vertex + 0\n    indices[this.currentIndex++] = vertex + 1\n    indices[this.currentIndex++] = vertex + 4\n    indices[this.currentIndex++] = vertex + 0\n    indices[this.currentIndex++] = vertex + 4\n    indices[this.currentIndex++] = vertex + 3\n    indices[this.currentIndex++] = vertex + 2\n    indices[this.currentIndex++] = vertex + 0\n    indices[this.currentIndex++] = vertex + 3\n    indices[this.currentIndex++] = vertex + 2\n    indices[this.currentIndex++] = vertex + 3\n    indices[this.currentIndex++] = vertex + 5\n  }\n\n  createDefaultSubrayCreationCallbacks() {\n    const random1 = this.randomGenerator.random\n\n    this.onDecideSubrayCreation = function (segment, lightningStrike) {\n      // Decide subrays creation at parent (sub)ray segment\n\n      const subray = lightningStrike.currentSubray\n\n      const period = lightningStrike.rayParameters.subrayPeriod\n      const dutyCycle = lightningStrike.rayParameters.subrayDutyCycle\n\n      const phase0 =\n        lightningStrike.rayParameters.isEternal && subray.recursion == 0\n          ? -random1() * period\n          : MathUtils.lerp(subray.birthTime, subray.endPropagationTime, segment.fraction0) - random1() * period\n\n      const phase = lightningStrike.time - phase0\n      const currentCycle = Math.floor(phase / period)\n\n      const childSubraySeed = random1() * (currentCycle + 1)\n\n      const isActive = phase % period <= dutyCycle * period\n\n      let probability = 0\n\n      if (isActive) {\n        probability = lightningStrike.subrayProbability\n        // Distribution test: probability *= segment.fraction0 > 0.5 && segment.fraction0 < 0.9 ? 1 / 0.4 : 0;\n      }\n\n      if (\n        subray.recursion < lightningStrike.maxSubrayRecursion &&\n        lightningStrike.numSubrays < lightningStrike.maxSubrays &&\n        random1() < probability\n      ) {\n        const childSubray = lightningStrike.addNewSubray()\n\n        const parentSeed = lightningStrike.randomGenerator.getSeed()\n        childSubray.seed = childSubraySeed\n        lightningStrike.randomGenerator.setSeed(childSubraySeed)\n\n        childSubray.recursion = subray.recursion + 1\n        childSubray.maxIterations = Math.max(1, subray.maxIterations - 1)\n\n        childSubray.linPos0.set(random1(), random1(), random1()).multiplyScalar(1000)\n        childSubray.linPos1.set(random1(), random1(), random1()).multiplyScalar(1000)\n        childSubray.up0.copy(subray.up0)\n        childSubray.up1.copy(subray.up1)\n        childSubray.radius0 = segment.radius0 * lightningStrike.rayParameters.radius0Factor\n        childSubray.radius1 = Math.min(\n          lightningStrike.rayParameters.minRadius,\n          segment.radius1 * lightningStrike.rayParameters.radius1Factor,\n        )\n\n        childSubray.birthTime = phase0 + currentCycle * period\n        childSubray.deathTime = childSubray.birthTime + period * dutyCycle\n\n        if (!lightningStrike.rayParameters.isEternal && subray.recursion == 0) {\n          childSubray.birthTime = Math.max(childSubray.birthTime, subray.birthTime)\n          childSubray.deathTime = Math.min(childSubray.deathTime, subray.deathTime)\n        }\n\n        childSubray.timeScale = subray.timeScale * 2\n        childSubray.roughness = subray.roughness\n        childSubray.straightness = subray.straightness\n        childSubray.propagationTimeFactor = subray.propagationTimeFactor\n        childSubray.vanishingTimeFactor = subray.vanishingTimeFactor\n\n        lightningStrike.onSubrayCreation(segment, subray, childSubray, lightningStrike)\n\n        lightningStrike.randomGenerator.setSeed(parentSeed)\n      }\n    }\n\n    const vec1Pos = new Vector3()\n    const vec2Forward = new Vector3()\n    const vec3Side = new Vector3()\n    const vec4Up = new Vector3()\n\n    this.onSubrayCreation = function (segment, parentSubray, childSubray, lightningStrike) {\n      // Decide childSubray origin and destination positions (pos0 and pos1) and possibly other properties of childSubray\n\n      // Just use the default cone position generator\n      lightningStrike.subrayCylinderPosition(segment, parentSubray, childSubray, 0.5, 0.6, 0.2)\n    }\n\n    this.subrayConePosition = function (\n      segment,\n      parentSubray,\n      childSubray,\n      heightFactor,\n      sideWidthFactor,\n      minSideWidthFactor,\n    ) {\n      // Sets childSubray pos0 and pos1 in a cone\n\n      childSubray.pos0.copy(segment.pos0)\n\n      vec1Pos.subVectors(parentSubray.pos1, parentSubray.pos0)\n      vec2Forward.copy(vec1Pos).normalize()\n      vec1Pos.multiplyScalar(segment.fraction0 + (1 - segment.fraction0) * (random1() * heightFactor))\n      const length = vec1Pos.length()\n      vec3Side.crossVectors(parentSubray.up0, vec2Forward)\n      const angle = 2 * Math.PI * random1()\n      vec3Side.multiplyScalar(Math.cos(angle))\n      vec4Up.copy(parentSubray.up0).multiplyScalar(Math.sin(angle))\n\n      childSubray.pos1\n        .copy(vec3Side)\n        .add(vec4Up)\n        .multiplyScalar(length * sideWidthFactor * (minSideWidthFactor + random1() * (1 - minSideWidthFactor)))\n        .add(vec1Pos)\n        .add(parentSubray.pos0)\n    }\n\n    this.subrayCylinderPosition = function (\n      segment,\n      parentSubray,\n      childSubray,\n      heightFactor,\n      sideWidthFactor,\n      minSideWidthFactor,\n    ) {\n      // Sets childSubray pos0 and pos1 in a cylinder\n\n      childSubray.pos0.copy(segment.pos0)\n\n      vec1Pos.subVectors(parentSubray.pos1, parentSubray.pos0)\n      vec2Forward.copy(vec1Pos).normalize()\n      vec1Pos.multiplyScalar(segment.fraction0 + (1 - segment.fraction0) * ((2 * random1() - 1) * heightFactor))\n      const length = vec1Pos.length()\n      vec3Side.crossVectors(parentSubray.up0, vec2Forward)\n      const angle = 2 * Math.PI * random1()\n      vec3Side.multiplyScalar(Math.cos(angle))\n      vec4Up.copy(parentSubray.up0).multiplyScalar(Math.sin(angle))\n\n      childSubray.pos1\n        .copy(vec3Side)\n        .add(vec4Up)\n        .multiplyScalar(length * sideWidthFactor * (minSideWidthFactor + random1() * (1 - minSideWidthFactor)))\n        .add(vec1Pos)\n        .add(parentSubray.pos0)\n    }\n  }\n\n  createSubray() {\n    return {\n      seed: 0,\n      maxIterations: 0,\n      recursion: 0,\n      pos0: new Vector3(),\n      pos1: new Vector3(),\n      linPos0: new Vector3(),\n      linPos1: new Vector3(),\n      up0: new Vector3(),\n      up1: new Vector3(),\n      radius0: 0,\n      radius1: 0,\n      birthTime: 0,\n      deathTime: 0,\n      timeScale: 0,\n      roughness: 0,\n      straightness: 0,\n      propagationTimeFactor: 0,\n      vanishingTimeFactor: 0,\n      endPropagationTime: 0,\n      beginVanishingTime: 0,\n    }\n  }\n\n  createSegment() {\n    return {\n      iteration: 0,\n      pos0: new Vector3(),\n      pos1: new Vector3(),\n      linPos0: new Vector3(),\n      linPos1: new Vector3(),\n      up0: new Vector3(),\n      up1: new Vector3(),\n      radius0: 0,\n      radius1: 0,\n      fraction0: 0,\n      fraction1: 0,\n      positionVariationFactor: 0,\n    }\n  }\n\n  getNewSegment() {\n    return this.raySegments[this.currentSegmentIndex++]\n  }\n\n  copy(source) {\n    super.copy(source)\n\n    this.init(LightningStrike.copyParameters({}, source.rayParameters))\n\n    return this\n  }\n\n  clone() {\n    return new this.constructor(LightningStrike.copyParameters({}, this.rayParameters))\n  }\n}\n\nexport { LightningStrike }\n"],"names":[],"mappings":"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"}