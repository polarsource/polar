{"version":3,"file":"BasisTextureLoader.js","sources":["../../src/loaders/BasisTextureLoader.js"],"sourcesContent":["import {\n  CompressedTexture,\n  FileLoader,\n  LinearFilter,\n  LinearMipmapLinearFilter,\n  Loader,\n  RGBAFormat,\n  RGBA_ASTC_4x4_Format,\n  RGBA_BPTC_Format,\n  RGBA_ETC2_EAC_Format,\n  RGBA_PVRTC_4BPPV1_Format,\n  RGBA_S3TC_DXT5_Format,\n  RGB_ETC1_Format,\n  RGB_ETC2_Format,\n  RGB_PVRTC_4BPPV1_Format,\n  RGB_S3TC_DXT1_Format,\n  UnsignedByteType,\n} from 'three'\n\n/**\n * Loader for Basis Universal GPU Texture Codec.\n *\n * Basis Universal is a \"supercompressed\" GPU texture and texture video\n * compression system that outputs a highly compressed intermediate file format\n * (.basis) that can be quickly transcoded to a wide variety of GPU texture\n * compression formats.\n *\n * This loader parallelizes the transcoding process across a configurable number\n * of web workers, before transferring the transcoded compressed texture back\n * to the main thread.\n */\n\nconst _taskCache = new WeakMap()\n\nclass BasisTextureLoader extends Loader {\n  /* CONSTANTS */\n\n  static BasisFormat = {\n    ETC1S: 0,\n    UASTC_4x4: 1,\n  }\n\n  static TranscoderFormat = {\n    ETC1: 0,\n    ETC2: 1,\n    BC1: 2,\n    BC3: 3,\n    BC4: 4,\n    BC5: 5,\n    BC7_M6_OPAQUE_ONLY: 6,\n    BC7_M5: 7,\n    PVRTC1_4_RGB: 8,\n    PVRTC1_4_RGBA: 9,\n    ASTC_4x4: 10,\n    ATC_RGB: 11,\n    ATC_RGBA_INTERPOLATED_ALPHA: 12,\n    RGBA32: 13,\n    RGB565: 14,\n    BGR565: 15,\n    RGBA4444: 16,\n  }\n\n  static EngineFormat = {\n    RGBAFormat: RGBAFormat,\n    RGBA_ASTC_4x4_Format: RGBA_ASTC_4x4_Format,\n    RGBA_BPTC_Format: RGBA_BPTC_Format,\n    RGBA_ETC2_EAC_Format: RGBA_ETC2_EAC_Format,\n    RGBA_PVRTC_4BPPV1_Format: RGBA_PVRTC_4BPPV1_Format,\n    RGBA_S3TC_DXT5_Format: RGBA_S3TC_DXT5_Format,\n    RGB_ETC1_Format: RGB_ETC1_Format,\n    RGB_ETC2_Format: RGB_ETC2_Format,\n    RGB_PVRTC_4BPPV1_Format: RGB_PVRTC_4BPPV1_Format,\n    RGB_S3TC_DXT1_Format: RGB_S3TC_DXT1_Format,\n  }\n\n  /* WEB WORKER */\n\n  static BasisWorker = function () {\n    let config\n    let transcoderPending\n    let BasisModule\n\n    const EngineFormat = _EngineFormat\n    const TranscoderFormat = _TranscoderFormat\n    const BasisFormat = _BasisFormat\n\n    onmessage = function (e) {\n      const message = e.data\n\n      switch (message.type) {\n        case 'init':\n          config = message.config\n          init(message.transcoderBinary)\n          break\n\n        case 'transcode':\n          transcoderPending.then(() => {\n            try {\n              const { width, height, hasAlpha, mipmaps, format } = message.taskConfig.lowLevel\n                ? transcodeLowLevel(message.taskConfig)\n                : transcode(message.buffers[0])\n\n              const buffers = []\n\n              for (let i = 0; i < mipmaps.length; ++i) {\n                buffers.push(mipmaps[i].data.buffer)\n              }\n\n              self.postMessage({ type: 'transcode', id: message.id, width, height, hasAlpha, mipmaps, format }, buffers)\n            } catch (error) {\n              console.error(error)\n\n              self.postMessage({ type: 'error', id: message.id, error: error.message })\n            }\n          })\n          break\n      }\n    }\n\n    function init(wasmBinary) {\n      transcoderPending = new Promise((resolve) => {\n        BasisModule = { wasmBinary, onRuntimeInitialized: resolve }\n        BASIS(BasisModule)\n      }).then(() => {\n        BasisModule.initializeBasis()\n      })\n    }\n\n    function transcodeLowLevel(taskConfig) {\n      const { basisFormat, width, height, hasAlpha } = taskConfig\n\n      const { transcoderFormat, engineFormat } = getTranscoderFormat(basisFormat, width, height, hasAlpha)\n\n      const blockByteLength = BasisModule.getBytesPerBlockOrPixel(transcoderFormat)\n\n      assert(BasisModule.isFormatSupported(transcoderFormat), 'THREE.BasisTextureLoader: Unsupported format.')\n\n      const mipmaps = []\n\n      if (basisFormat === BasisFormat.ETC1S) {\n        const transcoder = new BasisModule.LowLevelETC1SImageTranscoder()\n\n        const { endpointCount, endpointsData, selectorCount, selectorsData, tablesData } = taskConfig.globalData\n\n        try {\n          let ok\n\n          ok = transcoder.decodePalettes(endpointCount, endpointsData, selectorCount, selectorsData)\n\n          assert(ok, 'THREE.BasisTextureLoader: decodePalettes() failed.')\n\n          ok = transcoder.decodeTables(tablesData)\n\n          assert(ok, 'THREE.BasisTextureLoader: decodeTables() failed.')\n\n          for (let i = 0; i < taskConfig.levels.length; i++) {\n            const level = taskConfig.levels[i]\n            const imageDesc = taskConfig.globalData.imageDescs[i]\n\n            const dstByteLength = getTranscodedImageByteLength(transcoderFormat, level.width, level.height)\n            const dst = new Uint8Array(dstByteLength)\n\n            ok = transcoder.transcodeImage(\n              transcoderFormat,\n              dst,\n              dstByteLength / blockByteLength,\n              level.data,\n              getWidthInBlocks(transcoderFormat, level.width),\n              getHeightInBlocks(transcoderFormat, level.height),\n              level.width,\n              level.height,\n              level.index,\n              imageDesc.rgbSliceByteOffset,\n              imageDesc.rgbSliceByteLength,\n              imageDesc.alphaSliceByteOffset,\n              imageDesc.alphaSliceByteLength,\n              imageDesc.imageFlags,\n              hasAlpha,\n              false,\n              0,\n              0,\n            )\n\n            assert(ok, 'THREE.BasisTextureLoader: transcodeImage() failed for level ' + level.index + '.')\n\n            mipmaps.push({ data: dst, width: level.width, height: level.height })\n          }\n        } finally {\n          transcoder.delete()\n        }\n      } else {\n        for (let i = 0; i < taskConfig.levels.length; i++) {\n          const level = taskConfig.levels[i]\n\n          const dstByteLength = getTranscodedImageByteLength(transcoderFormat, level.width, level.height)\n          const dst = new Uint8Array(dstByteLength)\n\n          const ok = BasisModule.transcodeUASTCImage(\n            transcoderFormat,\n            dst,\n            dstByteLength / blockByteLength,\n            level.data,\n            getWidthInBlocks(transcoderFormat, level.width),\n            getHeightInBlocks(transcoderFormat, level.height),\n            level.width,\n            level.height,\n            level.index,\n            0,\n            level.data.byteLength,\n            0,\n            hasAlpha,\n            false,\n            0,\n            0,\n            -1,\n            -1,\n          )\n\n          assert(ok, 'THREE.BasisTextureLoader: transcodeUASTCImage() failed for level ' + level.index + '.')\n\n          mipmaps.push({ data: dst, width: level.width, height: level.height })\n        }\n      }\n\n      return { width, height, hasAlpha, mipmaps, format: engineFormat }\n    }\n\n    function transcode(buffer) {\n      const basisFile = new BasisModule.BasisFile(new Uint8Array(buffer))\n\n      const basisFormat = basisFile.isUASTC() ? BasisFormat.UASTC_4x4 : BasisFormat.ETC1S\n      const width = basisFile.getImageWidth(0, 0)\n      const height = basisFile.getImageHeight(0, 0)\n      const levels = basisFile.getNumLevels(0)\n      const hasAlpha = basisFile.getHasAlpha()\n\n      function cleanup() {\n        basisFile.close()\n        basisFile.delete()\n      }\n\n      const { transcoderFormat, engineFormat } = getTranscoderFormat(basisFormat, width, height, hasAlpha)\n\n      if (!width || !height || !levels) {\n        cleanup()\n        throw new Error('THREE.BasisTextureLoader:\tInvalid texture')\n      }\n\n      if (!basisFile.startTranscoding()) {\n        cleanup()\n        throw new Error('THREE.BasisTextureLoader: .startTranscoding failed')\n      }\n\n      const mipmaps = []\n\n      for (let mip = 0; mip < levels; mip++) {\n        const mipWidth = basisFile.getImageWidth(0, mip)\n        const mipHeight = basisFile.getImageHeight(0, mip)\n        const dst = new Uint8Array(basisFile.getImageTranscodedSizeInBytes(0, mip, transcoderFormat))\n\n        const status = basisFile.transcodeImage(dst, 0, mip, transcoderFormat, 0, hasAlpha)\n\n        if (!status) {\n          cleanup()\n          throw new Error('THREE.BasisTextureLoader: .transcodeImage failed.')\n        }\n\n        mipmaps.push({ data: dst, width: mipWidth, height: mipHeight })\n      }\n\n      cleanup()\n\n      return { width, height, hasAlpha, mipmaps, format: engineFormat }\n    }\n\n    //\n\n    // Optimal choice of a transcoder target format depends on the Basis format (ETC1S or UASTC),\n    // device capabilities, and texture dimensions. The list below ranks the formats separately\n    // for ETC1S and UASTC.\n    //\n    // In some cases, transcoding UASTC to RGBA32 might be preferred for higher quality (at\n    // significant memory cost) compared to ETC1/2, BC1/3, and PVRTC. The transcoder currently\n    // chooses RGBA32 only as a last resort and does not expose that option to the caller.\n    const FORMAT_OPTIONS = [\n      {\n        if: 'astcSupported',\n        basisFormat: [BasisFormat.UASTC_4x4],\n        transcoderFormat: [TranscoderFormat.ASTC_4x4, TranscoderFormat.ASTC_4x4],\n        engineFormat: [EngineFormat.RGBA_ASTC_4x4_Format, EngineFormat.RGBA_ASTC_4x4_Format],\n        priorityETC1S: Infinity,\n        priorityUASTC: 1,\n        needsPowerOfTwo: false,\n      },\n      {\n        if: 'bptcSupported',\n        basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],\n        transcoderFormat: [TranscoderFormat.BC7_M5, TranscoderFormat.BC7_M5],\n        engineFormat: [EngineFormat.RGBA_BPTC_Format, EngineFormat.RGBA_BPTC_Format],\n        priorityETC1S: 3,\n        priorityUASTC: 2,\n        needsPowerOfTwo: false,\n      },\n      {\n        if: 'dxtSupported',\n        basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],\n        transcoderFormat: [TranscoderFormat.BC1, TranscoderFormat.BC3],\n        engineFormat: [EngineFormat.RGB_S3TC_DXT1_Format, EngineFormat.RGBA_S3TC_DXT5_Format],\n        priorityETC1S: 4,\n        priorityUASTC: 5,\n        needsPowerOfTwo: false,\n      },\n      {\n        if: 'etc2Supported',\n        basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],\n        transcoderFormat: [TranscoderFormat.ETC1, TranscoderFormat.ETC2],\n        engineFormat: [EngineFormat.RGB_ETC2_Format, EngineFormat.RGBA_ETC2_EAC_Format],\n        priorityETC1S: 1,\n        priorityUASTC: 3,\n        needsPowerOfTwo: false,\n      },\n      {\n        if: 'etc1Supported',\n        basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],\n        transcoderFormat: [TranscoderFormat.ETC1, TranscoderFormat.ETC1],\n        engineFormat: [EngineFormat.RGB_ETC1_Format, EngineFormat.RGB_ETC1_Format],\n        priorityETC1S: 2,\n        priorityUASTC: 4,\n        needsPowerOfTwo: false,\n      },\n      {\n        if: 'pvrtcSupported',\n        basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],\n        transcoderFormat: [TranscoderFormat.PVRTC1_4_RGB, TranscoderFormat.PVRTC1_4_RGBA],\n        engineFormat: [EngineFormat.RGB_PVRTC_4BPPV1_Format, EngineFormat.RGBA_PVRTC_4BPPV1_Format],\n        priorityETC1S: 5,\n        priorityUASTC: 6,\n        needsPowerOfTwo: true,\n      },\n    ]\n\n    const ETC1S_OPTIONS = FORMAT_OPTIONS.sort(function (a, b) {\n      return a.priorityETC1S - b.priorityETC1S\n    })\n    const UASTC_OPTIONS = FORMAT_OPTIONS.sort(function (a, b) {\n      return a.priorityUASTC - b.priorityUASTC\n    })\n\n    function getTranscoderFormat(basisFormat, width, height, hasAlpha) {\n      let transcoderFormat\n      let engineFormat\n\n      const options = basisFormat === BasisFormat.ETC1S ? ETC1S_OPTIONS : UASTC_OPTIONS\n\n      for (let i = 0; i < options.length; i++) {\n        const opt = options[i]\n\n        if (!config[opt.if]) continue\n        if (!opt.basisFormat.includes(basisFormat)) continue\n        if (opt.needsPowerOfTwo && !(isPowerOfTwo(width) && isPowerOfTwo(height))) continue\n\n        transcoderFormat = opt.transcoderFormat[hasAlpha ? 1 : 0]\n        engineFormat = opt.engineFormat[hasAlpha ? 1 : 0]\n\n        return { transcoderFormat, engineFormat }\n      }\n\n      console.warn('THREE.BasisTextureLoader: No suitable compressed texture format found. Decoding to RGBA32.')\n\n      transcoderFormat = TranscoderFormat.RGBA32\n      engineFormat = EngineFormat.RGBAFormat\n\n      return { transcoderFormat, engineFormat }\n    }\n\n    function assert(ok, message) {\n      if (!ok) throw new Error(message)\n    }\n\n    function getWidthInBlocks(transcoderFormat, width) {\n      return Math.ceil(width / BasisModule.getFormatBlockWidth(transcoderFormat))\n    }\n\n    function getHeightInBlocks(transcoderFormat, height) {\n      return Math.ceil(height / BasisModule.getFormatBlockHeight(transcoderFormat))\n    }\n\n    function getTranscodedImageByteLength(transcoderFormat, width, height) {\n      const blockByteLength = BasisModule.getBytesPerBlockOrPixel(transcoderFormat)\n\n      if (BasisModule.formatIsUncompressed(transcoderFormat)) {\n        return width * height * blockByteLength\n      }\n\n      if (transcoderFormat === TranscoderFormat.PVRTC1_4_RGB || transcoderFormat === TranscoderFormat.PVRTC1_4_RGBA) {\n        // GL requires extra padding for very small textures:\n        // https://www.khronos.org/registry/OpenGL/extensions/IMG/IMG_texture_compression_pvrtc.txt\n        const paddedWidth = (width + 3) & ~3\n        const paddedHeight = (height + 3) & ~3\n\n        return (Math.max(8, paddedWidth) * Math.max(8, paddedHeight) * 4 + 7) / 8\n      }\n\n      return getWidthInBlocks(transcoderFormat, width) * getHeightInBlocks(transcoderFormat, height) * blockByteLength\n    }\n\n    function isPowerOfTwo(value) {\n      if (value <= 2) return true\n\n      return (value & (value - 1)) === 0 && value !== 0\n    }\n  }\n\n  constructor(manager) {\n    super(manager)\n\n    this.transcoderPath = ''\n    this.transcoderBinary = null\n    this.transcoderPending = null\n\n    this.workerLimit = 4\n    this.workerPool = []\n    this.workerNextTaskID = 1\n    this.workerSourceURL = ''\n    this.workerConfig = null\n  }\n\n  setTranscoderPath(path) {\n    this.transcoderPath = path\n\n    return this\n  }\n\n  setWorkerLimit(workerLimit) {\n    this.workerLimit = workerLimit\n\n    return this\n  }\n\n  detectSupport(renderer) {\n    this.workerConfig = {\n      astcSupported: renderer.extensions.has('WEBGL_compressed_texture_astc'),\n      etc1Supported: renderer.extensions.has('WEBGL_compressed_texture_etc1'),\n      etc2Supported: renderer.extensions.has('WEBGL_compressed_texture_etc'),\n      dxtSupported: renderer.extensions.has('WEBGL_compressed_texture_s3tc'),\n      bptcSupported: renderer.extensions.has('EXT_texture_compression_bptc'),\n      pvrtcSupported:\n        renderer.extensions.has('WEBGL_compressed_texture_pvrtc') ||\n        renderer.extensions.has('WEBKIT_WEBGL_compressed_texture_pvrtc'),\n    }\n\n    return this\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    const loader = new FileLoader(this.manager)\n\n    loader.setResponseType('arraybuffer')\n    loader.setWithCredentials(this.withCredentials)\n\n    const texture = new CompressedTexture()\n\n    loader.load(\n      url,\n      (buffer) => {\n        // Check for an existing task using this buffer. A transferred buffer cannot be transferred\n        // again from this thread.\n        if (_taskCache.has(buffer)) {\n          const cachedTask = _taskCache.get(buffer)\n\n          return cachedTask.promise.then(onLoad).catch(onError)\n        }\n\n        this._createTexture([buffer])\n          .then(function (_texture) {\n            texture.copy(_texture)\n            texture.needsUpdate = true\n\n            if (onLoad) onLoad(texture)\n          })\n          .catch(onError)\n      },\n      onProgress,\n      onError,\n    )\n\n    return texture\n  }\n\n  /** Low-level transcoding API, exposed for use by KTX2Loader. */\n  parseInternalAsync(options) {\n    const { levels } = options\n\n    const buffers = new Set()\n\n    for (let i = 0; i < levels.length; i++) {\n      buffers.add(levels[i].data.buffer)\n    }\n\n    return this._createTexture(Array.from(buffers), { ...options, lowLevel: true })\n  }\n\n  /**\n   * @param {ArrayBuffer[]} buffers\n   * @param {object?} config\n   * @return {Promise<CompressedTexture>}\n   */\n  _createTexture(buffers, config = {}) {\n    let worker\n    let taskID\n\n    const taskConfig = config\n    let taskCost = 0\n\n    for (let i = 0; i < buffers.length; i++) {\n      taskCost += buffers[i].byteLength\n    }\n\n    const texturePending = this._allocateWorker(taskCost)\n      .then((_worker) => {\n        worker = _worker\n        taskID = this.workerNextTaskID++\n\n        return new Promise((resolve, reject) => {\n          worker._callbacks[taskID] = { resolve, reject }\n\n          worker.postMessage({ type: 'transcode', id: taskID, buffers: buffers, taskConfig: taskConfig }, buffers)\n        })\n      })\n      .then((message) => {\n        const { mipmaps, width, height, format } = message\n\n        const texture = new CompressedTexture(mipmaps, width, height, format, UnsignedByteType)\n        texture.minFilter = mipmaps.length === 1 ? LinearFilter : LinearMipmapLinearFilter\n        texture.magFilter = LinearFilter\n        texture.generateMipmaps = false\n        texture.needsUpdate = true\n\n        return texture\n      })\n\n    // Note: replaced '.finally()' with '.catch().then()' block - iOS 11 support (#19416)\n    texturePending\n      .catch(() => true)\n      .then(() => {\n        if (worker && taskID) {\n          worker._taskLoad -= taskCost\n          delete worker._callbacks[taskID]\n        }\n      })\n\n    // Cache the task result.\n    _taskCache.set(buffers[0], { promise: texturePending })\n\n    return texturePending\n  }\n\n  _initTranscoder() {\n    if (!this.transcoderPending) {\n      // Load transcoder wrapper.\n      const jsLoader = new FileLoader(this.manager)\n      jsLoader.setPath(this.transcoderPath)\n      jsLoader.setWithCredentials(this.withCredentials)\n      const jsContent = new Promise((resolve, reject) => {\n        jsLoader.load('basis_transcoder.js', resolve, undefined, reject)\n      })\n\n      // Load transcoder WASM binary.\n      const binaryLoader = new FileLoader(this.manager)\n      binaryLoader.setPath(this.transcoderPath)\n      binaryLoader.setResponseType('arraybuffer')\n      binaryLoader.setWithCredentials(this.withCredentials)\n      const binaryContent = new Promise((resolve, reject) => {\n        binaryLoader.load('basis_transcoder.wasm', resolve, undefined, reject)\n      })\n\n      this.transcoderPending = Promise.all([jsContent, binaryContent]).then(([jsContent, binaryContent]) => {\n        const fn = BasisTextureLoader.BasisWorker.toString()\n\n        const body = [\n          '/* constants */',\n          'let _EngineFormat = ' + JSON.stringify(BasisTextureLoader.EngineFormat),\n          'let _TranscoderFormat = ' + JSON.stringify(BasisTextureLoader.TranscoderFormat),\n          'let _BasisFormat = ' + JSON.stringify(BasisTextureLoader.BasisFormat),\n          '/* basis_transcoder.js */',\n          jsContent,\n          '/* worker */',\n          fn.substring(fn.indexOf('{') + 1, fn.lastIndexOf('}')),\n        ].join('\\n')\n\n        this.workerSourceURL = URL.createObjectURL(new Blob([body]))\n        this.transcoderBinary = binaryContent\n      })\n    }\n\n    return this.transcoderPending\n  }\n\n  _allocateWorker(taskCost) {\n    return this._initTranscoder().then(() => {\n      if (this.workerPool.length < this.workerLimit) {\n        const worker = new Worker(this.workerSourceURL)\n\n        worker._callbacks = {}\n        worker._taskLoad = 0\n\n        worker.postMessage({\n          type: 'init',\n          config: this.workerConfig,\n          transcoderBinary: this.transcoderBinary,\n        })\n\n        worker.onmessage = function (e) {\n          const message = e.data\n\n          switch (message.type) {\n            case 'transcode':\n              worker._callbacks[message.id].resolve(message)\n              break\n\n            case 'error':\n              worker._callbacks[message.id].reject(message)\n              break\n\n            default:\n              console.error('THREE.BasisTextureLoader: Unexpected message, \"' + message.type + '\"')\n          }\n        }\n\n        this.workerPool.push(worker)\n      } else {\n        this.workerPool.sort(function (a, b) {\n          return a._taskLoad > b._taskLoad ? -1 : 1\n        })\n      }\n\n      const worker = this.workerPool[this.workerPool.length - 1]\n\n      worker._taskLoad += taskCost\n\n      return worker\n    })\n  }\n\n  dispose() {\n    for (let i = 0; i < this.workerPool.length; i++) {\n      this.workerPool[i].terminate()\n    }\n\n    this.workerPool.length = 0\n\n    return this\n  }\n}\n\nexport { BasisTextureLoader }\n"],"names":["jsContent","binaryContent","worker"],"mappings":"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"}