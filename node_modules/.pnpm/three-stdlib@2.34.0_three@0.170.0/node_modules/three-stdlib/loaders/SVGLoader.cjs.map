{"version":3,"file":"SVGLoader.cjs","sources":["../../src/loaders/SVGLoader.js"],"sourcesContent":["import {\n  Box2,\n  BufferGeometry,\n  FileLoader,\n  Float32BufferAttribute,\n  Loader,\n  Matrix3,\n  Path,\n  Shape,\n  ShapePath,\n  ShapeUtils,\n  Vector2,\n  Vector3,\n} from 'three'\n\nconst COLOR_SPACE_SVG = 'srgb'\n\nclass SVGLoader extends Loader {\n  constructor(manager) {\n    super(manager)\n\n    // Default dots per inch\n    this.defaultDPI = 90\n\n    // Accepted units: 'mm', 'cm', 'in', 'pt', 'pc', 'px'\n    this.defaultUnit = 'px'\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    const scope = this\n\n    const loader = new FileLoader(scope.manager)\n    loader.setPath(scope.path)\n    loader.setRequestHeader(scope.requestHeader)\n    loader.setWithCredentials(scope.withCredentials)\n    loader.load(\n      url,\n      function (text) {\n        try {\n          onLoad(scope.parse(text))\n        } catch (e) {\n          if (onError) {\n            onError(e)\n          } else {\n            console.error(e)\n          }\n\n          scope.manager.itemError(url)\n        }\n      },\n      onProgress,\n      onError,\n    )\n  }\n\n  parse(text) {\n    const scope = this\n\n    function parseNode(node, style) {\n      if (node.nodeType !== 1) return\n\n      const transform = getNodeTransform(node)\n\n      let isDefsNode = false\n\n      let path = null\n\n      switch (node.nodeName) {\n        case 'svg':\n          style = parseStyle(node, style)\n          break\n\n        case 'style':\n          parseCSSStylesheet(node)\n          break\n\n        case 'g':\n          style = parseStyle(node, style)\n          break\n\n        case 'path':\n          style = parseStyle(node, style)\n          if (node.hasAttribute('d')) path = parsePathNode(node)\n          break\n\n        case 'rect':\n          style = parseStyle(node, style)\n          path = parseRectNode(node)\n          break\n\n        case 'polygon':\n          style = parseStyle(node, style)\n          path = parsePolygonNode(node)\n          break\n\n        case 'polyline':\n          style = parseStyle(node, style)\n          path = parsePolylineNode(node)\n          break\n\n        case 'circle':\n          style = parseStyle(node, style)\n          path = parseCircleNode(node)\n          break\n\n        case 'ellipse':\n          style = parseStyle(node, style)\n          path = parseEllipseNode(node)\n          break\n\n        case 'line':\n          style = parseStyle(node, style)\n          path = parseLineNode(node)\n          break\n\n        case 'defs':\n          isDefsNode = true\n          break\n\n        case 'use':\n          style = parseStyle(node, style)\n\n          const href = node.getAttributeNS('http://www.w3.org/1999/xlink', 'href') || ''\n          const usedNodeId = href.substring(1)\n          const usedNode = node.viewportElement.getElementById(usedNodeId)\n          if (usedNode) {\n            parseNode(usedNode, style)\n          } else {\n            console.warn(\"SVGLoader: 'use node' references non-existent node id: \" + usedNodeId)\n          }\n\n          break\n\n        default:\n        // console.log( node );\n      }\n\n      if (path) {\n        if (style.fill !== undefined && style.fill !== 'none') {\n          path.color.setStyle(style.fill, COLOR_SPACE_SVG)\n        }\n\n        transformPath(path, currentTransform)\n\n        paths.push(path)\n\n        path.userData = { node: node, style: style }\n      }\n\n      const childNodes = node.childNodes\n\n      for (let i = 0; i < childNodes.length; i++) {\n        const node = childNodes[i]\n\n        if (isDefsNode && node.nodeName !== 'style' && node.nodeName !== 'defs') {\n          // Ignore everything in defs except CSS style definitions\n          // and nested defs, because it is OK by the standard to have\n          // <style/> there.\n          continue\n        }\n\n        parseNode(node, style)\n      }\n\n      if (transform) {\n        transformStack.pop()\n\n        if (transformStack.length > 0) {\n          currentTransform.copy(transformStack[transformStack.length - 1])\n        } else {\n          currentTransform.identity()\n        }\n      }\n    }\n\n    function parsePathNode(node) {\n      const path = new ShapePath()\n\n      const point = new Vector2()\n      const control = new Vector2()\n\n      const firstPoint = new Vector2()\n      let isFirstPoint = true\n      let doSetFirstPoint = false\n\n      const d = node.getAttribute('d')\n\n      if (d === '' || d === 'none') return null\n\n      // console.log( d );\n\n      const commands = d.match(/[a-df-z][^a-df-z]*/gi)\n\n      for (let i = 0, l = commands.length; i < l; i++) {\n        const command = commands[i]\n\n        const type = command.charAt(0)\n        const data = command.slice(1).trim()\n\n        if (isFirstPoint === true) {\n          doSetFirstPoint = true\n          isFirstPoint = false\n        }\n\n        let numbers\n\n        switch (type) {\n          case 'M':\n            numbers = parseFloats(data)\n            for (let j = 0, jl = numbers.length; j < jl; j += 2) {\n              point.x = numbers[j + 0]\n              point.y = numbers[j + 1]\n              control.x = point.x\n              control.y = point.y\n\n              if (j === 0) {\n                path.moveTo(point.x, point.y)\n              } else {\n                path.lineTo(point.x, point.y)\n              }\n\n              if (j === 0) firstPoint.copy(point)\n            }\n\n            break\n\n          case 'H':\n            numbers = parseFloats(data)\n\n            for (let j = 0, jl = numbers.length; j < jl; j++) {\n              point.x = numbers[j]\n              control.x = point.x\n              control.y = point.y\n              path.lineTo(point.x, point.y)\n\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point)\n            }\n\n            break\n\n          case 'V':\n            numbers = parseFloats(data)\n\n            for (let j = 0, jl = numbers.length; j < jl; j++) {\n              point.y = numbers[j]\n              control.x = point.x\n              control.y = point.y\n              path.lineTo(point.x, point.y)\n\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point)\n            }\n\n            break\n\n          case 'L':\n            numbers = parseFloats(data)\n\n            for (let j = 0, jl = numbers.length; j < jl; j += 2) {\n              point.x = numbers[j + 0]\n              point.y = numbers[j + 1]\n              control.x = point.x\n              control.y = point.y\n              path.lineTo(point.x, point.y)\n\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point)\n            }\n\n            break\n\n          case 'C':\n            numbers = parseFloats(data)\n\n            for (let j = 0, jl = numbers.length; j < jl; j += 6) {\n              path.bezierCurveTo(\n                numbers[j + 0],\n                numbers[j + 1],\n                numbers[j + 2],\n                numbers[j + 3],\n                numbers[j + 4],\n                numbers[j + 5],\n              )\n              control.x = numbers[j + 2]\n              control.y = numbers[j + 3]\n              point.x = numbers[j + 4]\n              point.y = numbers[j + 5]\n\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point)\n            }\n\n            break\n\n          case 'S':\n            numbers = parseFloats(data)\n\n            for (let j = 0, jl = numbers.length; j < jl; j += 4) {\n              path.bezierCurveTo(\n                getReflection(point.x, control.x),\n                getReflection(point.y, control.y),\n                numbers[j + 0],\n                numbers[j + 1],\n                numbers[j + 2],\n                numbers[j + 3],\n              )\n              control.x = numbers[j + 0]\n              control.y = numbers[j + 1]\n              point.x = numbers[j + 2]\n              point.y = numbers[j + 3]\n\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point)\n            }\n\n            break\n\n          case 'Q':\n            numbers = parseFloats(data)\n\n            for (let j = 0, jl = numbers.length; j < jl; j += 4) {\n              path.quadraticCurveTo(numbers[j + 0], numbers[j + 1], numbers[j + 2], numbers[j + 3])\n              control.x = numbers[j + 0]\n              control.y = numbers[j + 1]\n              point.x = numbers[j + 2]\n              point.y = numbers[j + 3]\n\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point)\n            }\n\n            break\n\n          case 'T':\n            numbers = parseFloats(data)\n\n            for (let j = 0, jl = numbers.length; j < jl; j += 2) {\n              const rx = getReflection(point.x, control.x)\n              const ry = getReflection(point.y, control.y)\n              path.quadraticCurveTo(rx, ry, numbers[j + 0], numbers[j + 1])\n              control.x = rx\n              control.y = ry\n              point.x = numbers[j + 0]\n              point.y = numbers[j + 1]\n\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point)\n            }\n\n            break\n\n          case 'A':\n            numbers = parseFloats(data, [3, 4], 7)\n\n            for (let j = 0, jl = numbers.length; j < jl; j += 7) {\n              // skip command if start point == end point\n              if (numbers[j + 5] == point.x && numbers[j + 6] == point.y) continue\n\n              const start = point.clone()\n              point.x = numbers[j + 5]\n              point.y = numbers[j + 6]\n              control.x = point.x\n              control.y = point.y\n              parseArcCommand(\n                path,\n                numbers[j],\n                numbers[j + 1],\n                numbers[j + 2],\n                numbers[j + 3],\n                numbers[j + 4],\n                start,\n                point,\n              )\n\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point)\n            }\n\n            break\n\n          case 'm':\n            numbers = parseFloats(data)\n\n            for (let j = 0, jl = numbers.length; j < jl; j += 2) {\n              point.x += numbers[j + 0]\n              point.y += numbers[j + 1]\n              control.x = point.x\n              control.y = point.y\n\n              if (j === 0) {\n                path.moveTo(point.x, point.y)\n              } else {\n                path.lineTo(point.x, point.y)\n              }\n\n              if (j === 0) firstPoint.copy(point)\n            }\n\n            break\n\n          case 'h':\n            numbers = parseFloats(data)\n\n            for (let j = 0, jl = numbers.length; j < jl; j++) {\n              point.x += numbers[j]\n              control.x = point.x\n              control.y = point.y\n              path.lineTo(point.x, point.y)\n\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point)\n            }\n\n            break\n\n          case 'v':\n            numbers = parseFloats(data)\n\n            for (let j = 0, jl = numbers.length; j < jl; j++) {\n              point.y += numbers[j]\n              control.x = point.x\n              control.y = point.y\n              path.lineTo(point.x, point.y)\n\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point)\n            }\n\n            break\n\n          case 'l':\n            numbers = parseFloats(data)\n\n            for (let j = 0, jl = numbers.length; j < jl; j += 2) {\n              point.x += numbers[j + 0]\n              point.y += numbers[j + 1]\n              control.x = point.x\n              control.y = point.y\n              path.lineTo(point.x, point.y)\n\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point)\n            }\n\n            break\n\n          case 'c':\n            numbers = parseFloats(data)\n\n            for (let j = 0, jl = numbers.length; j < jl; j += 6) {\n              path.bezierCurveTo(\n                point.x + numbers[j + 0],\n                point.y + numbers[j + 1],\n                point.x + numbers[j + 2],\n                point.y + numbers[j + 3],\n                point.x + numbers[j + 4],\n                point.y + numbers[j + 5],\n              )\n              control.x = point.x + numbers[j + 2]\n              control.y = point.y + numbers[j + 3]\n              point.x += numbers[j + 4]\n              point.y += numbers[j + 5]\n\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point)\n            }\n\n            break\n\n          case 's':\n            numbers = parseFloats(data)\n\n            for (let j = 0, jl = numbers.length; j < jl; j += 4) {\n              path.bezierCurveTo(\n                getReflection(point.x, control.x),\n                getReflection(point.y, control.y),\n                point.x + numbers[j + 0],\n                point.y + numbers[j + 1],\n                point.x + numbers[j + 2],\n                point.y + numbers[j + 3],\n              )\n              control.x = point.x + numbers[j + 0]\n              control.y = point.y + numbers[j + 1]\n              point.x += numbers[j + 2]\n              point.y += numbers[j + 3]\n\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point)\n            }\n\n            break\n\n          case 'q':\n            numbers = parseFloats(data)\n\n            for (let j = 0, jl = numbers.length; j < jl; j += 4) {\n              path.quadraticCurveTo(\n                point.x + numbers[j + 0],\n                point.y + numbers[j + 1],\n                point.x + numbers[j + 2],\n                point.y + numbers[j + 3],\n              )\n              control.x = point.x + numbers[j + 0]\n              control.y = point.y + numbers[j + 1]\n              point.x += numbers[j + 2]\n              point.y += numbers[j + 3]\n\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point)\n            }\n\n            break\n\n          case 't':\n            numbers = parseFloats(data)\n\n            for (let j = 0, jl = numbers.length; j < jl; j += 2) {\n              const rx = getReflection(point.x, control.x)\n              const ry = getReflection(point.y, control.y)\n              path.quadraticCurveTo(rx, ry, point.x + numbers[j + 0], point.y + numbers[j + 1])\n              control.x = rx\n              control.y = ry\n              point.x = point.x + numbers[j + 0]\n              point.y = point.y + numbers[j + 1]\n\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point)\n            }\n\n            break\n\n          case 'a':\n            numbers = parseFloats(data, [3, 4], 7)\n\n            for (let j = 0, jl = numbers.length; j < jl; j += 7) {\n              // skip command if no displacement\n              if (numbers[j + 5] == 0 && numbers[j + 6] == 0) continue\n\n              const start = point.clone()\n              point.x += numbers[j + 5]\n              point.y += numbers[j + 6]\n              control.x = point.x\n              control.y = point.y\n              parseArcCommand(\n                path,\n                numbers[j],\n                numbers[j + 1],\n                numbers[j + 2],\n                numbers[j + 3],\n                numbers[j + 4],\n                start,\n                point,\n              )\n\n              if (j === 0 && doSetFirstPoint === true) firstPoint.copy(point)\n            }\n\n            break\n\n          case 'Z':\n          case 'z':\n            path.currentPath.autoClose = true\n\n            if (path.currentPath.curves.length > 0) {\n              // Reset point to beginning of Path\n              point.copy(firstPoint)\n              path.currentPath.currentPoint.copy(point)\n              isFirstPoint = true\n            }\n\n            break\n\n          default:\n            console.warn(command)\n        }\n\n        // console.log( type, parseFloats( data ), parseFloats( data ).length  )\n\n        doSetFirstPoint = false\n      }\n\n      return path\n    }\n\n    function parseCSSStylesheet(node) {\n      if (!node.sheet || !node.sheet.cssRules || !node.sheet.cssRules.length) return\n\n      for (let i = 0; i < node.sheet.cssRules.length; i++) {\n        const stylesheet = node.sheet.cssRules[i]\n\n        if (stylesheet.type !== 1) continue\n\n        const selectorList = stylesheet.selectorText\n          .split(/,/gm)\n          .filter(Boolean)\n          .map((i) => i.trim())\n\n        for (let j = 0; j < selectorList.length; j++) {\n          // Remove empty rules\n          const definitions = Object.fromEntries(Object.entries(stylesheet.style).filter(([, v]) => v !== ''))\n\n          stylesheets[selectorList[j]] = Object.assign(stylesheets[selectorList[j]] || {}, definitions)\n        }\n      }\n    }\n\n    /**\n     * https://www.w3.org/TR/SVG/implnote.html#ArcImplementationNotes\n     * https://mortoray.com/2017/02/16/rendering-an-svg-elliptical-arc-as-bezier-curves/ Appendix: Endpoint to center arc conversion\n     * From\n     * rx ry x-axis-rotation large-arc-flag sweep-flag x y\n     * To\n     * aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation\n     */\n\n    function parseArcCommand(path, rx, ry, x_axis_rotation, large_arc_flag, sweep_flag, start, end) {\n      if (rx == 0 || ry == 0) {\n        // draw a line if either of the radii == 0\n        path.lineTo(end.x, end.y)\n        return\n      }\n\n      x_axis_rotation = (x_axis_rotation * Math.PI) / 180\n\n      // Ensure radii are positive\n      rx = Math.abs(rx)\n      ry = Math.abs(ry)\n\n      // Compute (x1', y1')\n      const dx2 = (start.x - end.x) / 2.0\n      const dy2 = (start.y - end.y) / 2.0\n      const x1p = Math.cos(x_axis_rotation) * dx2 + Math.sin(x_axis_rotation) * dy2\n      const y1p = -Math.sin(x_axis_rotation) * dx2 + Math.cos(x_axis_rotation) * dy2\n\n      // Compute (cx', cy')\n      let rxs = rx * rx\n      let rys = ry * ry\n      const x1ps = x1p * x1p\n      const y1ps = y1p * y1p\n\n      // Ensure radii are large enough\n      const cr = x1ps / rxs + y1ps / rys\n\n      if (cr > 1) {\n        // scale up rx,ry equally so cr == 1\n        const s = Math.sqrt(cr)\n        rx = s * rx\n        ry = s * ry\n        rxs = rx * rx\n        rys = ry * ry\n      }\n\n      const dq = rxs * y1ps + rys * x1ps\n      const pq = (rxs * rys - dq) / dq\n      let q = Math.sqrt(Math.max(0, pq))\n      if (large_arc_flag === sweep_flag) q = -q\n      const cxp = (q * rx * y1p) / ry\n      const cyp = (-q * ry * x1p) / rx\n\n      // Step 3: Compute (cx, cy) from (cx', cy')\n      const cx = Math.cos(x_axis_rotation) * cxp - Math.sin(x_axis_rotation) * cyp + (start.x + end.x) / 2\n      const cy = Math.sin(x_axis_rotation) * cxp + Math.cos(x_axis_rotation) * cyp + (start.y + end.y) / 2\n\n      // Step 4: Compute θ1 and Δθ\n      const theta = svgAngle(1, 0, (x1p - cxp) / rx, (y1p - cyp) / ry)\n      const delta = svgAngle((x1p - cxp) / rx, (y1p - cyp) / ry, (-x1p - cxp) / rx, (-y1p - cyp) / ry) % (Math.PI * 2)\n\n      path.currentPath.absellipse(cx, cy, rx, ry, theta, theta + delta, sweep_flag === 0, x_axis_rotation)\n    }\n\n    function svgAngle(ux, uy, vx, vy) {\n      const dot = ux * vx + uy * vy\n      const len = Math.sqrt(ux * ux + uy * uy) * Math.sqrt(vx * vx + vy * vy)\n      let ang = Math.acos(Math.max(-1, Math.min(1, dot / len))) // floating point precision, slightly over values appear\n      if (ux * vy - uy * vx < 0) ang = -ang\n      return ang\n    }\n\n    /*\n     * According to https://www.w3.org/TR/SVG/shapes.html#RectElementRXAttribute\n     * rounded corner should be rendered to elliptical arc, but bezier curve does the job well enough\n     */\n    function parseRectNode(node) {\n      const x = parseFloatWithUnits(node.getAttribute('x') || 0)\n      const y = parseFloatWithUnits(node.getAttribute('y') || 0)\n      const rx = parseFloatWithUnits(node.getAttribute('rx') || node.getAttribute('ry') || 0)\n      const ry = parseFloatWithUnits(node.getAttribute('ry') || node.getAttribute('rx') || 0)\n      const w = parseFloatWithUnits(node.getAttribute('width'))\n      const h = parseFloatWithUnits(node.getAttribute('height'))\n\n      // Ellipse arc to Bezier approximation Coefficient (Inversed). See:\n      // https://spencermortensen.com/articles/bezier-circle/\n      const bci = 1 - 0.551915024494\n\n      const path = new ShapePath()\n\n      // top left\n      path.moveTo(x + rx, y)\n\n      // top right\n      path.lineTo(x + w - rx, y)\n      if (rx !== 0 || ry !== 0) {\n        path.bezierCurveTo(x + w - rx * bci, y, x + w, y + ry * bci, x + w, y + ry)\n      }\n\n      // bottom right\n      path.lineTo(x + w, y + h - ry)\n      if (rx !== 0 || ry !== 0) {\n        path.bezierCurveTo(x + w, y + h - ry * bci, x + w - rx * bci, y + h, x + w - rx, y + h)\n      }\n\n      // bottom left\n      path.lineTo(x + rx, y + h)\n      if (rx !== 0 || ry !== 0) {\n        path.bezierCurveTo(x + rx * bci, y + h, x, y + h - ry * bci, x, y + h - ry)\n      }\n\n      // back to top left\n      path.lineTo(x, y + ry)\n      if (rx !== 0 || ry !== 0) {\n        path.bezierCurveTo(x, y + ry * bci, x + rx * bci, y, x + rx, y)\n      }\n\n      return path\n    }\n\n    function parsePolygonNode(node) {\n      function iterator(match, a, b) {\n        const x = parseFloatWithUnits(a)\n        const y = parseFloatWithUnits(b)\n\n        if (index === 0) {\n          path.moveTo(x, y)\n        } else {\n          path.lineTo(x, y)\n        }\n\n        index++\n      }\n\n      const regex = /([+-]?\\d*\\.?\\d+(?:e[+-]?\\d+)?)(?:,|\\s)([+-]?\\d*\\.?\\d+(?:e[+-]?\\d+)?)/g\n\n      const path = new ShapePath()\n\n      let index = 0\n\n      node.getAttribute('points').replace(regex, iterator)\n\n      path.currentPath.autoClose = true\n\n      return path\n    }\n\n    function parsePolylineNode(node) {\n      function iterator(match, a, b) {\n        const x = parseFloatWithUnits(a)\n        const y = parseFloatWithUnits(b)\n\n        if (index === 0) {\n          path.moveTo(x, y)\n        } else {\n          path.lineTo(x, y)\n        }\n\n        index++\n      }\n\n      const regex = /([+-]?\\d*\\.?\\d+(?:e[+-]?\\d+)?)(?:,|\\s)([+-]?\\d*\\.?\\d+(?:e[+-]?\\d+)?)/g\n\n      const path = new ShapePath()\n\n      let index = 0\n\n      node.getAttribute('points').replace(regex, iterator)\n\n      path.currentPath.autoClose = false\n\n      return path\n    }\n\n    function parseCircleNode(node) {\n      const x = parseFloatWithUnits(node.getAttribute('cx') || 0)\n      const y = parseFloatWithUnits(node.getAttribute('cy') || 0)\n      const r = parseFloatWithUnits(node.getAttribute('r') || 0)\n\n      const subpath = new Path()\n      subpath.absarc(x, y, r, 0, Math.PI * 2)\n\n      const path = new ShapePath()\n      path.subPaths.push(subpath)\n\n      return path\n    }\n\n    function parseEllipseNode(node) {\n      const x = parseFloatWithUnits(node.getAttribute('cx') || 0)\n      const y = parseFloatWithUnits(node.getAttribute('cy') || 0)\n      const rx = parseFloatWithUnits(node.getAttribute('rx') || 0)\n      const ry = parseFloatWithUnits(node.getAttribute('ry') || 0)\n\n      const subpath = new Path()\n      subpath.absellipse(x, y, rx, ry, 0, Math.PI * 2)\n\n      const path = new ShapePath()\n      path.subPaths.push(subpath)\n\n      return path\n    }\n\n    function parseLineNode(node) {\n      const x1 = parseFloatWithUnits(node.getAttribute('x1') || 0)\n      const y1 = parseFloatWithUnits(node.getAttribute('y1') || 0)\n      const x2 = parseFloatWithUnits(node.getAttribute('x2') || 0)\n      const y2 = parseFloatWithUnits(node.getAttribute('y2') || 0)\n\n      const path = new ShapePath()\n      path.moveTo(x1, y1)\n      path.lineTo(x2, y2)\n      path.currentPath.autoClose = false\n\n      return path\n    }\n\n    //\n\n    function parseStyle(node, style) {\n      style = Object.assign({}, style) // clone style\n\n      let stylesheetStyles = {}\n\n      if (node.hasAttribute('class')) {\n        const classSelectors = node\n          .getAttribute('class')\n          .split(/\\s/)\n          .filter(Boolean)\n          .map((i) => i.trim())\n\n        for (let i = 0; i < classSelectors.length; i++) {\n          stylesheetStyles = Object.assign(stylesheetStyles, stylesheets['.' + classSelectors[i]])\n        }\n      }\n\n      if (node.hasAttribute('id')) {\n        stylesheetStyles = Object.assign(stylesheetStyles, stylesheets['#' + node.getAttribute('id')])\n      }\n\n      function addStyle(svgName, jsName, adjustFunction) {\n        if (adjustFunction === undefined)\n          adjustFunction = function copy(v) {\n            if (v.startsWith('url')) console.warn('SVGLoader: url access in attributes is not implemented.')\n\n            return v\n          }\n\n        if (node.hasAttribute(svgName)) style[jsName] = adjustFunction(node.getAttribute(svgName))\n        if (stylesheetStyles[svgName]) style[jsName] = adjustFunction(stylesheetStyles[svgName])\n        if (node.style && node.style[svgName] !== '') style[jsName] = adjustFunction(node.style[svgName])\n      }\n\n      function clamp(v) {\n        return Math.max(0, Math.min(1, parseFloatWithUnits(v)))\n      }\n\n      function positive(v) {\n        return Math.max(0, parseFloatWithUnits(v))\n      }\n\n      addStyle('fill', 'fill')\n      addStyle('fill-opacity', 'fillOpacity', clamp)\n      addStyle('fill-rule', 'fillRule')\n      addStyle('opacity', 'opacity', clamp)\n      addStyle('stroke', 'stroke')\n      addStyle('stroke-opacity', 'strokeOpacity', clamp)\n      addStyle('stroke-width', 'strokeWidth', positive)\n      addStyle('stroke-linejoin', 'strokeLineJoin')\n      addStyle('stroke-linecap', 'strokeLineCap')\n      addStyle('stroke-miterlimit', 'strokeMiterLimit', positive)\n      addStyle('visibility', 'visibility')\n\n      return style\n    }\n\n    // http://www.w3.org/TR/SVG11/implnote.html#PathElementImplementationNotes\n\n    function getReflection(a, b) {\n      return a - (b - a)\n    }\n\n    // from https://github.com/ppvg/svg-numbers (MIT License)\n\n    function parseFloats(input, flags, stride) {\n      if (typeof input !== 'string') {\n        throw new TypeError('Invalid input: ' + typeof input)\n      }\n\n      // Character groups\n      const RE = {\n        SEPARATOR: /[ \\t\\r\\n\\,.\\-+]/,\n        WHITESPACE: /[ \\t\\r\\n]/,\n        DIGIT: /[\\d]/,\n        SIGN: /[-+]/,\n        POINT: /\\./,\n        COMMA: /,/,\n        EXP: /e/i,\n        FLAGS: /[01]/,\n      }\n\n      // States\n      const SEP = 0\n      const INT = 1\n      const FLOAT = 2\n      const EXP = 3\n\n      let state = SEP\n      let seenComma = true\n      let number = '',\n        exponent = ''\n      const result = []\n\n      function throwSyntaxError(current, i, partial) {\n        const error = new SyntaxError('Unexpected character \"' + current + '\" at index ' + i + '.')\n        error.partial = partial\n        throw error\n      }\n\n      function newNumber() {\n        if (number !== '') {\n          if (exponent === '') result.push(Number(number))\n          else result.push(Number(number) * Math.pow(10, Number(exponent)))\n        }\n\n        number = ''\n        exponent = ''\n      }\n\n      let current\n      const length = input.length\n\n      for (let i = 0; i < length; i++) {\n        current = input[i]\n\n        // check for flags\n        if (Array.isArray(flags) && flags.includes(result.length % stride) && RE.FLAGS.test(current)) {\n          state = INT\n          number = current\n          newNumber()\n          continue\n        }\n\n        // parse until next number\n        if (state === SEP) {\n          // eat whitespace\n          if (RE.WHITESPACE.test(current)) {\n            continue\n          }\n\n          // start new number\n          if (RE.DIGIT.test(current) || RE.SIGN.test(current)) {\n            state = INT\n            number = current\n            continue\n          }\n\n          if (RE.POINT.test(current)) {\n            state = FLOAT\n            number = current\n            continue\n          }\n\n          // throw on double commas (e.g. \"1, , 2\")\n          if (RE.COMMA.test(current)) {\n            if (seenComma) {\n              throwSyntaxError(current, i, result)\n            }\n\n            seenComma = true\n          }\n        }\n\n        // parse integer part\n        if (state === INT) {\n          if (RE.DIGIT.test(current)) {\n            number += current\n            continue\n          }\n\n          if (RE.POINT.test(current)) {\n            number += current\n            state = FLOAT\n            continue\n          }\n\n          if (RE.EXP.test(current)) {\n            state = EXP\n            continue\n          }\n\n          // throw on double signs (\"-+1\"), but not on sign as separator (\"-1-2\")\n          if (RE.SIGN.test(current) && number.length === 1 && RE.SIGN.test(number[0])) {\n            throwSyntaxError(current, i, result)\n          }\n        }\n\n        // parse decimal part\n        if (state === FLOAT) {\n          if (RE.DIGIT.test(current)) {\n            number += current\n            continue\n          }\n\n          if (RE.EXP.test(current)) {\n            state = EXP\n            continue\n          }\n\n          // throw on double decimal points (e.g. \"1..2\")\n          if (RE.POINT.test(current) && number[number.length - 1] === '.') {\n            throwSyntaxError(current, i, result)\n          }\n        }\n\n        // parse exponent part\n        if (state === EXP) {\n          if (RE.DIGIT.test(current)) {\n            exponent += current\n            continue\n          }\n\n          if (RE.SIGN.test(current)) {\n            if (exponent === '') {\n              exponent += current\n              continue\n            }\n\n            if (exponent.length === 1 && RE.SIGN.test(exponent)) {\n              throwSyntaxError(current, i, result)\n            }\n          }\n        }\n\n        // end of number\n        if (RE.WHITESPACE.test(current)) {\n          newNumber()\n          state = SEP\n          seenComma = false\n        } else if (RE.COMMA.test(current)) {\n          newNumber()\n          state = SEP\n          seenComma = true\n        } else if (RE.SIGN.test(current)) {\n          newNumber()\n          state = INT\n          number = current\n        } else if (RE.POINT.test(current)) {\n          newNumber()\n          state = FLOAT\n          number = current\n        } else {\n          throwSyntaxError(current, i, result)\n        }\n      }\n\n      // add the last number found (if any)\n      newNumber()\n\n      return result\n    }\n\n    // Units\n\n    const units = ['mm', 'cm', 'in', 'pt', 'pc', 'px']\n\n    // Conversion: [ fromUnit ][ toUnit ] (-1 means dpi dependent)\n    const unitConversion = {\n      mm: {\n        mm: 1,\n        cm: 0.1,\n        in: 1 / 25.4,\n        pt: 72 / 25.4,\n        pc: 6 / 25.4,\n        px: -1,\n      },\n      cm: {\n        mm: 10,\n        cm: 1,\n        in: 1 / 2.54,\n        pt: 72 / 2.54,\n        pc: 6 / 2.54,\n        px: -1,\n      },\n      in: {\n        mm: 25.4,\n        cm: 2.54,\n        in: 1,\n        pt: 72,\n        pc: 6,\n        px: -1,\n      },\n      pt: {\n        mm: 25.4 / 72,\n        cm: 2.54 / 72,\n        in: 1 / 72,\n        pt: 1,\n        pc: 6 / 72,\n        px: -1,\n      },\n      pc: {\n        mm: 25.4 / 6,\n        cm: 2.54 / 6,\n        in: 1 / 6,\n        pt: 72 / 6,\n        pc: 1,\n        px: -1,\n      },\n      px: {\n        px: 1,\n      },\n    }\n\n    function parseFloatWithUnits(string) {\n      let theUnit = 'px'\n\n      if (typeof string === 'string' || string instanceof String) {\n        for (let i = 0, n = units.length; i < n; i++) {\n          const u = units[i]\n\n          if (string.endsWith(u)) {\n            theUnit = u\n            string = string.substring(0, string.length - u.length)\n            break\n          }\n        }\n      }\n\n      let scale = undefined\n\n      if (theUnit === 'px' && scope.defaultUnit !== 'px') {\n        // Conversion scale from  pixels to inches, then to default units\n\n        scale = unitConversion['in'][scope.defaultUnit] / scope.defaultDPI\n      } else {\n        scale = unitConversion[theUnit][scope.defaultUnit]\n\n        if (scale < 0) {\n          // Conversion scale to pixels\n\n          scale = unitConversion[theUnit]['in'] * scope.defaultDPI\n        }\n      }\n\n      return scale * parseFloat(string)\n    }\n\n    // Transforms\n\n    function getNodeTransform(node) {\n      if (\n        !(\n          node.hasAttribute('transform') ||\n          (node.nodeName === 'use' && (node.hasAttribute('x') || node.hasAttribute('y')))\n        )\n      ) {\n        return null\n      }\n\n      const transform = parseNodeTransform(node)\n\n      if (transformStack.length > 0) {\n        transform.premultiply(transformStack[transformStack.length - 1])\n      }\n\n      currentTransform.copy(transform)\n      transformStack.push(transform)\n\n      return transform\n    }\n\n    function parseNodeTransform(node) {\n      const transform = new Matrix3()\n      const currentTransform = tempTransform0\n\n      if (node.nodeName === 'use' && (node.hasAttribute('x') || node.hasAttribute('y'))) {\n        const tx = parseFloatWithUnits(node.getAttribute('x'))\n        const ty = parseFloatWithUnits(node.getAttribute('y'))\n\n        transform.translate(tx, ty)\n      }\n\n      if (node.hasAttribute('transform')) {\n        const transformsTexts = node.getAttribute('transform').split(')')\n\n        for (let tIndex = transformsTexts.length - 1; tIndex >= 0; tIndex--) {\n          const transformText = transformsTexts[tIndex].trim()\n\n          if (transformText === '') continue\n\n          const openParPos = transformText.indexOf('(')\n          const closeParPos = transformText.length\n\n          if (openParPos > 0 && openParPos < closeParPos) {\n            const transformType = transformText.slice(0, openParPos)\n\n            const array = parseFloats(transformText.slice(openParPos + 1))\n\n            currentTransform.identity()\n\n            switch (transformType) {\n              case 'translate':\n                if (array.length >= 1) {\n                  const tx = array[0]\n                  let ty = 0\n\n                  if (array.length >= 2) {\n                    ty = array[1]\n                  }\n\n                  currentTransform.translate(tx, ty)\n                }\n\n                break\n\n              case 'rotate':\n                if (array.length >= 1) {\n                  let angle = 0\n                  let cx = 0\n                  let cy = 0\n\n                  // Angle\n                  angle = (array[0] * Math.PI) / 180\n\n                  if (array.length >= 3) {\n                    // Center x, y\n                    cx = array[1]\n                    cy = array[2]\n                  }\n\n                  // Rotate around center (cx, cy)\n                  tempTransform1.makeTranslation(-cx, -cy)\n                  tempTransform2.makeRotation(angle)\n                  tempTransform3.multiplyMatrices(tempTransform2, tempTransform1)\n                  tempTransform1.makeTranslation(cx, cy)\n                  currentTransform.multiplyMatrices(tempTransform1, tempTransform3)\n                }\n\n                break\n\n              case 'scale':\n                if (array.length >= 1) {\n                  const scaleX = array[0]\n                  let scaleY = scaleX\n\n                  if (array.length >= 2) {\n                    scaleY = array[1]\n                  }\n\n                  currentTransform.scale(scaleX, scaleY)\n                }\n\n                break\n\n              case 'skewX':\n                if (array.length === 1) {\n                  currentTransform.set(1, Math.tan((array[0] * Math.PI) / 180), 0, 0, 1, 0, 0, 0, 1)\n                }\n\n                break\n\n              case 'skewY':\n                if (array.length === 1) {\n                  currentTransform.set(1, 0, 0, Math.tan((array[0] * Math.PI) / 180), 1, 0, 0, 0, 1)\n                }\n\n                break\n\n              case 'matrix':\n                if (array.length === 6) {\n                  currentTransform.set(array[0], array[2], array[4], array[1], array[3], array[5], 0, 0, 1)\n                }\n\n                break\n            }\n          }\n\n          transform.premultiply(currentTransform)\n        }\n      }\n\n      return transform\n    }\n\n    function transformPath(path, m) {\n      function transfVec2(v2) {\n        tempV3.set(v2.x, v2.y, 1).applyMatrix3(m)\n\n        v2.set(tempV3.x, tempV3.y)\n      }\n\n      function transfEllipseGeneric(curve) {\n        // For math description see:\n        // https://math.stackexchange.com/questions/4544164\n\n        const a = curve.xRadius\n        const b = curve.yRadius\n\n        const cosTheta = Math.cos(curve.aRotation)\n        const sinTheta = Math.sin(curve.aRotation)\n\n        const v1 = new Vector3(a * cosTheta, a * sinTheta, 0)\n        const v2 = new Vector3(-b * sinTheta, b * cosTheta, 0)\n\n        const f1 = v1.applyMatrix3(m)\n        const f2 = v2.applyMatrix3(m)\n\n        const mF = tempTransform0.set(f1.x, f2.x, 0, f1.y, f2.y, 0, 0, 0, 1)\n\n        const mFInv = tempTransform1.copy(mF).invert()\n        const mFInvT = tempTransform2.copy(mFInv).transpose()\n        const mQ = mFInvT.multiply(mFInv)\n        const mQe = mQ.elements\n\n        const ed = eigenDecomposition(mQe[0], mQe[1], mQe[4])\n        const rt1sqrt = Math.sqrt(ed.rt1)\n        const rt2sqrt = Math.sqrt(ed.rt2)\n\n        curve.xRadius = 1 / rt1sqrt\n        curve.yRadius = 1 / rt2sqrt\n        curve.aRotation = Math.atan2(ed.sn, ed.cs)\n\n        const isFullEllipse = (curve.aEndAngle - curve.aStartAngle) % (2 * Math.PI) < Number.EPSILON\n\n        // Do not touch angles of a full ellipse because after transformation they\n        // would converge to a sinle value effectively removing the whole curve\n\n        if (!isFullEllipse) {\n          const mDsqrt = tempTransform1.set(rt1sqrt, 0, 0, 0, rt2sqrt, 0, 0, 0, 1)\n\n          const mRT = tempTransform2.set(ed.cs, ed.sn, 0, -ed.sn, ed.cs, 0, 0, 0, 1)\n\n          const mDRF = mDsqrt.multiply(mRT).multiply(mF)\n\n          const transformAngle = (phi) => {\n            const { x: cosR, y: sinR } = new Vector3(Math.cos(phi), Math.sin(phi), 0).applyMatrix3(mDRF)\n\n            return Math.atan2(sinR, cosR)\n          }\n\n          curve.aStartAngle = transformAngle(curve.aStartAngle)\n          curve.aEndAngle = transformAngle(curve.aEndAngle)\n\n          if (isTransformFlipped(m)) {\n            curve.aClockwise = !curve.aClockwise\n          }\n        }\n      }\n\n      function transfEllipseNoSkew(curve) {\n        // Faster shortcut if no skew is applied\n        // (e.g, a euclidean transform of a group containing the ellipse)\n\n        const sx = getTransformScaleX(m)\n        const sy = getTransformScaleY(m)\n\n        curve.xRadius *= sx\n        curve.yRadius *= sy\n\n        // Extract rotation angle from the matrix of form:\n        //\n        //  | cosθ sx   -sinθ sy |\n        //  | sinθ sx    cosθ sy |\n        //\n        // Remembering that tanθ = sinθ / cosθ; and that\n        // `sx`, `sy`, or both might be zero.\n        const theta =\n          sx > Number.EPSILON ? Math.atan2(m.elements[1], m.elements[0]) : Math.atan2(-m.elements[3], m.elements[4])\n\n        curve.aRotation += theta\n\n        if (isTransformFlipped(m)) {\n          curve.aStartAngle *= -1\n          curve.aEndAngle *= -1\n          curve.aClockwise = !curve.aClockwise\n        }\n      }\n\n      const subPaths = path.subPaths\n\n      for (let i = 0, n = subPaths.length; i < n; i++) {\n        const subPath = subPaths[i]\n        const curves = subPath.curves\n\n        for (let j = 0; j < curves.length; j++) {\n          const curve = curves[j]\n\n          if (curve.isLineCurve) {\n            transfVec2(curve.v1)\n            transfVec2(curve.v2)\n          } else if (curve.isCubicBezierCurve) {\n            transfVec2(curve.v0)\n            transfVec2(curve.v1)\n            transfVec2(curve.v2)\n            transfVec2(curve.v3)\n          } else if (curve.isQuadraticBezierCurve) {\n            transfVec2(curve.v0)\n            transfVec2(curve.v1)\n            transfVec2(curve.v2)\n          } else if (curve.isEllipseCurve) {\n            // Transform ellipse center point\n\n            tempV2.set(curve.aX, curve.aY)\n            transfVec2(tempV2)\n            curve.aX = tempV2.x\n            curve.aY = tempV2.y\n\n            // Transform ellipse shape parameters\n\n            if (isTransformSkewed(m)) {\n              transfEllipseGeneric(curve)\n            } else {\n              transfEllipseNoSkew(curve)\n            }\n          }\n        }\n      }\n    }\n\n    function isTransformFlipped(m) {\n      const te = m.elements\n      return te[0] * te[4] - te[1] * te[3] < 0\n    }\n\n    function isTransformSkewed(m) {\n      const te = m.elements\n      const basisDot = te[0] * te[3] + te[1] * te[4]\n\n      // Shortcut for trivial rotations and transformations\n      if (basisDot === 0) return false\n\n      const sx = getTransformScaleX(m)\n      const sy = getTransformScaleY(m)\n\n      return Math.abs(basisDot / (sx * sy)) > Number.EPSILON\n    }\n\n    function getTransformScaleX(m) {\n      const te = m.elements\n      return Math.sqrt(te[0] * te[0] + te[1] * te[1])\n    }\n\n    function getTransformScaleY(m) {\n      const te = m.elements\n      return Math.sqrt(te[3] * te[3] + te[4] * te[4])\n    }\n\n    // Calculates the eigensystem of a real symmetric 2x2 matrix\n    //    [ A  B ]\n    //    [ B  C ]\n    // in the form\n    //    [ A  B ]  =  [ cs  -sn ] [ rt1   0  ] [  cs  sn ]\n    //    [ B  C ]     [ sn   cs ] [  0   rt2 ] [ -sn  cs ]\n    // where rt1 >= rt2.\n    //\n    // Adapted from: https://www.mpi-hd.mpg.de/personalhomes/globes/3x3/index.html\n    // -> Algorithms for real symmetric matrices -> Analytical (2x2 symmetric)\n    function eigenDecomposition(A, B, C) {\n      let rt1, rt2, cs, sn, t\n      const sm = A + C\n      const df = A - C\n      const rt = Math.sqrt(df * df + 4 * B * B)\n\n      if (sm > 0) {\n        rt1 = 0.5 * (sm + rt)\n        t = 1 / rt1\n        rt2 = A * t * C - B * t * B\n      } else if (sm < 0) {\n        rt2 = 0.5 * (sm - rt)\n      } else {\n        // This case needs to be treated separately to avoid div by 0\n\n        rt1 = 0.5 * rt\n        rt2 = -0.5 * rt\n      }\n\n      // Calculate eigenvectors\n\n      if (df > 0) {\n        cs = df + rt\n      } else {\n        cs = df - rt\n      }\n\n      if (Math.abs(cs) > 2 * Math.abs(B)) {\n        t = (-2 * B) / cs\n        sn = 1 / Math.sqrt(1 + t * t)\n        cs = t * sn\n      } else if (Math.abs(B) === 0) {\n        cs = 1\n        sn = 0\n      } else {\n        t = (-0.5 * cs) / B\n        cs = 1 / Math.sqrt(1 + t * t)\n        sn = t * cs\n      }\n\n      if (df > 0) {\n        t = cs\n        cs = -sn\n        sn = t\n      }\n\n      return { rt1, rt2, cs, sn }\n    }\n\n    //\n\n    const paths = []\n    const stylesheets = {}\n\n    const transformStack = []\n\n    const tempTransform0 = new Matrix3()\n    const tempTransform1 = new Matrix3()\n    const tempTransform2 = new Matrix3()\n    const tempTransform3 = new Matrix3()\n    const tempV2 = new Vector2()\n    const tempV3 = new Vector3()\n\n    const currentTransform = new Matrix3()\n\n    const xml = new DOMParser().parseFromString(text, 'image/svg+xml') // application/xml\n\n    parseNode(xml.documentElement, {\n      fill: '#000',\n      fillOpacity: 1,\n      strokeOpacity: 1,\n      strokeWidth: 1,\n      strokeLineJoin: 'miter',\n      strokeLineCap: 'butt',\n      strokeMiterLimit: 4,\n    })\n\n    const data = { paths: paths, xml: xml.documentElement }\n\n    // console.log( paths );\n    return data\n  }\n\n  static createShapes(shapePath) {\n    // Param shapePath: a shapepath as returned by the parse function of this class\n    // Returns Shape object\n\n    const BIGNUMBER = 999999999\n\n    const IntersectionLocationType = {\n      ORIGIN: 0,\n      DESTINATION: 1,\n      BETWEEN: 2,\n      LEFT: 3,\n      RIGHT: 4,\n      BEHIND: 5,\n      BEYOND: 6,\n    }\n\n    const classifyResult = {\n      loc: IntersectionLocationType.ORIGIN,\n      t: 0,\n    }\n\n    function findEdgeIntersection(a0, a1, b0, b1) {\n      const x1 = a0.x\n      const x2 = a1.x\n      const x3 = b0.x\n      const x4 = b1.x\n      const y1 = a0.y\n      const y2 = a1.y\n      const y3 = b0.y\n      const y4 = b1.y\n      const nom1 = (x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)\n      const nom2 = (x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)\n      const denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1)\n      const t1 = nom1 / denom\n      const t2 = nom2 / denom\n\n      if ((denom === 0 && nom1 !== 0) || t1 <= 0 || t1 >= 1 || t2 < 0 || t2 > 1) {\n        //1. lines are parallel or edges don't intersect\n\n        return null\n      } else if (nom1 === 0 && denom === 0) {\n        //2. lines are colinear\n\n        //check if endpoints of edge2 (b0-b1) lies on edge1 (a0-a1)\n        for (let i = 0; i < 2; i++) {\n          classifyPoint(i === 0 ? b0 : b1, a0, a1)\n          //find position of this endpoints relatively to edge1\n          if (classifyResult.loc == IntersectionLocationType.ORIGIN) {\n            const point = i === 0 ? b0 : b1\n            return { x: point.x, y: point.y, t: classifyResult.t }\n          } else if (classifyResult.loc == IntersectionLocationType.BETWEEN) {\n            const x = +(x1 + classifyResult.t * (x2 - x1)).toPrecision(10)\n            const y = +(y1 + classifyResult.t * (y2 - y1)).toPrecision(10)\n            return { x: x, y: y, t: classifyResult.t }\n          }\n        }\n\n        return null\n      } else {\n        //3. edges intersect\n\n        for (let i = 0; i < 2; i++) {\n          classifyPoint(i === 0 ? b0 : b1, a0, a1)\n\n          if (classifyResult.loc == IntersectionLocationType.ORIGIN) {\n            const point = i === 0 ? b0 : b1\n            return { x: point.x, y: point.y, t: classifyResult.t }\n          }\n        }\n\n        const x = +(x1 + t1 * (x2 - x1)).toPrecision(10)\n        const y = +(y1 + t1 * (y2 - y1)).toPrecision(10)\n        return { x: x, y: y, t: t1 }\n      }\n    }\n\n    function classifyPoint(p, edgeStart, edgeEnd) {\n      const ax = edgeEnd.x - edgeStart.x\n      const ay = edgeEnd.y - edgeStart.y\n      const bx = p.x - edgeStart.x\n      const by = p.y - edgeStart.y\n      const sa = ax * by - bx * ay\n\n      if (p.x === edgeStart.x && p.y === edgeStart.y) {\n        classifyResult.loc = IntersectionLocationType.ORIGIN\n        classifyResult.t = 0\n        return\n      }\n\n      if (p.x === edgeEnd.x && p.y === edgeEnd.y) {\n        classifyResult.loc = IntersectionLocationType.DESTINATION\n        classifyResult.t = 1\n        return\n      }\n\n      if (sa < -Number.EPSILON) {\n        classifyResult.loc = IntersectionLocationType.LEFT\n        return\n      }\n\n      if (sa > Number.EPSILON) {\n        classifyResult.loc = IntersectionLocationType.RIGHT\n        return\n      }\n\n      if (ax * bx < 0 || ay * by < 0) {\n        classifyResult.loc = IntersectionLocationType.BEHIND\n        return\n      }\n\n      if (Math.sqrt(ax * ax + ay * ay) < Math.sqrt(bx * bx + by * by)) {\n        classifyResult.loc = IntersectionLocationType.BEYOND\n        return\n      }\n\n      let t\n\n      if (ax !== 0) {\n        t = bx / ax\n      } else {\n        t = by / ay\n      }\n\n      classifyResult.loc = IntersectionLocationType.BETWEEN\n      classifyResult.t = t\n    }\n\n    function getIntersections(path1, path2) {\n      const intersectionsRaw = []\n      const intersections = []\n\n      for (let index = 1; index < path1.length; index++) {\n        const path1EdgeStart = path1[index - 1]\n        const path1EdgeEnd = path1[index]\n\n        for (let index2 = 1; index2 < path2.length; index2++) {\n          const path2EdgeStart = path2[index2 - 1]\n          const path2EdgeEnd = path2[index2]\n\n          const intersection = findEdgeIntersection(path1EdgeStart, path1EdgeEnd, path2EdgeStart, path2EdgeEnd)\n\n          if (\n            intersection !== null &&\n            intersectionsRaw.find(\n              (i) => i.t <= intersection.t + Number.EPSILON && i.t >= intersection.t - Number.EPSILON,\n            ) === undefined\n          ) {\n            intersectionsRaw.push(intersection)\n            intersections.push(new Vector2(intersection.x, intersection.y))\n          }\n        }\n      }\n\n      return intersections\n    }\n\n    function getScanlineIntersections(scanline, boundingBox, paths) {\n      const center = new Vector2()\n      boundingBox.getCenter(center)\n\n      const allIntersections = []\n\n      paths.forEach((path) => {\n        // check if the center of the bounding box is in the bounding box of the paths.\n        // this is a pruning method to limit the search of intersections in paths that can't envelop of the current path.\n        // if a path envelops another path. The center of that oter path, has to be inside the bounding box of the enveloping path.\n        if (path.boundingBox.containsPoint(center)) {\n          const intersections = getIntersections(scanline, path.points)\n\n          intersections.forEach((p) => {\n            allIntersections.push({ identifier: path.identifier, isCW: path.isCW, point: p })\n          })\n        }\n      })\n\n      allIntersections.sort((i1, i2) => {\n        return i1.point.x - i2.point.x\n      })\n\n      return allIntersections\n    }\n\n    function isHoleTo(simplePath, allPaths, scanlineMinX, scanlineMaxX, _fillRule) {\n      if (_fillRule === null || _fillRule === undefined || _fillRule === '') {\n        _fillRule = 'nonzero'\n      }\n\n      const centerBoundingBox = new Vector2()\n      simplePath.boundingBox.getCenter(centerBoundingBox)\n\n      const scanline = [new Vector2(scanlineMinX, centerBoundingBox.y), new Vector2(scanlineMaxX, centerBoundingBox.y)]\n\n      const scanlineIntersections = getScanlineIntersections(scanline, simplePath.boundingBox, allPaths)\n\n      scanlineIntersections.sort((i1, i2) => {\n        return i1.point.x - i2.point.x\n      })\n\n      const baseIntersections = []\n      const otherIntersections = []\n\n      scanlineIntersections.forEach((i) => {\n        if (i.identifier === simplePath.identifier) {\n          baseIntersections.push(i)\n        } else {\n          otherIntersections.push(i)\n        }\n      })\n\n      const firstXOfPath = baseIntersections[0].point.x\n\n      // build up the path hierarchy\n      const stack = []\n      let i = 0\n\n      while (i < otherIntersections.length && otherIntersections[i].point.x < firstXOfPath) {\n        if (stack.length > 0 && stack[stack.length - 1] === otherIntersections[i].identifier) {\n          stack.pop()\n        } else {\n          stack.push(otherIntersections[i].identifier)\n        }\n\n        i++\n      }\n\n      stack.push(simplePath.identifier)\n\n      if (_fillRule === 'evenodd') {\n        const isHole = stack.length % 2 === 0 ? true : false\n        const isHoleFor = stack[stack.length - 2]\n\n        return { identifier: simplePath.identifier, isHole: isHole, for: isHoleFor }\n      } else if (_fillRule === 'nonzero') {\n        // check if path is a hole by counting the amount of paths with alternating rotations it has to cross.\n        let isHole = true\n        let isHoleFor = null\n        let lastCWValue = null\n\n        for (let i = 0; i < stack.length; i++) {\n          const identifier = stack[i]\n          if (isHole) {\n            lastCWValue = allPaths[identifier].isCW\n            isHole = false\n            isHoleFor = identifier\n          } else if (lastCWValue !== allPaths[identifier].isCW) {\n            lastCWValue = allPaths[identifier].isCW\n            isHole = true\n          }\n        }\n\n        return { identifier: simplePath.identifier, isHole: isHole, for: isHoleFor }\n      } else {\n        console.warn('fill-rule: \"' + _fillRule + '\" is currently not implemented.')\n      }\n    }\n\n    // check for self intersecting paths\n    // TODO\n\n    // check intersecting paths\n    // TODO\n\n    // prepare paths for hole detection\n    let scanlineMinX = BIGNUMBER\n    let scanlineMaxX = -BIGNUMBER\n\n    let simplePaths = shapePath.subPaths.map((p) => {\n      const points = p.getPoints()\n      let maxY = -BIGNUMBER\n      let minY = BIGNUMBER\n      let maxX = -BIGNUMBER\n      let minX = BIGNUMBER\n\n      //points.forEach(p => p.y *= -1);\n\n      for (let i = 0; i < points.length; i++) {\n        const p = points[i]\n\n        if (p.y > maxY) {\n          maxY = p.y\n        }\n\n        if (p.y < minY) {\n          minY = p.y\n        }\n\n        if (p.x > maxX) {\n          maxX = p.x\n        }\n\n        if (p.x < minX) {\n          minX = p.x\n        }\n      }\n\n      //\n      if (scanlineMaxX <= maxX) {\n        scanlineMaxX = maxX + 1\n      }\n\n      if (scanlineMinX >= minX) {\n        scanlineMinX = minX - 1\n      }\n\n      return {\n        curves: p.curves,\n        points: points,\n        isCW: ShapeUtils.isClockWise(points),\n        identifier: -1,\n        boundingBox: new Box2(new Vector2(minX, minY), new Vector2(maxX, maxY)),\n      }\n    })\n\n    simplePaths = simplePaths.filter((sp) => sp.points.length > 1)\n\n    for (let identifier = 0; identifier < simplePaths.length; identifier++) {\n      simplePaths[identifier].identifier = identifier\n    }\n\n    // check if path is solid or a hole\n    const isAHole = simplePaths.map((p) =>\n      isHoleTo(\n        p,\n        simplePaths,\n        scanlineMinX,\n        scanlineMaxX,\n        shapePath.userData ? shapePath.userData.style.fillRule : undefined,\n      ),\n    )\n\n    const shapesToReturn = []\n    simplePaths.forEach((p) => {\n      const amIAHole = isAHole[p.identifier]\n\n      if (!amIAHole.isHole) {\n        const shape = new Shape()\n        shape.curves = p.curves\n        const holes = isAHole.filter((h) => h.isHole && h.for === p.identifier)\n        holes.forEach((h) => {\n          const hole = simplePaths[h.identifier]\n          const path = new Path()\n          path.curves = hole.curves\n          shape.holes.push(path)\n        })\n        shapesToReturn.push(shape)\n      }\n    })\n\n    return shapesToReturn\n  }\n\n  static getStrokeStyle(width, color, lineJoin, lineCap, miterLimit) {\n    // Param width: Stroke width\n    // Param color: As returned by THREE.Color.getStyle()\n    // Param lineJoin: One of \"round\", \"bevel\", \"miter\" or \"miter-limit\"\n    // Param lineCap: One of \"round\", \"square\" or \"butt\"\n    // Param miterLimit: Maximum join length, in multiples of the \"width\" parameter (join is truncated if it exceeds that distance)\n    // Returns style object\n\n    width = width !== undefined ? width : 1\n    color = color !== undefined ? color : '#000'\n    lineJoin = lineJoin !== undefined ? lineJoin : 'miter'\n    lineCap = lineCap !== undefined ? lineCap : 'butt'\n    miterLimit = miterLimit !== undefined ? miterLimit : 4\n\n    return {\n      strokeColor: color,\n      strokeWidth: width,\n      strokeLineJoin: lineJoin,\n      strokeLineCap: lineCap,\n      strokeMiterLimit: miterLimit,\n    }\n  }\n\n  static pointsToStroke(points, style, arcDivisions, minDistance) {\n    // Generates a stroke with some width around the given path.\n    // The path can be open or closed (last point equals to first point)\n    // Param points: Array of Vector2D (the path). Minimum 2 points.\n    // Param style: Object with SVG properties as returned by SVGLoader.getStrokeStyle(), or SVGLoader.parse() in the path.userData.style object\n    // Params arcDivisions: Arc divisions for round joins and endcaps. (Optional)\n    // Param minDistance: Points closer to this distance will be merged. (Optional)\n    // Returns BufferGeometry with stroke triangles (In plane z = 0). UV coordinates are generated ('u' along path. 'v' across it, from left to right)\n\n    const vertices = []\n    const normals = []\n    const uvs = []\n\n    if (SVGLoader.pointsToStrokeWithBuffers(points, style, arcDivisions, minDistance, vertices, normals, uvs) === 0) {\n      return null\n    }\n\n    const geometry = new BufferGeometry()\n    geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3))\n    geometry.setAttribute('normal', new Float32BufferAttribute(normals, 3))\n    geometry.setAttribute('uv', new Float32BufferAttribute(uvs, 2))\n\n    return geometry\n  }\n\n  static pointsToStrokeWithBuffers(points, style, arcDivisions, minDistance, vertices, normals, uvs, vertexOffset) {\n    // This function can be called to update existing arrays or buffers.\n    // Accepts same parameters as pointsToStroke, plus the buffers and optional offset.\n    // Param vertexOffset: Offset vertices to start writing in the buffers (3 elements/vertex for vertices and normals, and 2 elements/vertex for uvs)\n    // Returns number of written vertices / normals / uvs pairs\n    // if 'vertices' parameter is undefined no triangles will be generated, but the returned vertices count will still be valid (useful to preallocate the buffers)\n    // 'normals' and 'uvs' buffers are optional\n\n    const tempV2_1 = new Vector2()\n    const tempV2_2 = new Vector2()\n    const tempV2_3 = new Vector2()\n    const tempV2_4 = new Vector2()\n    const tempV2_5 = new Vector2()\n    const tempV2_6 = new Vector2()\n    const tempV2_7 = new Vector2()\n    const lastPointL = new Vector2()\n    const lastPointR = new Vector2()\n    const point0L = new Vector2()\n    const point0R = new Vector2()\n    const currentPointL = new Vector2()\n    const currentPointR = new Vector2()\n    const nextPointL = new Vector2()\n    const nextPointR = new Vector2()\n    const innerPoint = new Vector2()\n    const outerPoint = new Vector2()\n\n    arcDivisions = arcDivisions !== undefined ? arcDivisions : 12\n    minDistance = minDistance !== undefined ? minDistance : 0.001\n    vertexOffset = vertexOffset !== undefined ? vertexOffset : 0\n\n    // First ensure there are no duplicated points\n    points = removeDuplicatedPoints(points)\n\n    const numPoints = points.length\n\n    if (numPoints < 2) return 0\n\n    const isClosed = points[0].equals(points[numPoints - 1])\n\n    let currentPoint\n    let previousPoint = points[0]\n    let nextPoint\n\n    const strokeWidth2 = style.strokeWidth / 2\n\n    const deltaU = 1 / (numPoints - 1)\n    let u0 = 0,\n      u1\n\n    let innerSideModified\n    let joinIsOnLeftSide\n    let isMiter\n    let initialJoinIsOnLeftSide = false\n\n    let numVertices = 0\n    let currentCoordinate = vertexOffset * 3\n    let currentCoordinateUV = vertexOffset * 2\n\n    // Get initial left and right stroke points\n    getNormal(points[0], points[1], tempV2_1).multiplyScalar(strokeWidth2)\n    lastPointL.copy(points[0]).sub(tempV2_1)\n    lastPointR.copy(points[0]).add(tempV2_1)\n    point0L.copy(lastPointL)\n    point0R.copy(lastPointR)\n\n    for (let iPoint = 1; iPoint < numPoints; iPoint++) {\n      currentPoint = points[iPoint]\n\n      // Get next point\n      if (iPoint === numPoints - 1) {\n        if (isClosed) {\n          // Skip duplicated initial point\n          nextPoint = points[1]\n        } else nextPoint = undefined\n      } else {\n        nextPoint = points[iPoint + 1]\n      }\n\n      // Normal of previous segment in tempV2_1\n      const normal1 = tempV2_1\n      getNormal(previousPoint, currentPoint, normal1)\n\n      tempV2_3.copy(normal1).multiplyScalar(strokeWidth2)\n      currentPointL.copy(currentPoint).sub(tempV2_3)\n      currentPointR.copy(currentPoint).add(tempV2_3)\n\n      u1 = u0 + deltaU\n\n      innerSideModified = false\n\n      if (nextPoint !== undefined) {\n        // Normal of next segment in tempV2_2\n        getNormal(currentPoint, nextPoint, tempV2_2)\n\n        tempV2_3.copy(tempV2_2).multiplyScalar(strokeWidth2)\n        nextPointL.copy(currentPoint).sub(tempV2_3)\n        nextPointR.copy(currentPoint).add(tempV2_3)\n\n        joinIsOnLeftSide = true\n        tempV2_3.subVectors(nextPoint, previousPoint)\n        if (normal1.dot(tempV2_3) < 0) {\n          joinIsOnLeftSide = false\n        }\n\n        if (iPoint === 1) initialJoinIsOnLeftSide = joinIsOnLeftSide\n\n        tempV2_3.subVectors(nextPoint, currentPoint)\n        tempV2_3.normalize()\n        const dot = Math.abs(normal1.dot(tempV2_3))\n\n        // If path is straight, don't create join\n        if (dot > Number.EPSILON) {\n          // Compute inner and outer segment intersections\n          const miterSide = strokeWidth2 / dot\n          tempV2_3.multiplyScalar(-miterSide)\n          tempV2_4.subVectors(currentPoint, previousPoint)\n          tempV2_5.copy(tempV2_4).setLength(miterSide).add(tempV2_3)\n          innerPoint.copy(tempV2_5).negate()\n          const miterLength2 = tempV2_5.length()\n          const segmentLengthPrev = tempV2_4.length()\n          tempV2_4.divideScalar(segmentLengthPrev)\n          tempV2_6.subVectors(nextPoint, currentPoint)\n          const segmentLengthNext = tempV2_6.length()\n          tempV2_6.divideScalar(segmentLengthNext)\n          // Check that previous and next segments doesn't overlap with the innerPoint of intersection\n          if (tempV2_4.dot(innerPoint) < segmentLengthPrev && tempV2_6.dot(innerPoint) < segmentLengthNext) {\n            innerSideModified = true\n          }\n\n          outerPoint.copy(tempV2_5).add(currentPoint)\n          innerPoint.add(currentPoint)\n\n          isMiter = false\n\n          if (innerSideModified) {\n            if (joinIsOnLeftSide) {\n              nextPointR.copy(innerPoint)\n              currentPointR.copy(innerPoint)\n            } else {\n              nextPointL.copy(innerPoint)\n              currentPointL.copy(innerPoint)\n            }\n          } else {\n            // The segment triangles are generated here if there was overlapping\n\n            makeSegmentTriangles()\n          }\n\n          switch (style.strokeLineJoin) {\n            case 'bevel':\n              makeSegmentWithBevelJoin(joinIsOnLeftSide, innerSideModified, u1)\n\n              break\n\n            case 'round':\n              // Segment triangles\n\n              createSegmentTrianglesWithMiddleSection(joinIsOnLeftSide, innerSideModified)\n\n              // Join triangles\n\n              if (joinIsOnLeftSide) {\n                makeCircularSector(currentPoint, currentPointL, nextPointL, u1, 0)\n              } else {\n                makeCircularSector(currentPoint, nextPointR, currentPointR, u1, 1)\n              }\n\n              break\n\n            case 'miter':\n            case 'miter-clip':\n            default:\n              const miterFraction = (strokeWidth2 * style.strokeMiterLimit) / miterLength2\n\n              if (miterFraction < 1) {\n                // The join miter length exceeds the miter limit\n\n                if (style.strokeLineJoin !== 'miter-clip') {\n                  makeSegmentWithBevelJoin(joinIsOnLeftSide, innerSideModified, u1)\n                  break\n                } else {\n                  // Segment triangles\n\n                  createSegmentTrianglesWithMiddleSection(joinIsOnLeftSide, innerSideModified)\n\n                  // Miter-clip join triangles\n\n                  if (joinIsOnLeftSide) {\n                    tempV2_6.subVectors(outerPoint, currentPointL).multiplyScalar(miterFraction).add(currentPointL)\n                    tempV2_7.subVectors(outerPoint, nextPointL).multiplyScalar(miterFraction).add(nextPointL)\n\n                    addVertex(currentPointL, u1, 0)\n                    addVertex(tempV2_6, u1, 0)\n                    addVertex(currentPoint, u1, 0.5)\n\n                    addVertex(currentPoint, u1, 0.5)\n                    addVertex(tempV2_6, u1, 0)\n                    addVertex(tempV2_7, u1, 0)\n\n                    addVertex(currentPoint, u1, 0.5)\n                    addVertex(tempV2_7, u1, 0)\n                    addVertex(nextPointL, u1, 0)\n                  } else {\n                    tempV2_6.subVectors(outerPoint, currentPointR).multiplyScalar(miterFraction).add(currentPointR)\n                    tempV2_7.subVectors(outerPoint, nextPointR).multiplyScalar(miterFraction).add(nextPointR)\n\n                    addVertex(currentPointR, u1, 1)\n                    addVertex(tempV2_6, u1, 1)\n                    addVertex(currentPoint, u1, 0.5)\n\n                    addVertex(currentPoint, u1, 0.5)\n                    addVertex(tempV2_6, u1, 1)\n                    addVertex(tempV2_7, u1, 1)\n\n                    addVertex(currentPoint, u1, 0.5)\n                    addVertex(tempV2_7, u1, 1)\n                    addVertex(nextPointR, u1, 1)\n                  }\n                }\n              } else {\n                // Miter join segment triangles\n\n                if (innerSideModified) {\n                  // Optimized segment + join triangles\n\n                  if (joinIsOnLeftSide) {\n                    addVertex(lastPointR, u0, 1)\n                    addVertex(lastPointL, u0, 0)\n                    addVertex(outerPoint, u1, 0)\n\n                    addVertex(lastPointR, u0, 1)\n                    addVertex(outerPoint, u1, 0)\n                    addVertex(innerPoint, u1, 1)\n                  } else {\n                    addVertex(lastPointR, u0, 1)\n                    addVertex(lastPointL, u0, 0)\n                    addVertex(outerPoint, u1, 1)\n\n                    addVertex(lastPointL, u0, 0)\n                    addVertex(innerPoint, u1, 0)\n                    addVertex(outerPoint, u1, 1)\n                  }\n\n                  if (joinIsOnLeftSide) {\n                    nextPointL.copy(outerPoint)\n                  } else {\n                    nextPointR.copy(outerPoint)\n                  }\n                } else {\n                  // Add extra miter join triangles\n\n                  if (joinIsOnLeftSide) {\n                    addVertex(currentPointL, u1, 0)\n                    addVertex(outerPoint, u1, 0)\n                    addVertex(currentPoint, u1, 0.5)\n\n                    addVertex(currentPoint, u1, 0.5)\n                    addVertex(outerPoint, u1, 0)\n                    addVertex(nextPointL, u1, 0)\n                  } else {\n                    addVertex(currentPointR, u1, 1)\n                    addVertex(outerPoint, u1, 1)\n                    addVertex(currentPoint, u1, 0.5)\n\n                    addVertex(currentPoint, u1, 0.5)\n                    addVertex(outerPoint, u1, 1)\n                    addVertex(nextPointR, u1, 1)\n                  }\n                }\n\n                isMiter = true\n              }\n\n              break\n          }\n        } else {\n          // The segment triangles are generated here when two consecutive points are collinear\n\n          makeSegmentTriangles()\n        }\n      } else {\n        // The segment triangles are generated here if it is the ending segment\n\n        makeSegmentTriangles()\n      }\n\n      if (!isClosed && iPoint === numPoints - 1) {\n        // Start line endcap\n        addCapGeometry(points[0], point0L, point0R, joinIsOnLeftSide, true, u0)\n      }\n\n      // Increment loop variables\n\n      u0 = u1\n\n      previousPoint = currentPoint\n\n      lastPointL.copy(nextPointL)\n      lastPointR.copy(nextPointR)\n    }\n\n    if (!isClosed) {\n      // Ending line endcap\n      addCapGeometry(currentPoint, currentPointL, currentPointR, joinIsOnLeftSide, false, u1)\n    } else if (innerSideModified && vertices) {\n      // Modify path first segment vertices to adjust to the segments inner and outer intersections\n\n      let lastOuter = outerPoint\n      let lastInner = innerPoint\n\n      if (initialJoinIsOnLeftSide !== joinIsOnLeftSide) {\n        lastOuter = innerPoint\n        lastInner = outerPoint\n      }\n\n      if (joinIsOnLeftSide) {\n        if (isMiter || initialJoinIsOnLeftSide) {\n          lastInner.toArray(vertices, 0 * 3)\n          lastInner.toArray(vertices, 3 * 3)\n\n          if (isMiter) {\n            lastOuter.toArray(vertices, 1 * 3)\n          }\n        }\n      } else {\n        if (isMiter || !initialJoinIsOnLeftSide) {\n          lastInner.toArray(vertices, 1 * 3)\n          lastInner.toArray(vertices, 3 * 3)\n\n          if (isMiter) {\n            lastOuter.toArray(vertices, 0 * 3)\n          }\n        }\n      }\n    }\n\n    return numVertices\n\n    // -- End of algorithm\n\n    // -- Functions\n\n    function getNormal(p1, p2, result) {\n      result.subVectors(p2, p1)\n      return result.set(-result.y, result.x).normalize()\n    }\n\n    function addVertex(position, u, v) {\n      if (vertices) {\n        vertices[currentCoordinate] = position.x\n        vertices[currentCoordinate + 1] = position.y\n        vertices[currentCoordinate + 2] = 0\n\n        if (normals) {\n          normals[currentCoordinate] = 0\n          normals[currentCoordinate + 1] = 0\n          normals[currentCoordinate + 2] = 1\n        }\n\n        currentCoordinate += 3\n\n        if (uvs) {\n          uvs[currentCoordinateUV] = u\n          uvs[currentCoordinateUV + 1] = v\n\n          currentCoordinateUV += 2\n        }\n      }\n\n      numVertices += 3\n    }\n\n    function makeCircularSector(center, p1, p2, u, v) {\n      // param p1, p2: Points in the circle arc.\n      // p1 and p2 are in clockwise direction.\n\n      tempV2_1.copy(p1).sub(center).normalize()\n      tempV2_2.copy(p2).sub(center).normalize()\n\n      let angle = Math.PI\n      const dot = tempV2_1.dot(tempV2_2)\n      if (Math.abs(dot) < 1) angle = Math.abs(Math.acos(dot))\n\n      angle /= arcDivisions\n\n      tempV2_3.copy(p1)\n\n      for (let i = 0, il = arcDivisions - 1; i < il; i++) {\n        tempV2_4.copy(tempV2_3).rotateAround(center, angle)\n\n        addVertex(tempV2_3, u, v)\n        addVertex(tempV2_4, u, v)\n        addVertex(center, u, 0.5)\n\n        tempV2_3.copy(tempV2_4)\n      }\n\n      addVertex(tempV2_4, u, v)\n      addVertex(p2, u, v)\n      addVertex(center, u, 0.5)\n    }\n\n    function makeSegmentTriangles() {\n      addVertex(lastPointR, u0, 1)\n      addVertex(lastPointL, u0, 0)\n      addVertex(currentPointL, u1, 0)\n\n      addVertex(lastPointR, u0, 1)\n      addVertex(currentPointL, u1, 0)\n      addVertex(currentPointR, u1, 1)\n    }\n\n    function makeSegmentWithBevelJoin(joinIsOnLeftSide, innerSideModified, u) {\n      if (innerSideModified) {\n        // Optimized segment + bevel triangles\n\n        if (joinIsOnLeftSide) {\n          // Path segments triangles\n\n          addVertex(lastPointR, u0, 1)\n          addVertex(lastPointL, u0, 0)\n          addVertex(currentPointL, u1, 0)\n\n          addVertex(lastPointR, u0, 1)\n          addVertex(currentPointL, u1, 0)\n          addVertex(innerPoint, u1, 1)\n\n          // Bevel join triangle\n\n          addVertex(currentPointL, u, 0)\n          addVertex(nextPointL, u, 0)\n          addVertex(innerPoint, u, 0.5)\n        } else {\n          // Path segments triangles\n\n          addVertex(lastPointR, u0, 1)\n          addVertex(lastPointL, u0, 0)\n          addVertex(currentPointR, u1, 1)\n\n          addVertex(lastPointL, u0, 0)\n          addVertex(innerPoint, u1, 0)\n          addVertex(currentPointR, u1, 1)\n\n          // Bevel join triangle\n\n          addVertex(currentPointR, u, 1)\n          addVertex(innerPoint, u, 0)\n          addVertex(nextPointR, u, 1)\n        }\n      } else {\n        // Bevel join triangle. The segment triangles are done in the main loop\n\n        if (joinIsOnLeftSide) {\n          addVertex(currentPointL, u, 0)\n          addVertex(nextPointL, u, 0)\n          addVertex(currentPoint, u, 0.5)\n        } else {\n          addVertex(currentPointR, u, 1)\n          addVertex(nextPointR, u, 0)\n          addVertex(currentPoint, u, 0.5)\n        }\n      }\n    }\n\n    function createSegmentTrianglesWithMiddleSection(joinIsOnLeftSide, innerSideModified) {\n      if (innerSideModified) {\n        if (joinIsOnLeftSide) {\n          addVertex(lastPointR, u0, 1)\n          addVertex(lastPointL, u0, 0)\n          addVertex(currentPointL, u1, 0)\n\n          addVertex(lastPointR, u0, 1)\n          addVertex(currentPointL, u1, 0)\n          addVertex(innerPoint, u1, 1)\n\n          addVertex(currentPointL, u0, 0)\n          addVertex(currentPoint, u1, 0.5)\n          addVertex(innerPoint, u1, 1)\n\n          addVertex(currentPoint, u1, 0.5)\n          addVertex(nextPointL, u0, 0)\n          addVertex(innerPoint, u1, 1)\n        } else {\n          addVertex(lastPointR, u0, 1)\n          addVertex(lastPointL, u0, 0)\n          addVertex(currentPointR, u1, 1)\n\n          addVertex(lastPointL, u0, 0)\n          addVertex(innerPoint, u1, 0)\n          addVertex(currentPointR, u1, 1)\n\n          addVertex(currentPointR, u0, 1)\n          addVertex(innerPoint, u1, 0)\n          addVertex(currentPoint, u1, 0.5)\n\n          addVertex(currentPoint, u1, 0.5)\n          addVertex(innerPoint, u1, 0)\n          addVertex(nextPointR, u0, 1)\n        }\n      }\n    }\n\n    function addCapGeometry(center, p1, p2, joinIsOnLeftSide, start, u) {\n      // param center: End point of the path\n      // param p1, p2: Left and right cap points\n\n      switch (style.strokeLineCap) {\n        case 'round':\n          if (start) {\n            makeCircularSector(center, p2, p1, u, 0.5)\n          } else {\n            makeCircularSector(center, p1, p2, u, 0.5)\n          }\n\n          break\n\n        case 'square':\n          if (start) {\n            tempV2_1.subVectors(p1, center)\n            tempV2_2.set(tempV2_1.y, -tempV2_1.x)\n\n            tempV2_3.addVectors(tempV2_1, tempV2_2).add(center)\n            tempV2_4.subVectors(tempV2_2, tempV2_1).add(center)\n\n            // Modify already existing vertices\n            if (joinIsOnLeftSide) {\n              tempV2_3.toArray(vertices, 1 * 3)\n              tempV2_4.toArray(vertices, 0 * 3)\n              tempV2_4.toArray(vertices, 3 * 3)\n            } else {\n              tempV2_3.toArray(vertices, 1 * 3)\n              // using tempV2_4 to update 3rd vertex if the uv.y of 3rd vertex is 1\n              uvs[3 * 2 + 1] === 1 ? tempV2_4.toArray(vertices, 3 * 3) : tempV2_3.toArray(vertices, 3 * 3)\n              tempV2_4.toArray(vertices, 0 * 3)\n            }\n          } else {\n            tempV2_1.subVectors(p2, center)\n            tempV2_2.set(tempV2_1.y, -tempV2_1.x)\n\n            tempV2_3.addVectors(tempV2_1, tempV2_2).add(center)\n            tempV2_4.subVectors(tempV2_2, tempV2_1).add(center)\n\n            const vl = vertices.length\n\n            // Modify already existing vertices\n            if (joinIsOnLeftSide) {\n              tempV2_3.toArray(vertices, vl - 1 * 3)\n              tempV2_4.toArray(vertices, vl - 2 * 3)\n              tempV2_4.toArray(vertices, vl - 4 * 3)\n            } else {\n              tempV2_4.toArray(vertices, vl - 2 * 3)\n              tempV2_3.toArray(vertices, vl - 1 * 3)\n              tempV2_4.toArray(vertices, vl - 4 * 3)\n            }\n          }\n\n          break\n\n        case 'butt':\n        default:\n          // Nothing to do here\n          break\n      }\n    }\n\n    function removeDuplicatedPoints(points) {\n      // Creates a new array if necessary with duplicated points removed.\n      // This does not remove duplicated initial and ending points of a closed path.\n\n      let dupPoints = false\n      for (let i = 1, n = points.length - 1; i < n; i++) {\n        if (points[i].distanceTo(points[i + 1]) < minDistance) {\n          dupPoints = true\n          break\n        }\n      }\n\n      if (!dupPoints) return points\n\n      const newPoints = []\n      newPoints.push(points[0])\n\n      for (let i = 1, n = points.length - 1; i < n; i++) {\n        if (points[i].distanceTo(points[i + 1]) >= minDistance) {\n          newPoints.push(points[i])\n        }\n      }\n\n      newPoints.push(points[points.length - 1])\n\n      return newPoints\n    }\n  }\n}\n\nexport { SVGLoader }\n"],"names":["Loader","FileLoader","node","ShapePath","Vector2","data","i","Path","current","Matrix3","currentTransform","Vector3","scanlineMinX","scanlineMaxX","p","ShapeUtils","Box2","Shape","BufferGeometry","Float32BufferAttribute","joinIsOnLeftSide","innerSideModified","points"],"mappings":"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"}